<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Advanced Shading Techniques with Pixel Local Storage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('translucency.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced Shading Techniques with Pixel Local Storage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample uses OpenGL ES 3.0 and Pixel Local Storage to perform advanced shading techniques. The sample computes a per-pixel object thickness, and uses it to render a subsurface scattering effect for translucent geometry, without the use of external depth-maps or additional rendertargets.</p>
<div class="image">
<img src="translucency_00.png" alt="translucency_00.png"/>
</div>
<h1><a class="anchor" id="translucencyIntroduction"></a>
Introduction</h1>
<p>This sample uses OpenGL ES 3.0 and the Pixel Local Storage extension to perform advanced shading techniques. A two-pass routine is used to calculate a per-pixel object thickness, and stores it together with material properties in fast on-chip memory known as local storage. The thickness data is used in a deferred shading pass to approximate effects of translucency and subsurface scattering. For efficiency, the stencil buffer is used to mask out relevant objects when computing thickness and performing shading. Finally, the translucent geometry is rendered together with opaque geometry.</p>
<p>The source code for this sample can be found in the folder of the SDK. Feel free to read along with the documentation.</p>
<h1><a class="anchor" id="translucencyTranslucencyAndSubsurfaceScattering"></a>
Translucency and subsurface scattering</h1>
<p>Translucency is the effect of light passing slightly through a material. It is inbetween two extremes - opaque (no light passes through) and transparent (all light passes through). Many materials are somewhat translucent. Light has a tendency to bounce around rather sporadically inside such materials, and brighten parts that were not directly lit in the first place. This effect is called subsurface scattering, and is the holy grail for skin-rendering enthusiasts, but is also relevant for materials such marble, leaves, wax and milk.</p>
<p>As expected, much research effort has been put into how to compute realistic subsurface scattering. In this sample we do the opposite, and aim for the roughest of rough approximations, intended for use when performance is of greater concern than realism. We'll show how you can easily combine the technique with traditional deferred rendering, using the pixel local storage extension. Since we don't rely on additional rendertargets, we also achieve better performance on bandwidth-limited devices, such as mobiles.</p>
<h1><a class="anchor" id="translucencyApproximatedShading"></a>
Approximated translucency shading</h1>
<p>Recent work for real-time approximations tend to use texture-space blurring or rely on additional depth-maps. While these techniques tend to look quite good, they may require significant amounts of memory and moving around of said memory. This is bad for mobile devices, so we'll try not to do that. Instead, this sample will forego the usage of external depth- and texture maps, and rely purely on fast, on-chip local storage. The downside to this is that the effect can become slightly limited, and will therefore be a very, very rough approximation of how scattering works in real-life.</p>
<p>The scattering model we apply is based on Colin Barré-Brisebois' GDC presentation, "Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look" [6]. Simply put, light is attenuated as it travels through a material. And the attenuation is influenced by many things, such as the varying thickness of the object, the view direction and the properties of the light.</p>
<h1><a class="anchor" id="translucencyThickness"></a>
Computing per-pixel object thickness</h1>
<p>In order to perform the shading effect described above, we need to determine how far the light travels inside an object before it reaches the point to be shaded. We approximate this distance by computing the object thickness as seen from the camera, instead of the actual distance travelled by the light. The above mentioned technique uses precomputed thickness maps, but we will compute the object thickness during runtime. Computing the thickness in runtime has the additional benefit of supporting deformation, which may be relevant for dynamic materials such as jelly or milk. To make matters clear, the figure below shows the per-pixel object thickness we compute, t, versus the actual distance the light travels, s.</p>
<div class="image">
<img src="translucency_01.png" alt="translucency_01.png"/>
</div>
<p>The thickness is computed by taking the difference between the maximum and the minimum view-space depth of an object. To simplify matters, we'll only consider the closest object to the camera and assume that the effect of background objects is negligible. This assumption might not hold, but it does prevent overestimating the thickness, which would be a much more apparent artifact. To compute the thickness we use two shader passes.</p>
<p>The first pass is used to determine what the closest object is, and its minimum view-space depth. We render each translucent object with depth testing, and set a unique object identifier in the stencil buffer. Since depth testing is enabled, we can be sure that the final fragment will belong to the closest object. The object ID is simply an integer, greater than 0, that we use in the second pass to determine the max depth for the closest object. For convenience, we reserve the ID of 0 to distinguish translucent geometry from opaque geometry. The view-space depth is stored in pixel local storage, together with material properties in the following layout.</p>
<div class="fragment"><div class="line">__pixel_localEXT FragDataLocal {</div>
<div class="line">    <a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(rgb10_a2) <a class="code" href="structvec4.html">vec4</a> lighting; <span class="comment">// RGBA</span></div>
<div class="line">    <a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(rg16f) <a class="code" href="structvec2.html">vec2</a> minMaxDepth; <span class="comment">// View-space depths</span></div>
<div class="line">    <a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(rgb10_a2) <a class="code" href="structvec4.html">vec4</a> albedo;   <span class="comment">// RGB and sign(normal.z)</span></div>
<div class="line">    <a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(rg16f) <a class="code" href="structvec2.html">vec2</a> normalXY;    <span class="comment">// View-space normal components</span></div>
<div class="line">} storage;</div>
</div><!-- fragment --><p>The fragment shader for this pass writes the material properties and sets both minimum and maximum depth to be the incoming depth. We also clear the lighting variable, which will be used to accumulate lighting in the shading pass later.</p>
<div class="fragment"><div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec3.html">vec3</a> albedo;</div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> vClipPos;</div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_simple_triangle_2jni_2_native_8cpp.html#a8ada611d96d8e1cfb505c37519d64cf3">vPosition</a>;</div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> vNormal;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> n = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(vNormal);</div>
<div class="line">    storage.lighting = <a class="code" href="structvec4.html">vec4</a>(0.0);</div>
<div class="line">    storage.minMaxDepth = <a class="code" href="structvec2.html">vec2</a>(-vPosition.z, -vPosition.z);</div>
<div class="line">    storage.albedo.rgb = albedo;</div>
<div class="line">    storage.albedo.a = sign(n.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a>);</div>
<div class="line">    storage.normalXY = n.xy;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second pass finds the maximum depth of the previously determined closest object. To do this we render the same objects again - without depth testing - but with a stencil test set to equal each object's ID. Since the ID of the closest object is stored in the stencil buffer, only that same object will have fragments that pass through. We can then do a max of the stored max-depth and the incoming depth.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> depth = -vPosition.z;</div>
<div class="line">    storage.minMaxDepth.y = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(depth, storage.minMaxDepth.y);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The figure below shows the resulting object thickness when applied to a scene of two boxes and a teapot.</p>
<div class="image">
<img src="translucency_02.png" alt="translucency_02.png"/>
</div>
<h1><a class="anchor" id="translucencyShadingPass"></a>
Shading pass</h1>
<p>Once the material properties and the view-space thickness have been computed and stored in the local storage, we can perform a shading pass over all translucent geometry. We can use the previously written stencil buffer values for extra efficiency here. By setting the stencil test function to only pass whenever the stored value is greater than zero, we can avoid running the costly lighting computation for fragments that don't contain any translucent geometry. Now let's examine the shader used for the translucency effect.</p>
<div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> lighting(<a class="code" href="structvec3.html">vec3</a> P, <a class="code" href="structvec3.html">vec3</a> Lp, <a class="code" href="structvec3.html">vec3</a> N, <a class="code" href="structvec3.html">vec3</a> V, <span class="keywordtype">float</span> thickness, <span class="keywordtype">float</span> Li, <a class="code" href="structvec3.html">vec3</a> Ldiff, <a class="code" href="structvec3.html">vec3</a> Cdiff)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Compute distance to light from point being shaded</span></div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> = <a class="code" href="gl2ext_8h.html#ab9c919755bde3b34349e23a32b4e0fa7">length</a>(P - Lp);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Apply Blinn-Phong shading model</span></div>
<div class="line">    <span class="comment">// float Iblinn = ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Apply subsurface scattering</span></div>
<div class="line">    thickness = <a class="code" href="noise_8cpp.html#ad601cfd7a14298c6bba5e0cad4c640c7">min</a>(thickness, r);</div>
<div class="line">    <span class="keywordtype">float</span> Isss = sss(P, L, V, N, r, thickness);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Compute attenuation</span></div>
<div class="line">    <span class="comment">// float attenuation = ...</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> attenuation * (Iblinn + Isss) * Ldiff * Cdiff;</div>
<div class="line">}</div>
</div><!-- fragment --><p>First, we compute a standard Blinn-Phong lighting contribution. It will be the prevalent shading when the point being shaded is directly visible from both the light source and the viewer. The next thing we do is to take the minimum of the object thickness and the distance to the light from the shading point. This is done to prevent overestimation of the distance that the light travels through the material. It also blends rather nicely into the case where lights are inside objects. Next we compute the translucency term.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> sss(<a class="code" href="structvec3.html">vec3</a> P, <a class="code" href="structvec3.html">vec3</a> L, <a class="code" href="structvec3.html">vec3</a> V, <a class="code" href="structvec3.html">vec3</a> N, <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>, <span class="keywordtype">float</span> thickness)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> Lt = -(L + N * distortion);</div>
<div class="line">    <span class="keywordtype">float</span> VdotL = pow(<a class="code" href="noise_8cpp.html#ade5e5a7c2668edda2637fd3bdadb85e5">clamp</a>(dot(V, Lt), 0.0, 1.0), sharpness) * <a class="code" href="_roto_zoom_8cpp.html#a5ed0e93b65a00ac5f33de4808f6d6d59">scale</a></div>
<div class="line">    <span class="keywordflow">return</span> (VdotL + ambient) * <a class="code" href="noise_8cpp.html#ade5e5a7c2668edda2637fd3bdadb85e5">clamp</a>(1.0 - thickness * 0.5, 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The basic idea is that thickness attenuates light transmittance. When the thickness is large, the transmitted light intensity will be close to zero. When the object is very thin, the intensity will be somewhat larger. We refer to [6] for more details regarding this lighting model.</p>
<p>Suffice to say, the model first computes the inverted light vector and distorts it by the surface normal. The resulting vector is then dotted with the direction to the viewer, so that light is most prevalent when going through the material and towards the viewer. Similarly to how you would compute a specular, the dot product is raised to a power we denote as <b>sharpness</b>. This controls how focused the light will be.</p>
<p>(The call to pow might shock and horrify most readers, but rest assured, it is optimized in the actual code. See [7] for details.)</p>
<p>There are several interesting parameters that can be adjusted to achieve different visual results. For example, the image below shows the same scene, but adjusted such that the objects transmit less light. A more thorough comparison can be found in [6].</p>
<div class="image">
<img src="translucency_03.png" alt="translucency_03.png"/>
</div>
<h1><a class="anchor" id="translucencyReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] Khronos. "EXT shader pixel local storage", <a href="https://www.khronos.org/registry/gles/extensions/EXT/EXT_shader_pixel_local_storage.txt">available online</a>.</p>
<p><a class="anchor" id="ref2"></a>[2] Marius Bjørge and Sam Martin. "Bandwidth-efficient graphics", <a href="http://twvideo01.ubm-us.net/o1/vault/GDC2014/Presentations/Martin_Sam_The_Revolution_in.pdf">available online</a>.</p>
<p><a class="anchor" id="ref3"></a>[3] Jan-Harald Fredriksen. "Pixel Local Storage on ARM® Mali™ GPUs", <a href="http://community.arm.com/groups/arm-mali-graphics/blog/2014/04/01/pixel-local-storage-on-arm-mali-gpus">available online</a>.</p>
<p><a class="anchor" id="ref4"></a>[4] Jorge Jimenez and David Whelan and Veronica Sundstedt and Diego Gutierrez. "Real-Time Realistic Skin Translucency", <a href="http://www.iryoku.com/translucency/downloads/Real-Time-Realistic-Skin-Translucency.pdf">available online</a></p>
<p><a class="anchor" id="ref5"></a>[5] Henrik Wann Jensen and Stephen R. Marschner and Marc Levoy and Pat Hanrahan. "A Practical Model for Sursurface Light Transport", <a href="http://www.graphics.stanford.edu/papers/bssrdf/bssrdf.pdf">available online</a></p>
<p><a class="anchor" id="ref6"></a>[6] Colin Barré-Brisebois and Marc Bouchard. “Approximating Translucency for a Fast, Cheap and Convincing Subsurface <a class="el" href="class_scattering.html">Scattering</a> Look”, GDC 2011, <a href="http://www.slideshare.net/colinbb/colin-barrebrisebois-gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurfacescattering-look-7170855">available online</a>.</p>
<p><a class="anchor" id="ref7"></a>[7] Colin Barré-Brisebois. "Simplified Spherical Gaussian Exponentiation", <a href="http://colinbarrebrisebois.com/2012/04/09/approximating-translucency-revisited-with-simplified-spherical-gaussian/">available online</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
