<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Metaballs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('metaballs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Metaballs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Using a GPU to create organic-looking 3-dimensional objects in OpenGL ES 3.0.</p>
<div class="image">
<img src="Metaballs.png" alt="Metaballs.png"/>
</div>
<h1><a class="anchor" id="metaballsAbstract"></a>
Abstract</h1>
<p>This tutorial demonstrates how a GPU can be used to render organic-looking 3D objects using OpenGL ES 3.0's transform feedback feature. All calculations are implemented on the GPU's shader processors. Surface triangulation is performed using the Marching Cubes algorithm. The Phong model is used for lighting metaball objects. 3D textures are used to provide access to three dimentional arrays in shaders.</p>
<h1><a class="anchor" id="metaballsIntroduction"></a>
Introduction</h1>
<p>The application displays several metaballs moving in space. When the metaballs come too close to each other they smoothly change their spherical shape before becoming an organic whole. The easiest way to achieve this effect is to follow real life and use the movement of charged spheres. According to physical laws the space surrounding charged spheres will have an electrical field. Because the field at each point in space has only one value, it is often called a scalar field. A scalar field value can be trivially calculated for each point in space (a gravity field is another example of a scalar field, and is calculated using similar formulae, but applied to the weight of the spheres).</p>
<p>To visualize a scalar field we represent it as a surface. This is usually achieved by choosing some value level and displaying a surface containing all points in space with that chosen level. Such surfaces are usually called isosurfaces. The level value is usually chosen empirically based on visual quality.</p>
<p>We need to account for the capabilities of the graphics system we use to draw 3D objects. OpenGL ES can easily render 3D objects, but the only primitives useful to display surfaces that OpenGL ES accepts are triangles. Therefore, we split our model surface and represent it to OpenGL ES as a set of triangles. We have to approximate here, because a mathematically defined isosurface is smooth, whereas a surface constructed of triangles is not. We approximate the surface using the Marching Cubes algorithm.</p>
<p>For the Marching Cubes algorithm to work we sample the space and define the isosurface value. Marching Cubes operates on eight samples at once (one per cell corner), which form the basic cubic cell. Note that this sample uses features found in OpenGL ES3.0. In order for these features to work on your device, you must be using at least Android 4.3 or API version 18.</p>
<h1><a class="anchor" id="metaballsStages"></a>
Stages</h1>
<p>As with most applications dealing with 3D graphics, this example consists of several components. The Metaballs project is constructed from five components: one control program that is run on the CPU and four supplementary shader programs run on the GPU. Usually, programs run on a GPU consist of two parts: a vertex shader and fragment shader. In this example we use eight shaders (two for each stage), but only five shaders contain actual program code; the remaining three shaders are dummy shaders required for the program object to link.</p>
<p>We split the application into the following stages:</p><ol type="1">
<li><a class="el" href="metaballs.html#metaballsStage1">Calculation of sphere positions</a> This stage updates the sphere positions in space for the current time. Here we use transform feedback mode for the first time in the example.</li>
<li><a class="el" href="metaballs.html#metaballsStage2">Scalar field generation</a> This stage breaks the model space into <em>samples_per_axis</em><sup>3</sup> samples and calculates the scalar field value at each point in space.</li>
<li><a class="el" href="metaballs.html#metaballsStage3">Marching Cubes cell-splitting</a> This stage breaks up the scalar field into cubic cells and determines each cell's type. The <em>Cell type</em> identifies whether the isosurface passes through the cell and if so, how it can be approximated with triangles.</li>
<li><a class="el" href="metaballs.html#metaballsStage4">Marching Cubes triangle generation and rendering</a> This stage generates triangles for each cell, appropriate to the cell type.</li>
</ol>
<p>We use transform feedback mode in the first three stages. The transform feedback mode allows us to capture output generated by the vertex shader and to record the output into buffer objects. Its usage is explained in detail in <a class="el" href="metaballs.html#metaballsStage1">Calculation of sphere positions</a>. All four stages are executed for each frame in the rendering loop. Additionally, each stage requires some initialization operations that are executed in the <a class="el" href="_anti_alias_8cpp.html#a5cf4b6142f07f6e9207708e8b8d3398c">setupGraphics()</a> function of the control program.</p>
<h1><a class="anchor" id="metaballsStage1"></a>
Calculation of sphere positions</h1>
<p>Because the whole scene depends on the sphere positions at the currently rendered time, we need to update the positions as a first step. We can keep information describing spheres and their movement equations in the vertex shader, because for further calculations we need only the current sphere positions. This enables us to improve overall performance by minimizing amount of data transferred between CPU and GPU memory. The only input information required for the vertex shader of this stage (<em>spheres_updater_vert_shader</em>) from the control program is the time value, which we declare in the vertex shader as a uniform:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;/** Current time moment. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;uniform float time;\n&quot;</span></div></div><!-- fragment --><p> To pass values from the control program to the shaders, we retrieve a location for the uniforms once the shader program is compiled and linked. For this stage we need to retrieve only the location of the <em>time</em> uniform in the <a class="el" href="_anti_alias_8cpp.html#a5cf4b6142f07f6e9207708e8b8d3398c">setupGraphics()</a> function:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Get input uniform location. */</span></div><div class="line">    <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a75c565a788f789b176eb1f24783fd629">spheres_updater_uniform_time_id</a> = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a3ced5080b54f9aa6d1d8a301570e18ce">spheres_updater_program_id</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a758d332647e56a20074016348bfa0934">spheres_updater_uniform_time_name</a>));</div></div><!-- fragment --><p> During the rendering loop we pass the current time value to the vertex shader with a command:</p>
<div class="fragment"><div class="line">        <span class="comment">/* Specify input arguments to vertex shader. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1f(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a75c565a788f789b176eb1f24783fd629">spheres_updater_uniform_time_id</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a29fcba045d20605dc4bf39427d1c5757">model_time</a>));</div></div><!-- fragment --><p> Now let's take a look at the output values generated in this stage by the vertex shader:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;/** Calculated sphere positions. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;out vec4 sphere_position;\n&quot;</span></div></div><!-- fragment --><p> As you can see in its source code, the shader outputs only four floating point values (packed as vec4s): three sphere coordinates and a sphere weight. To calculate parameters for <em>n_spheres</em> spheres, we instruct OpenGL ES to run the vertex shader <em>n_spheres</em> times. The control program does this by issuing the command during the rendering loop:</p>
<div class="fragment"><div class="line">            <span class="comment">/* Run sphere positions calculation. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_POINTS, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#abd62d106e511290be9aca466c7d540dd">n_spheres</a>));</div></div><!-- fragment --><p> As the calculations of sphere positions are independent of each other, OpenGL ES might (and most often does) run calculations for several spheres at the same time on multiple vertex processors.</p>
<p>Capturing values produced by the vertex shader require us to specify in the control program which varyings (that is, shader output variables) we are interested in before linking the program:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Specify shader varyings (output variables) we are interested in capturing. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTransformFeedbackVaryings(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a3ced5080b54f9aa6d1d8a301570e18ce">spheres_updater_program_id</a>, 1, &amp;<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a1e9757580b856b0341e6c85f0cf77e59">sphere_position_varying_name</a>, GL_SEPARATE_ATTRIBS));</div><div class="line"></div><div class="line">    <span class="comment">/* Link the program object. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glLinkProgram(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a3ced5080b54f9aa6d1d8a301570e18ce">spheres_updater_program_id</a>));</div></div><!-- fragment --><p> Here we specify that we are interested in one value, which is defined in the <em>sphere_position_varying_name</em> constant.</p>
<p>Each calculated sphere position is written into an appropriate place in a buffer attached by the control program. In the <a class="el" href="_anti_alias_8cpp.html#a5cf4b6142f07f6e9207708e8b8d3398c">setupGraphics()</a> function we need to allocate a buffer object and allocate a storage to store values generated by the shader:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffer object id. Define required storage space sufficient to hold sphere positions data. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a71fcb22586408d3c87079cc484d2de08">spheres_updater_sphere_positions_buffer_object_id</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a71fcb22586408d3c87079cc484d2de08">spheres_updater_sphere_positions_buffer_object_id</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_TRANSFORM_FEEDBACK_BUFFER, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#abd62d106e511290be9aca466c7d540dd">n_spheres</a> * <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#af5c4efe36008ba08166e8f0293acb386">n_sphere_position_components</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>), NULL, GL_STATIC_DRAW));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_TRANSFORM_FEEDBACK_BUFFER, 0));</div></div><!-- fragment --><p> Next, we allocate a transform feedback object (TFO), and configure it by binding an appropriate buffer object (in this case <em>spheres_updater_sphere_positions_buffer_object_id</em>) to the GL_TRANSFORM_FEEDBACK_BUFFER target:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate and bind transform feedback object. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTransformFeedbacks(1, &amp;<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac4d6f878996cbaa949c25a3727d15b27">spheres_updater_transform_feedback_object_id</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac4d6f878996cbaa949c25a3727d15b27">spheres_updater_transform_feedback_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Bind buffers to store calculated sphere positions. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a71fcb22586408d3c87079cc484d2de08">spheres_updater_sphere_positions_buffer_object_id</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, 0));</div></div><!-- fragment --><p> In these lines we tell OpenGL ES to store the output values in the buffer when transform feedback mode is activated. This TFO is activated by binding it to the GL_TRANSFORM_FEEDBACK target. That's exactly what we do as the first step during the rendering process:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Bind buffers to store calculated sphere position values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac4d6f878996cbaa949c25a3727d15b27">spheres_updater_transform_feedback_object_id</a>));</div></div><!-- fragment --><p> After that, we need to prepare the transform feedback mode to be useful for our purposes: we don't need primitives to be rendered at this stage and we want to capture data. The first command shortens the OpenGL pipeline by discarding any primitives generated by the vertex shader:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Shorten GL pipeline: we will use vertex shader only. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_RASTERIZER_DISCARD));</div></div><!-- fragment --><p> The second command activates the transform feedback mode itself, instructing OpenGL ES to capture and store the specified primitives into the buffer object:</p>
<div class="fragment"><div class="line">        <span class="comment">/* Activate transform feedback mode. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBeginTransformFeedback(GL_POINTS));</div></div><!-- fragment --><p> When we're done, we issue paired commands to deactivate transform feedback mode:</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEndTransformFeedback());</div></div><!-- fragment --><p> And another to restore the OpenGL ES pipeline:</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDisable(GL_RASTERIZER_DISCARD));</div></div><!-- fragment --><p> To sum up, here is the complete listing for this stage:</p>
<div class="fragment"><div class="line">    <span class="comment">/* 1. Calculate sphere positions stage.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * At this stage we calculate new sphere positions in space</span></div><div class="line"><span class="comment">     * according to current time moment.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* [Stage 1 Bind buffers to store calculated sphere position values] */</span></div><div class="line">    <span class="comment">/* Bind buffers to store calculated sphere position values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac4d6f878996cbaa949c25a3727d15b27">spheres_updater_transform_feedback_object_id</a>));</div><div class="line">    <span class="comment">/* [Stage 1 Bind buffers to store calculated sphere position values] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* [Stage 1 Enable GL_RASTERIZER_DISCARD] */</span></div><div class="line">    <span class="comment">/* Shorten GL pipeline: we will use vertex shader only. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_RASTERIZER_DISCARD));</div><div class="line">    <span class="comment">/* [Stage 1 Enable GL_RASTERIZER_DISCARD] */</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Select program for sphere positions generation stage. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a3ced5080b54f9aa6d1d8a301570e18ce">spheres_updater_program_id</a>));</div><div class="line"></div><div class="line">        <span class="comment">/* [Stage 1 Specify input arguments to vertex shader] */</span></div><div class="line">        <span class="comment">/* Specify input arguments to vertex shader. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1f(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a75c565a788f789b176eb1f24783fd629">spheres_updater_uniform_time_id</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a29fcba045d20605dc4bf39427d1c5757">model_time</a>));</div><div class="line">        <span class="comment">/* [Stage 1 Specify input arguments to vertex shader] */</span></div><div class="line"></div><div class="line">        <span class="comment">/* [Stage 1 Activate transform feedback mode] */</span></div><div class="line">        <span class="comment">/* Activate transform feedback mode. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBeginTransformFeedback(GL_POINTS));</div><div class="line">        <span class="comment">/* [Stage 1 Activate transform feedback mode] */</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* [Stage 1 Execute n_spheres times vertex shader] */</span></div><div class="line">            <span class="comment">/* Run sphere positions calculation. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_POINTS, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#abd62d106e511290be9aca466c7d540dd">n_spheres</a>));</div><div class="line">            <span class="comment">/* [Stage 1 Execute n_spheres times vertex shader] */</span></div><div class="line">        }</div><div class="line">        <span class="comment">/* [Stage 1 Deactivate transform feedback mode] */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEndTransformFeedback());</div><div class="line">        <span class="comment">/* [Stage 1 Deactivate transform feedback mode] */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* [Stage 1 Disable GL_RASTERIZER_DISCARD] */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDisable(GL_RASTERIZER_DISCARD));</div><div class="line">    <span class="comment">/* [Stage 1 Disable GL_RASTERIZER_DISCARD] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Unbind buffers used at this stage. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, 0));</div></div><!-- fragment --> <h1><a class="anchor" id="metaballsStage2"></a>
Scalar field generation</h1>
<p>There are very few differences in the control program between this stage and the first stage:</p>
<div class="fragment"><div class="line">    <span class="comment">/* 2. Scalar field generation stage.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * At this stage we calculate scalar field and store it in buffer</span></div><div class="line"><span class="comment">     * and later copy from buffer to texture.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* Bind sphere positions data buffer to GL_UNIFORM_BUFFER. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_UNIFORM_BUFFER, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a71fcb22586408d3c87079cc484d2de08">spheres_updater_sphere_positions_buffer_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Bind buffer object to store calculated scalar field values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#aa4b0597eb89b1831629145cca3ab4f89">scalar_field_transform_feedback_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Shorten GL pipeline: we will use vertex shader only. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_RASTERIZER_DISCARD));</div><div class="line">    {</div><div class="line">        <span class="comment">/* Select program for scalar field generation stage. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram(<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ab073c43a2272a8bfcabd553495a545bb">scalar_field_program_id</a>));</div><div class="line"></div><div class="line">        <span class="comment">/* Activate transform feedback mode. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBeginTransformFeedback(GL_POINTS));</div><div class="line">        {</div><div class="line">            <span class="comment">/* Run scalar field calculation for all vertices in space. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_POINTS, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a324c4c6b4f305ebfddd50bba1d66d92e">samples_in_3d_space</a>));</div><div class="line">        }</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEndTransformFeedback());</div><div class="line">    }</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDisable(GL_RASTERIZER_DISCARD));</div><div class="line"></div><div class="line">    <span class="comment">/* Unbind buffers used at this stage. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTransformFeedback(<a class="code" href="gl2ext_8h.html#a694f38d57c753e86c2167310f5d3d3b3">GL_TRANSFORM_FEEDBACK</a>, 0));</div></div><!-- fragment --><p> Although we use different program, buffer and transform feedback objects, the general flow of operations in the control program is the same as the first stage. This is because at this stage we again use the transform feedback mechanism and only need to specify input and output variables to vertex shader, which will do the actual work. The only differing command is the first one, which binds the buffer object to GL_UNIFORM_BUFFER target. By issuing this command we make the sphere positions that were generated and collected in the buffer object during the first stage available to the vertex shader at this stage. Unfortunately, only a relatively small amount of data can be passed to shaders using this mechanism due to limitations in OpenGL ES. It is also worth noticing that we instruct OpenGL ES to run the shader program <em>samples_in_3d_space</em> times, which will be explained below.</p>
<p>The main difference is in the stage's vertex shader, which we'll examine after looking at the ideas of the stage.</p>
<p>As you know, the gravity field value generated by an object with mass M in a point in space at distance D from the object directly correlates with that mass and square of that distance, i.e. FV=M/(D<sup>2</sup>). In order to have a physical meaning for this formula we also need to introduce a constant coefficient, but for the purposes of this example it can be omitted. The gravity field value generated by multiple objects is calculated as sum of all field values, i.e. FV<sub>total</sub>=&Sigma;FV<sub>i</sub>. In this example we'll use term weight instead of mass, which while not as correct as mass is usually easier to understand.</p>
<p>It is hard to deal with surfaces as defined mathematically, so as in many other sciences we simplify the task by sampling the space. We use <em>tesselation_level</em>=32 samples for each axis, which provides us with 32*32*32 or 32768 points in space for which a scalar field value should be calculated. You may try to increase this value to increase the quality of the image generated.</p>
<p>If you take a look at the forumlae above, you may notice that the scalar field value depends only on the positions and masses (weights) of all spheres. This enables us to calculate the field value for several points in space at the same time in different shader programs.</p>
<p>As input data, the vertex shader expects the number of samples on each axis and the sphere positions stored in the buffer:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;/* Uniforms: */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;/** Amount of samples taken for each axis of a scalar field; */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;uniform int samples_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;/** Uniform block encapsulating sphere locations. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;uniform spheres_uniform_block\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    vec4 input_spheres[N_SPHERES];\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;};\n&quot;</span></div></div><!-- fragment --><p> As you can see, the number of spheres stored in buffer is hardcoded here by using a preprocessor define. That's the limitation of shaders: they need to know the exact number of items in the incoming uniform buffer. If you need to make shader more flexible, you may reserve more space in the buffer and ignore items based on some flag or by validating some value (for example zero weight value). Another approach is to use a texture as input array of data, which we will use in <a class="el" href="metaballs.html#metaballsStage2">Scalar field generation</a>.</p>
<p>Each vertex shader run in this stage starts execution by decoding the point in space for which the shader is running:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;/** Decode coordinates in space from vertex number.\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; *  Assume 3D space of samples_per_axis length for each axis and following encoding:\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; *  encoded_position = x + y * samples_per_axis + z * samples_per_axis * samples_per_axis\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; *\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; *  @param  vertex_index Encoded vertex position\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; *  @return              Coordinates of a vertex in space ranged [0 .. samples_per_axis-1]\n&quot;</span></div><div class="line"><span class="stringliteral">&quot; */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;ivec3 decode_space_position(in int vertex_index)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   encoded_position = vertex_index;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    ivec3 space_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Calculate coordinates from vertex number. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.x = encoded_position % samples_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position = encoded_position / samples_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.y = encoded_position % samples_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position = encoded_position / samples_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.z = encoded_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return space_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> This is a quite widely used technique where the built in <em>OpenGL ES Shading Language</em> variable <b>gl_VertexID</b> is used as an implicit parameter. Each executed vertex shader has its own unique value passed via gl_VertexID with the range zero to the value of the <em>count</em> parameter passed into the glDrawArrays call. Based on the gl_VertexID value, the shader can control its execution appropriately. In this function the shader splits value of <b>gl_VertexID</b> into x, y, z coordinates of point in space for which the shader should calculate the scalar field value.</p>
<p>To make a scalar field value independent from the <em>tesselation_level</em>, the shader normalizes the point in space's coordinates to the range [0..1]:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;vec3 normalize_space_position_coordinates(in ivec3 space_position)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    vec3 normalized_space_position = vec3(space_position) / float(samples_per_axis - 1);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return normalized_space_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> It then calculates the scalar field value:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;float calculate_scalar_field_value(in vec3 position)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    float field_value = 0.0f;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Field value in given space position influenced by all spheres. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    for (int i = 0; i &lt; N_SPHERES; i++)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    {\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3  sphere_position         = input_spheres[i].xyz;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        float vertex_sphere_distance  = length(distance(sphere_position, position));\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* Field value is a sum of all spheres fields in a given space position.\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;         * Sphere weight (or charge) is stored in w-coordinate.\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;         */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        field_value += input_spheres[i].w / pow(max(EPSILON, vertex_sphere_distance), 2.0);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    }\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return field_value;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> And finally the shader outputs the calculated scalar field value using the only output variable declared in the shader:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;/* Output data: */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;/** Calculated scalar field value. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;out float scalar_field_value;\n&quot;</span></div></div><!-- fragment --><p> At the end of this stage we have scalar field values calculated and stored in the buffer object for each point in space. Unfortunately, large buffer objects cannot be used as input data. That's why at the end of this stage we need to perform one more operation: we apply another widespread OpenGL ES technique and transfer the data from the buffer object into a texture. This is performed in the control program:</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE1));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer   (GL_PIXEL_UNPACK_BUFFER, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a22d99a8f198b4d563a841af71deebf90">scalar_field_buffer_object_id</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexSubImage3D(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>,    <span class="comment">/* Use texture bound to GL_TEXTURE_3D                                     */</span></div><div class="line">                             0,                <span class="comment">/* Base image level                                                       */</span></div><div class="line">                             0,                <span class="comment">/* From the texture origin                                                */</span></div><div class="line">                             0,                <span class="comment">/* From the texture origin                                                */</span></div><div class="line">                             0,                <span class="comment">/* From the texture origin                                                */</span></div><div class="line">                             <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>, <span class="comment">/* Texture have same width as scalar field in buffer                      */</span></div><div class="line">                             <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>, <span class="comment">/* Texture have same height as scalar field in buffer                     */</span></div><div class="line">                             <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>, <span class="comment">/* Texture have same depth as scalar field in buffer                      */</span></div><div class="line">                             GL_RED,           <span class="comment">/* Scalar field gathered in buffer has only one component                 */</span></div><div class="line">                             GL_FLOAT,         <span class="comment">/* Scalar field gathered in buffer is of float type                       */</span></div><div class="line">                             NULL              <span class="comment">/* Scalar field gathered in buffer bound to GL_PIXEL_UNPACK_BUFFER target */</span></div><div class="line">                            ));</div></div><!-- fragment --><p> The first command above activates texture unit one, the second command specifies the source data buffer, and the third command performs the actual transfer of data from the buffer object into the texture object currently bound to the GL_TEXTURE_3D target at a specific binding point. We use the 3D textures as a convenient way to access the data as a 3D array in the next shader stage.</p>
<p>The texture bound to the GL_TEXTURE_3D target point of texture unit one is created and initialized to contain an appropriate number of scalar field values in the <a class="el" href="_anti_alias_8cpp.html#a5cf4b6142f07f6e9207708e8b8d3398c">setupGraphics()</a> function:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate texture object to hold scalar field data. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac27f0ae47abeaef9c35bf5b97ae9bd8a">scalar_field_texture_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Scalar field uses GL_TEXTURE_3D target of texture unit 1. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE1));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ac27f0ae47abeaef9c35bf5b97ae9bd8a">scalar_field_texture_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare texture storage for scalar field values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, 1, GL_R32F, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#acbed55c45773c444de68a3207a53fb56">samples_per_axis</a>));</div></div><!-- fragment --> <h1><a class="anchor" id="metaballsStage3"></a>
Marching Cubes cell-splitting</h1>
<p>The last two stages actually implement the Marching Cubes algorithm. The algorithm is one of the ways to create a polygonal surface representation of a 3D scalar field isosurface <a href="#ref1">[1]</a>, <a href="#ref2">[2]</a>. The algorithm breaks the scalar field into cubic cells. Each cell corner has one scalar field value. By performing a simple compare operation between the isosurface level and the scalar field value in the cell corner, it can be determined whether the corner is below the isosurface or not. If one corner of a cell is below the isosurface and another corner on same cell edge is above the isosurface then obviously the isosurface crosses the edge. Also, due to field continuity and smoothness, there will be other crossed edges in same cell. Using edge cross points, a polygon can be generated that will best approximate the isosurface. Now let's take a look at the algorithm from the other side. The state of each cell corner can be represented as a boolean value: either the corner is above the isosurface (appropriate bit set to <em>1</em>) or not (appropriate bit set to <em>0</em>). It is obvious that having eight corners in a cell we have 2<sup>8</sup>, i.e. 256 cases where corners are either above or below the isosurface. If a surfaces passes straight through a corner we assume the corner is below the isosurface, to keep the state binary. In other words, the isosurface can pass through the cell in one of 256 ways. Thus with 256 cell types we can describe a set of triangles to be generated in order for the cell to approximate an isosurface.</p>
<p>At this stage we divide the space by the cells and identify cell types. The space was already divided by samples at a previous stage (<a class="el" href="metaballs.html#metaballsStage2">Scalar field generation</a>) and the shader takes eight samples in cell corners to form a cell. Using the isosurface level value, the shader identifies a cell type for each cell according to the algorithm described above.</p>
<p>Stage three of the control program is even closer to the stage two control program, so we won't describe the whole thing. We will, however, pay some attention to texture creation in the <a class="el" href="_anti_alias_8cpp.html#a5cf4b6142f07f6e9207708e8b8d3398c">setupGraphics()</a> function:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate a texture object to hold cell type data. (We will explain why the texture later). */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a10e5f16ade591046f30e1f9cdaae8cf6">marching_cubes_cells_types_texture_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Marching cubes cell type data uses GL_TEXTURE_3D target of texture unit 2. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE2));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a10e5f16ade591046f30e1f9cdaae8cf6">marching_cubes_cells_types_texture_object_id</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare texture storage for marching cube cell type data. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, 1, GL_R32I, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a9ce5e0036f4d711df70fec872454cb15">cells_per_axis</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a9ce5e0036f4d711df70fec872454cb15">cells_per_axis</a>, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a9ce5e0036f4d711df70fec872454cb15">cells_per_axis</a>));</div></div><!-- fragment --><p> Notice that here we use texture unit two and create a 3D texture of one-component integers (GL_R32I), which will hold types for each of the 31*31*31 cells. The number of cells on each axis (<em>cells_per_axis</em>) is one less than the number of samples on each axis (<em>samples_per_axis</em>). It is easier to explain why using an example: let's imagine that we cut a butter brick into two halves (cells). Parallel to the cut plane we have three sides for two cells (one is shared by both halves). Thus the number of cells is one less than the number of sides. The control program instructs the GPU to execute the vertex shader for each cell:</p>
<div class="fragment"><div class="line">            <span class="comment">/* Run Marching Cubes algorithm cell splitting stage for all cells. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_POINTS, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a58d470851c6374698db0390076b5ed6a">cells_in_3d_space</a>));</div></div><!-- fragment --><p> In this stage's vertex shader we first decode the position in space of the origin point of the cell processed by this instance of the shader in a way similar to what we did in the previous stage. The only difference is that here as a divisor, we use the number of cells on each axis and not the number of samples:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;ivec3 decode_space_position(in int cell_index)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    ivec3 space_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   encoded_position = cell_index;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Calculate coordinates from encoded position */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.x       = encoded_position % cells_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position       = encoded_position / cells_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.y       = encoded_position % cells_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position       = encoded_position / cells_per_axis;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    space_position.z       = encoded_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return space_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> The shader then gathers the scalar field values for the corners of current cell into an array by extracting scalar values from the texture, which was created during the previous stage (<a class="el" href="metaballs.html#metaballsStage2">Scalar field generation</a>):</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    /* Find scalar field values in cell corners. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    for (int i = 0; i &lt; corners_in_cell; i++)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    {\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* Calculate cell corner processed at this iteration. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        ivec3 cell_corner = space_position + cell_corners_offsets[i];\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* Calculate cell corner&#39;s actual position ([0.0 .. 1.0] range.) */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 normalized_cell_corner  = vec3(cell_corner) / scalar_field_normalizers;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* Get scalar field value in cell corner from scalar field texture. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        scalar_field_in_cell_corners[i] = textureLod(scalar_field, normalized_cell_corner, 0.0).r;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    }\n&quot;</span></div></div><!-- fragment --><p> Having the values of the scalar field in the cell corners, and the isosurface level value, we can determine the cell type:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;int get_cell_type_index(in float cell_corner_field_value[8], in float isolevel)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int cell_type_index = 0;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Iterate through all cell corners. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    for (int i = 0; i &lt; 8; i++)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    {\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* If corner is inside isosurface then set bit in cell type index index. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        if (cell_corner_field_value[i] &lt; isolevel)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        {\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;            /* Set appropriate corner bit in cell type index. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;            cell_type_index |= (1&lt;&lt;i);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        }\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    }\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return cell_type_index;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> The cell type is returned by this stage and stored in an appropriate buffer for further processing during the next stage.</p>
<h1><a class="anchor" id="metaballsStage4"></a>
Marching Cubes triangle generation and rendering</h1>
<p>The Marching Cubes algorithm approximates a surface passing through the cell with up to five triangles. For cell types 0 and 255 it generates no triangles, due to the fact that all the cell corners are either below or above the isosurface. Using a lookup table indexed by cell types (<em>tri_table</em>) is an efficient way to get a list of triangles generated for the cell.</p>
<p>Finally, we have all the information needed to generate a set of triangles and to render them. For this stage the control program does not activate transform feedback mode, because there is no need to store any generated triangle vertices. It is more useful to pass the generated triangle vertices to the fragment shader for culling or rendering:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Run triangle generating and rendering program. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a58d470851c6374698db0390076b5ed6a">cells_in_3d_space</a> * <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#ae00eaee8c8400c18da7da52a70c01b93">triangles_per_cell</a> * <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#aa57c5e51f9347c36bc343e341a3c3418">vertices_per_triangle</a>));</div></div><!-- fragment --><p> If you take a look at the constant values, you might notice that here we instruct OpenGL ES to run the shader fifteen times for each cell. This multiplier comes from the Marching Cubes algorithm: an isosurface passing through a cell and intersecting each edge no more than once can be approximated with up to five triangles, and we use three vertices to define one triangle. Notice also that the algorithm does not use the cell corners to build triangles, but instead uses the "middle" points of the cell. In this case, the "middle" point is a point on the cell edge where that edge is actually intersected by an isosurface. This provides better image quality.</p>
<p>Each cell can produce maximum of five triangles according to its cell type, but most of the cell types produce significantly fewer triangles. For an example, look at <em>tri_table</em>, which is used to build triangles out of cell types. We present first four cell types out of 256 here:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> GLint <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a35bf16164e2cb74780fd76b21c1391b9">tri_table</a>[<a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a9ee4e21cd9c66ce12a3571972dd5385c">mc_cells_types_count</a> * <a class="code" href="advanced__samples_2_metaballs_2jni_2_native_8cpp.html#a6f8e000bed70fd541a39e3549d9256b4">mc_vertices_per_cell</a>] =</div><div class="line">{</div><div class="line">  -1, -1, -1,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,</div><div class="line">   0,  8,  3,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,</div><div class="line">   0,  1,  9,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,</div><div class="line">   1,  8,  3,     9,  8,  1,    -1, -1, -1,    -1, -1, -1,    -1, -1, -1,</div></div><!-- fragment --><p> Each row in the table represents one cell type. Each cell type contains up to five triangles. Each triangle is defined by three sequential vertices. Each number in the table is a number of a cell edge, of which the "middle" point is taken as a triangle vertex. If the cell type provides fewer than five triangles, then the extra edge numbers are filled with the value -1. For example, cell type 0 (first data line) does not define any triangles: all of its "middle" points are set to -1. Cell type 1 (second data line) defines one triangle consisting of the "middle" points of edges 0, 8 and 3 of a cell. Cell type 2 defines a single triangle again, while cell type 3 defines two triangles. An observant reader might notice that the number of cell edges in the table is less than 12. This is because the cell cube has only 12 edges, which are numbered in the table from 0 to 11 inclusive.</p>
<p>Each vertex shader instance processes only one vertex of a triangle. At first, based on <em>gl_VertexID</em> it decodes the triangle vertex number and the position of the cell it processes in a way similar to <a class="el" href="metaballs.html#metaballsStage2">Scalar field generation</a> :</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;ivec4 decode_cell_position(in int encoded_position_argument)\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;{\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    ivec4 cell_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   encoded_position = encoded_position_argument;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Decode combined triangle and vertex number. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    cell_position.w  = encoded_position % mc_vertices_per_cell;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position = encoded_position / mc_vertices_per_cell;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Decode coordinates from encoded position. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    cell_position.x  = encoded_position % CELLS_PER_AXIS;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position = encoded_position / CELLS_PER_AXIS;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    cell_position.y  = encoded_position % CELLS_PER_AXIS;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    encoded_position = encoded_position / CELLS_PER_AXIS;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    cell_position.z  = encoded_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    return cell_position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;}\n&quot;</span></div></div><!-- fragment --><p> Here, the decoding is one step longer: besides the cell coordinates it also decodes the combined triangle and vertex number. We store this information in the <a class="el" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main()</a> function's local variables for further processing:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    /* Split gl_vertexID into cell position and vertex number processed by this shader instance. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    ivec4 cell_position_and_vertex_no = decode_cell_position(gl_VertexID);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    ivec3 cell_position               = cell_position_and_vertex_no.xyz;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   triangle_and_vertex_number  = cell_position_and_vertex_no.w;\n&quot;</span></div></div><!-- fragment --><p> Having obtained coordinates, the shader can retrieve cell type and cell edge number:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;    /* Get cell type for cell current vertex belongs to. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   cell_type_index             = get_cell_type(cell_position);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    /* Get edge of the cell to which belongs processed vertex. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;    int   edge_number                 = get_edge_number(cell_type_index, triangle_and_vertex_number);\n&quot;</span></div></div><!-- fragment --><p> From here we proceed only if the shader should generate a vertex (i.e. the edge number is not equal to -1). The discarding of dummy triangle vertices will be considered later.</p>
<p>From the cell coordinates we can calculate the coordinates of the origin point of the cell:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;        /* Calculate normalized coordinates in space of cell origin corner. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 cell_origin_corner    = vec3(cell_position) / float(samples_per_axis - 1);\n&quot;</span></div></div><!-- fragment --><p> Having coordinates of the cell origin point and the edge number (of which "middle" point we are currently calculating), we can find the cell corner vertices at which this particular edge begins and ends:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;        /* Calculate start and end edge coordinates. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 start_corner          = get_edge_coordinates(cell_origin_corner, edge_number, true);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 end_corner            = get_edge_coordinates(cell_origin_corner, edge_number, false);\n&quot;</span></div></div><!-- fragment --><p> Now, having the values of the scalar field in the beginning and end vertices of the edge and the isosurface level value we can calculate the exact position at which the isosurface crosses the edge:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;        /* Calculate share of start point of an edge. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        float start_vertex_portion = get_start_corner_portion(start_corner, end_corner, iso_level);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        /* Calculate &#39;&#39;middle&#39;&#39; edge vertex. This vertex is moved closer to start or end vertices of the edge. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 edge_middle_vertex    = mix(end_corner, start_corner, start_vertex_portion);\n&quot;</span></div></div><!-- fragment --><p> And for lighting we calculate a normal vector to the isosurface:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;        /* Calculate normal to surface in the &#39;&#39;middle&#39;&#39; vertex. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        vec3 vertex_normal         = calc_phong_normal(start_vertex_portion, start_corner, end_corner);\n&quot;</span></div></div><!-- fragment --><p> The normal vector to the surface in the edge "middle" point is calculated as a mixture of normal vectors in the beginning and end edge vertices. The normal vector in the beginning and end edge vertices is calculated using partial derivatives of the scalar field, which are calculated using the scalar field values adjacent to the vertex scalar field values. For more information on calculating a normal vector to a surface please take a look at <a href="#ref3">[3]</a>. It is assumed that you are already familiar with this lighting technique, so we will not focus on describing the effect in detail.</p>
<p>If it turns out that the shader processes a vertex of a triangle that should not be generated (the edge number is -1), then it drops processing the vertex by specifying coordinates that match all other vertices of the dummy triangle:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;        /* This cell type generates fewer triangles, and this particular one should be discarded. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        gl_Position                = vec4(0);                                    /* Discard vertex by setting its coordinate in infinity. */\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        phong_vertex_position      = gl_Position;\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        phong_vertex_normal_vector = vec3(0);\n&quot;</span></div><div class="line"><span class="stringliteral">&quot;        phong_vertex_color         = vec3(0);\n&quot;</span></div></div><!-- fragment --><p> It would be more optimal to use a geometry shader for this stage, which (unlike a vertex shader) could generate as many vertices as required, or none at all. However, geometry shaders are an OpenGL feature and not present in core OpenGL ES, so we need to do the job in a vertex shader, discarding inappropriate triangles by specifying all their vertex coordinates to the same value.</p>
<p>The fragment shader implements a simple Phong lighting model <a href="#ref4">[4]</a>. For more information, look at the code comments in the fragment shader of the Marching Cubes triangle generation and rendering stage.</p>
<h1><a class="anchor" id="metaballsReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://paulbourke.net/geometry/polygonise/">http://paulbourke.net/geometry/polygonise/</a> <br />
<a class="anchor" id="ref2"></a>[2] <a href="http://en.wikipedia.org/wiki/Marching_cubes">http://en.wikipedia.org/wiki/Marching_cubes</a> <br />
<a class="anchor" id="ref3"></a>[3] <a href="http://mathworld.wolfram.com/NormalVector.html">http://mathworld.wolfram.com/NormalVector.html</a> <br />
<a class="anchor" id="ref4"></a>[4] <a href="http://en.wikipedia.org/wiki/Phong_shading">http://en.wikipedia.org/wiki/Phong_shading</a> <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
