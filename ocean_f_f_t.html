<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Ocean Rendering with Fast Fourier Transform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ocean_f_f_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Ocean Rendering with Fast Fourier Transform </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample will show you how to efficiently implement high quality ocean water rendering using compute shaders in OpenGL ES 3.1.</p>
<div class="image">
<img src="ocean.png" alt="ocean.png"/>
</div>
<h1><a class="anchor" id="oceanIntroduction"></a>
Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>This sample uses OpenGL ES 3.1.</dd>
<dd>
This sample makes use of Tessellation shaders and RGBA16F framebuffer extensions when supported by the device.</dd>
<dd>
This sample assumes good knowledge of OpenGL ES 3.1 compute shaders.</dd></dl>
<p>The ocean rendering technique in this sample is based on the well-known water rendering paper by J. Tessendorf <a href="#ref1">[1]</a> which implements heightmap generation by synthesizing a very large number of waves using the Fast Fourier Transform.</p>
<p>The main principle of Ocean rendering is that it can be modelled very well by thinking of it a sum of "infinite" waves at different amplitudes travelling in different directions.</p>
<p>Summing up a large number of sinusoids is very intensive with a naive approach, and has complexity O(M * N) if synthesizing M waves into N samples in one dimension. Increasing this to two dimensions and we end up with a terrible O(M * N^2) complexity. With simpler water techniques, very few waves are therefore used instead and the sinusoids are accumulated directly. For realistic looking water, we would really prefer the number of waves to be the same as number of samples.</p>
<p>The inverse fast Fourier transform does this excellently, using only O(2N * (N * log2(N))) complexity for a 2D NxN grid to synthesize NxN waves. For reasonable values (this sample uses N = 256), this can be done very efficiently on GPUs.</p>
<h1><a class="anchor" id="oceanFFTWaves"></a>
The Fast Fourier Transform for Ocean Waves</h1>
<p>There are many excellent introductions to the Fast Fourier Transforms, so only a short introduction will be provided here. The core of the Fourier Transform is a transform which converts from the time/spatial domain to frequency domain and back. The mathematical formulation of the discrete (forward) Fourier Transform is:</p>
<div class="fragment"><div class="line">X[k] = sum n from 0 to <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a> - 1: <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[<a class="code" href="gl2ext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>] * exp(-j * k * 2 * pi * n / <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</div>
</div><!-- fragment --><p>and inverse Fourier Transform which we're mostly interested in here:</p>
<div class="fragment"><div class="line"><span class="comment">// Only real difference is the sign of j.</span></div>
<div class="line"><a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>[<a class="code" href="gl2ext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>] = sum k from 0 to <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a> - 1: X[k] * exp(j * n * 2 * pi * k / <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</div>
</div><!-- fragment --><p>j is the imaginary constant sqrt(-1) which is also knows as "i". Thus, the Fourier Transform is formulated with complex numbers. Taking the exponential of an imaginary number might look weird at first, but it can be shown using Taylor expansion that exp(j * x) is equivalent to</p>
<div class="fragment"><div class="line">exp(j * <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>) = cos(<a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>) + j * sin(<a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>)</div>
</div><!-- fragment --><p>If we imagine that the real and imaginary numbers form a 2D plane, exp(j * x) looks very much like rotation with angle x. In fact, we can simply think of exp(j * x) as a complex oscillator.</p>
<p>This is the core of ocean wave synthesis. In the frequency domain, we will create waves with certain amplitudes and phases, and use the inverse Fourier transform to generate a sum of sinusoids. To move the water, we simply need to modify the phases in the frequency domain and do the inverse FFT over again.</p>
<p>Since the FFT assumes repeating inputs, the heightmap will be tiled with GL_REPEAT wrapping mode. As long as the heightmap is large enough, the tiling effect should not be particularly noticable.</p>
<p>The GPU FFT implementation used in this sample is based on the <a class="el" href="namespace_g_l_f_f_t.html">GLFFT</a> library <a href="#ref2">[2]</a>. The FFT implementation in <a class="el" href="namespace_g_l_f_f_t.html">GLFFT</a> is inspired by work from E. Bainville <a href="#ref3">[3]</a> which contain more details on how FFT can be implemented efficiently on GPUs.</p>
<h2><a class="anchor" id="oceanGeneration"></a>
Procedurally generating frequency domain samples</h2>
<p>The ocean is a random process in that the amplitudes and phases of waves are quite random, however, their statistical distributions are greatly affected by wind and can be modelled quite well. The Tessendorf paper <a href="#ref1">[1]</a> uses the Phillips spectrum which gives the estimated variance for waves at certain wavelengths based on wind direction and speed.</p>
<p>Based on this formula, we generate a random two-dimensional buffer with initial phase and amplitude data for the heightmap and upload this to the GPU only at startup.</p>
<div class="fragment"><div class="line"><a class="code" href="fftwater_8hpp.html#ae32f8747bac5f5ebe592f8a45ff2223a">cfloat</a> <a class="code" href="class_f_f_t_water.html#aebd49ffcfb641ef4145fb93a1a41e6ee">FFTWater::phillips</a>(<a class="code" href="structvec2.html">vec2</a> k, <span class="keywordtype">float</span> max_l)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> k_len = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7acb7d81f3dea352ba654b2f72da2b0c">vec_length</a>(k);</div>
<div class="line">    <span class="keywordflow">if</span> (k_len == 0.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> kL = k_len * <a class="code" href="class_f_f_t_water.html#ab6a82186878a7c432e854aabc7f6265b">L</a>;</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> k_dir = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(k);</div>
<div class="line">    <span class="keywordtype">float</span> kw = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(k_dir, <a class="code" href="class_f_f_t_water.html#ae223a7af079e2a0078a52da427494378">wind_dir</a>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span></div>
<div class="line">        pow(kw * kw, 1.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>) *        <span class="comment">// Directional</span></div>
<div class="line">        exp(-1.0 * k_len * k_len * max_l * max_l) * <span class="comment">// Suppress small waves at ~max_l.</span></div>
<div class="line">        exp(-1.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a> / (kL * kL)) *</div>
<div class="line">        pow(k_len, -4.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="class_f_f_t_water.html#ac3fae5744f3994a03ffc65c60d9b6f28">FFTWater::generate_distribution</a>(<a class="code" href="fftwater_8hpp.html#ae32f8747bac5f5ebe592f8a45ff2223a">cfloat</a> *distribution, <a class="code" href="structvec2.html">vec2</a> size, <span class="keywordtype">float</span> amplitude, <span class="keywordtype">float</span> max_l)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> mod = <a class="code" href="structvec2.html">vec2</a>(2.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a> * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>) / <a class="code" href="class_f_f_t_water.html#a1647525ae1c34faef6a29e9ecd570452">size</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> z = 0; z &lt; <a class="code" href="class_f_f_t_water.html#a2d4b475dde6fbfb2f5e82ca6e60a69b8">Nz</a>; z++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a> = 0; <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a> &lt; <a class="code" href="class_f_f_t_water.html#a18a6aca197721e59ac5ba6b0e9766a62">Nx</a>; <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span> &amp;<a class="code" href="gl2ext_8h.html#a55f85da29bf761fde63cc95d26300230">v</a> = distribution[z * Nx + <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>];</div>
<div class="line">            <a class="code" href="structvec2.html">vec2</a> k = mod * <a class="code" href="structvec2.html">vec2</a>(<a class="code" href="fftwater_8cpp.html#a353783a6b8955acf3695b87f85785c38">alias</a>(<a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, Nx), <a class="code" href="fftwater_8cpp.html#a353783a6b8955acf3695b87f85785c38">alias</a>(z, Nz));</div>
<div class="line">            <a class="code" href="fftwater_8hpp.html#ae32f8747bac5f5ebe592f8a45ff2223a">cfloat</a> dist = <a class="code" href="fftwater_8hpp.html#ae32f8747bac5f5ebe592f8a45ff2223a">cfloat</a>(<a class="code" href="class_f_f_t_water.html#ab097fabe9ae6c9d5dd663849d61d3f31">normal_dist</a>(<a class="code" href="class_f_f_t_water.html#a5c6e7e5dcb703e4877ca80c2ac300a96">engine</a>), <a class="code" href="class_f_f_t_water.html#ab097fabe9ae6c9d5dd663849d61d3f31">normal_dist</a>(<a class="code" href="class_f_f_t_water.html#a5c6e7e5dcb703e4877ca80c2ac300a96">engine</a>));</div>
<div class="line">            <a class="code" href="gl2ext_8h.html#a55f85da29bf761fde63cc95d26300230">v</a> = dist * amplitude * sqrt(0.5<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a> * <a class="code" href="class_f_f_t_water.html#aebd49ffcfb641ef4145fb93a1a41e6ee">phillips</a>(k, max_l));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In Fourier Transforms, we need to consider negative and positive frequencies. Before computing the spatial frequency, we alias the frequency according to Nyquist. This means that the higher values for x and z will alias to the negative frequencies. The negative frequencies represent waves travelling in the opposite direction as the positive counterparts.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="fftwater_8cpp.html#a353783a6b8955acf3695b87f85785c38">alias</a>(<span class="keywordtype">int</span> <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, <span class="keywordtype">int</span> <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (x &gt; N / 2)</div>
<div class="line">        x -= <a class="code" href="geometry_8cpp.html#a0240ac851181b84ac374872dc5434ee4">N</a>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before actually doing the FFT on the GPU, we run compute shader passes which generates a new frequency domain buffer for height, normals and displacement.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> generate_heightmap()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structuvec2.html">uvec2</a> i = gl_GlobalInvocationID.xy;</div>
<div class="line">    <span class="comment">// Pick out the negative frequency variant.</span></div>
<div class="line">    <a class="code" href="structuvec2.html">uvec2</a> wi = mix(N - i, <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ad458ce1be4fc1f4b3bb14a7f6124edc2">uvec2</a>(0u), equal(i, <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ad458ce1be4fc1f4b3bb14a7f6124edc2">uvec2</a>(0u)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pick out positive and negative travelling waves.</span></div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> <a class="code" href="gl2ext_8h.html#ac8729153468b5dcf13f971b21d84d4e5">a</a> = distribution[i.<a class="code" href="structuvec2.html#af9805d8c05a45e4cf001e85bac29d10c">y</a> * N.x + i.<a class="code" href="structuvec2.html#ac251d4ddc17abd607bda7d6efc4834cc">x</a>];</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> <a class="code" href="gl2ext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a> = distribution[wi.<a class="code" href="structuvec2.html#af9805d8c05a45e4cf001e85bac29d10c">y</a> * N.x + wi.<a class="code" href="structuvec2.html#ac251d4ddc17abd607bda7d6efc4834cc">x</a>];</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> k = uMod * <a class="code" href="fftwater_8cpp.html#a353783a6b8955acf3695b87f85785c38">alias</a>(<a class="code" href="structvec2.html">vec2</a>(i), <a class="code" href="structvec2.html">vec2</a>(N));</div>
<div class="line">    <span class="keywordtype">float</span> k_len = <a class="code" href="gl2ext_8h.html#ab9c919755bde3b34349e23a32b4e0fa7">length</a>(k);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> G = 9.81;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If this sample runs for hours on end, the cosines of very large numbers will eventually become unstable.</span></div>
<div class="line">    <span class="comment">// It is fairly easy to fix this by wrapping uTime,</span></div>
<div class="line">    <span class="comment">// and quantizing w such that wrapping uTime does not change the result.</span></div>
<div class="line">    <span class="comment">// See Tessendorf&#39;s paper for how to do it.</span></div>
<div class="line">    <span class="comment">// The sqrt(G * k_len) factor represents how fast ocean waves at different frequencies propagate.</span></div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#afb1b07e1b25035d41d60fb2c03d507e6">w</a> = sqrt(G * k_len) * uTime;</div>
<div class="line">    <span class="keywordtype">float</span> cw = cos(w);</div>
<div class="line">    <span class="keywordtype">float</span> sw = sin(w);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Complex multiply to rotate our frequency samples.</span></div>
<div class="line">    a = cmul(a, <a class="code" href="structvec2.html">vec2</a>(cw, sw));</div>
<div class="line">    b = cmul(b, <a class="code" href="structvec2.html">vec2</a>(cw, sw));</div>
<div class="line">    b = <a class="code" href="structvec2.html">vec2</a>(b.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a>, -b.<a class="code" href="structvec2.html#a6d28b12b511da692550fc9d37b4e9b1d">y</a>); <span class="comment">// Complex conjugate since we picked a frequency with the opposite direction.</span></div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> res = a + <a class="code" href="gl2ext_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>; <span class="comment">// Sum up forward and backwards travelling waves.</span></div>
<div class="line">    heights[i.<a class="code" href="structuvec2.html#af9805d8c05a45e4cf001e85bac29d10c">y</a> * N.x + i.<a class="code" href="structuvec2.html#ac251d4ddc17abd607bda7d6efc4834cc">x</a>] = pack2(res);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="oceanRealFFT"></a>
Using Complex-To-Real FFT to speed up heightmap GPU FFT by almost 2x</h3>
<p>While the frequency space is indeed complex, the final heightmaps we're interested in contain real data. Since the frequency samples generated by generate_heightmap() are complex conjugated, we can use a clever two-for-one FFT scheme which can do complex-to-real FFT at close to 2x improvement in both speed and power.</p>
<p>For the normal map and displacement map however, we need two components, so we do a regular complex-to-complex FFT in this case.</p>
<div class="fragment"><div class="line"><span class="comment">// Init GLFFT</span></div>
<div class="line">fft_height = unique_ptr&lt;FFT&gt;(<span class="keyword">new</span> FFT(Nx, Nz,</div>
<div class="line">            <a class="code" href="namespace_g_l_f_f_t.html#a9e4e56aea9cf91161efc50f047b83bc2a53d68f168d040bee91103cd353dd0d17">ComplexToReal</a>, <a class="code" href="namespace_g_l_f_f_t.html#a59650536a57180472536136a7778a5c9ab0e656b2d17df7b1064c98366f428551">Inverse</a>, <a class="code" href="namespace_g_l_f_f_t.html#ab2687fef8a775901f5fb093657631cb1ae5acf46f7696870f1a14d4ee79a846c0">SSBO</a>, <a class="code" href="namespace_g_l_f_f_t.html#ab2687fef8a775901f5fb093657631cb1a5215c4089b10cf0b584f13679c14cbb0">ImageReal</a>, cache, options));</div>
<div class="line">fft_displacement = unique_ptr&lt;FFT&gt;(<span class="keyword">new</span> FFT(Nx &gt;&gt; displacement_downsample, Nz &gt;&gt; displacement_downsample,</div>
<div class="line">            <a class="code" href="namespace_g_l_f_f_t.html#a9e4e56aea9cf91161efc50f047b83bc2aff047bea8dba137b7468fb7d42abd9a7">ComplexToComplex</a>, <a class="code" href="namespace_g_l_f_f_t.html#a59650536a57180472536136a7778a5c9ab0e656b2d17df7b1064c98366f428551">Inverse</a>, <a class="code" href="namespace_g_l_f_f_t.html#ab2687fef8a775901f5fb093657631cb1ae5acf46f7696870f1a14d4ee79a846c0">SSBO</a>, <a class="code" href="struct_image.html">Image</a>, cache, options));</div>
<div class="line">fft_normal = unique_ptr&lt;FFT&gt;(<span class="keyword">new</span> FFT(Nx, Nz,</div>
<div class="line">            <a class="code" href="namespace_g_l_f_f_t.html#a9e4e56aea9cf91161efc50f047b83bc2aff047bea8dba137b7468fb7d42abd9a7">ComplexToComplex</a>, <a class="code" href="namespace_g_l_f_f_t.html#a59650536a57180472536136a7778a5c9ab0e656b2d17df7b1064c98366f428551">Inverse</a>, <a class="code" href="namespace_g_l_f_f_t.html#ab2687fef8a775901f5fb093657631cb1ae5acf46f7696870f1a14d4ee79a846c0">SSBO</a>, <a class="code" href="struct_image.html">Image</a>, move(cache), options));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate new FFTs</span></div>
<div class="line">glUseProgram(prog_generate_height.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, distribution_buffer.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, freq_height.get());</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// We only need to generate half the frequencies due to C2R transform.</span></div>
<div class="line">glDispatchCompute(Nx / 8 + 1, Nz / 4, 1);</div>
<div class="line"></div>
<div class="line">glUseProgram(prog_generate_displacement.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, distribution_buffer_displacement.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, freq_displacement.get());</div>
<div class="line"><span class="comment">// ... Since displacement is very low-frequency, compute it at a lower resolution.</span></div>
<div class="line">glDispatchCompute((Nx &gt;&gt; displacement_downsample) / 4, (Nz &gt;&gt; displacement_downsample) / 4, 1);</div>
<div class="line"></div>
<div class="line">glUseProgram(prog_generate_normal.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, distribution_buffer_normal.get());</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, freq_normal.get());</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">glDispatchCompute(Nx / 4, Nz / 4, 1);</div>
<div class="line"></div>
<div class="line">glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compute the iFFT</span></div>
<div class="line">texture_index ^= 1;</div>
<div class="line">fft_height-&gt;process(heightmap[texture_index].<span class="keyword">get</span>(), freq_height.get());</div>
<div class="line">fft_displacement-&gt;process(displacementmap[texture_index].<span class="keyword">get</span>(), freq_displacement.get());</div>
<div class="line">fft_normal-&gt;process(normalmap[texture_index].<span class="keyword">get</span>(), freq_normal.get());</div>
<div class="line">glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);</div>
</div><!-- fragment --><p>After generating the iFFTs, we generate heightmap normals, compute the Jacobian, and various other things, before mipmapping the textures.</p>
<h3><a class="anchor" id="oceanFP16FFT"></a>
Using FP16 FFTs for bandwidth savings and performance</h3>
<p>Using a FP16 FFT instead of FP32 FFT works well in this sample and this saves lots of extra bandwidth and computation in the FFT implementation.</p>
<h3><a class="anchor" id="oceanMipmap"></a>
Correctly mipmapping the heightmap</h3>
<p>One important detail with mipmapping the heightmap is that we cannot use a box filter. Instead, we pretend that the first texel lies on uv = (0, 0). This is necessary later when we want to properly render the heightmap. It is also necessary to mipmap our heightmap with compute shaders. The alternative is to compute the mipmap with fragment shaders, but for a tiled architecture such as Mali, having vertex shading (which uses the heightmap) depends on fragment (mip-generation) often creates a bad pipeline stall.</p>
<div class="fragment"><div class="line"><a class="code" href="structvec2.html">vec2</a> uv = (2.0 * <a class="code" href="structvec2.html">vec2</a>(gl_GlobalInvocationID.xy) + 0.5) * uInvSize; <span class="comment">// A typical box filter would use 1.0 offset here instead of 0.5.</span></div>
<div class="line"></div>
<div class="line">mediump <a class="code" href="structvec4.html">vec4</a> filtered = <a class="code" href="structvec4.html">vec4</a>(0.0);</div>
<div class="line">filtered += 0.25 * textureLod(uNormal, uv + <a class="code" href="structvec2.html">vec2</a>(-D, -D) * uInvSize, <span class="keywordtype">float</span>(uLod));</div>
<div class="line">filtered += 0.25 * textureLod(uNormal, uv + <a class="code" href="structvec2.html">vec2</a>(+D, -D) * uInvSize, <span class="keywordtype">float</span>(uLod));</div>
<div class="line">filtered += 0.25 * textureLod(uNormal, uv + <a class="code" href="structvec2.html">vec2</a>(-D, +D) * uInvSize, <span class="keywordtype">float</span>(uLod));</div>
<div class="line">filtered += 0.25 * textureLod(uNormal, uv + <a class="code" href="structvec2.html">vec2</a>(+D, +D) * uInvSize, <span class="keywordtype">float</span>(uLod));</div>
<div class="line"></div>
<div class="line">imageStore(iNormal, <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ac8de76610b426f3ba8c071f5011dd15e">ivec2</a>(gl_GlobalInvocationID.xy), filtered);</div>
</div><!-- fragment --><h2><a class="anchor" id="oceanChoppy"></a>
Choppy waves</h2>
<p>In reality, ocean waves do not behave like pure sinusoids, but behave in a more "choppy" way where peaks of the waves compact a bit, to make the waves look sharper.</p>
<p>Using only a straight heightmap, this is not easy to implement, however, we can have another "displacement" map which computes displacement in the horizontal plane as well. If we compute the inverse Fourier transform of the gradient of the heightmap, we can find a horizontal displacement vector which we will push vertices toward. This gives a great choppy look to the waves.</p>
<p>By adding choppiness, we can go from</p>
<div class="image">
<img src="oceanNoChopping.png" alt="oceanNoChopping.png"/>
</div>
<p>to</p>
<div class="image">
<img src="oceanChopping.png" alt="oceanChopping.png"/>
</div>
<p>We implement it in compute shaders by modifiying generate_heightmap() slightly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> generate_displacement()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="comment">// Derivative of exp(j * x) is j * exp(j * x).</span></div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> grad = cmul(res, <a class="code" href="structvec2.html">vec2</a>(-k.<a class="code" href="structvec2.html#a6d28b12b511da692550fc9d37b4e9b1d">y</a> / (k_len + 0.00001), k.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a> / (k_len + 0.00001)));</div>
<div class="line">    grads[i.<a class="code" href="structuvec2.html#af9805d8c05a45e4cf001e85bac29d10c">y</a> * N.x + i.<a class="code" href="structuvec2.html#ac251d4ddc17abd607bda7d6efc4834cc">x</a>] = pack2(grad);</div>
<div class="line">}</div>
</div><!-- fragment --><p>See <a href="#ref1">[1]</a> for mathematical details.</p>
<h2><a class="anchor" id="oceanJacobian"></a>
Using the Jacobian for modelling turbulent effects at wave crests</h2>
<p>At wave crests, the turbulence tends to cause a more diffuse reflection, increasing overall brightness and "whiteness" of the water. By looking at the gradient of the horizontal displacement map, we can detect where the crests occur and use this to pass a turbulence factor to the fragment shader.</p>
<div class="fragment"><div class="line"><span class="comment">// From bake_height_gradient.comp.</span></div>
<div class="line"></div>
<div class="line">mediump <span class="keywordtype">float</span> jacobian(mediump <a class="code" href="structvec2.html">vec2</a> dDdx, mediump <a class="code" href="structvec2.html">vec2</a> dDdy)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (1.0 + dDdx.x) * (1.0 + dDdy.y) - dDdx.y * dDdy.x;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#define LAMBDA 1.2</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><a class="code" href="structvec2.html">vec2</a> dDdx = 0.5 * LAMBDA * (</div>
<div class="line">    textureLodOffset(uDisplacement, uv.zw, 0.0, <a class="code" href="structdetail_1_1ivec2.html">ivec2</a>(+1, 0)).xy -</div>
<div class="line">    textureLodOffset(uDisplacement, uv.zw, 0.0, <a class="code" href="structdetail_1_1ivec2.html">ivec2</a>(-1, 0)).xy);</div>
<div class="line"><a class="code" href="structvec2.html">vec2</a> dDdy = 0.5 * LAMBDA * (</div>
<div class="line">    textureLodOffset(uDisplacement, uv.zw, 0.0, <a class="code" href="structdetail_1_1ivec2.html">ivec2</a>(0, +1)).xy -</div>
<div class="line">    textureLodOffset(uDisplacement, uv.zw, 0.0, <a class="code" href="structdetail_1_1ivec2.html">ivec2</a>(0, -1)).xy);</div>
<div class="line"><span class="keywordtype">float</span> j = jacobian(dDdx * uScale.z, dDdy * uScale.z);</div>
<div class="line"></div>
<div class="line">imageStore(iHeightDisplacement, <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ac8de76610b426f3ba8c071f5011dd15e">ivec2</a>(gl_GlobalInvocationID.xy), <a class="code" href="structvec4.html">vec4</a>(<a class="code" href="gl2ext_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a>, displacement, 0.0));</div>
<div class="line">imageStore(iGradJacobian, <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ac8de76610b426f3ba8c071f5011dd15e">ivec2</a>(gl_GlobalInvocationID.xy), <a class="code" href="structvec4.html">vec4</a>(grad, j, 0.0));</div>
</div><!-- fragment --><p>When the Jacobian factor is close to 0, the water is very "turbulent" and when larger than 1, the water mesh has been "stretched" out. A Jacobian of 1 is the "normal" state.</p>
<p>We combine the lower-frequency Jacobian with the normal map in the fragment shader to compute a final "turbulence" factor which creates a neat shading effect.</p>
<div class="fragment"><div class="line"><span class="comment">// water.fs</span></div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> vGradJacobian = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(uGradJacobian, vGradNormalTex.xy).xyz;</div>
<div class="line"><a class="code" href="structvec2.html">vec2</a> noise_gradient = 0.30 * <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(uNormal, vGradNormalTex.zw).xy;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> jacobian = vGradJacobian.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a>;</div>
<div class="line"><span class="keywordtype">float</span> turbulence = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(2.0 - jacobian + dot(abs(noise_gradient), <a class="code" href="structvec2.html">vec2</a>(1.2)), 0.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// This is rather &quot;arbitrary&quot;, but looks pretty good in practice.</span></div>
<div class="line"><span class="keywordtype">float</span> color_mod = 1.0 + 3.0 * <a class="code" href="_translucency_2jni_2common_2matrix_8h.html#a9adb31f089bc3242295eb00cf26dfe98">smoothstep</a>(1.2, 1.8, turbulence);</div>
</div><!-- fragment --><h1><a class="anchor" id="oceanHeightmap"></a>
Rendering Heightmap Efficiently with Continuous LOD</h1>
<p>Rendering heightmaps (terrains) efficiently is a big topic on its own. For this sample, we implement two different approaches to rendering continous LOD heightmaps. Both variants have a concept of patches which are adaptively subdivided based on distance to camera.</p>
<p>First we place a large grid of patches in the world. The patches are roughly centered around the camera, but they do not move in lock-step with the camera, rather, they only move in units of whole patches in order to avoid the "vertex swimming" artifact.</p>
<div class="image">
<img src="oceanPatch.png" alt="oceanPatch.png"/>
</div>
<p>With this scheme, we want to subdivide the patches depending to distance to camera. The full grid is quite large, so we cannot have full quality for the entire world without taking a serious performance hit.</p>
<div class="image">
<img src="oceanPatchSubdivision.png" alt="oceanPatchSubdivision.png"/>
</div>
<p>We also want a "continous" LOD effect. A difficult problem to solve is avoiding "popping" artifacts and "swimming" artifacts at the same time. Popping happens when the vertex mesh suddenly changes resolution without any kind of transition band. <a class="el" href="struct_vertex.html">Vertex</a> swimming happens if we move the heightmap (and hence texture sampling coordinates) around without snapping it to some kind of grid.</p>
<h2><a class="anchor" id="oceanTessellation"></a>
Tessellation</h2>
<p>For adaptively subdividing a patch, Tessellation in OpenGL ES 3.2 <a href="#ref7">[7]</a> can solve this quite neatly.</p>
<div class="image">
<img src="oceanTess.png" alt="oceanTess.png"/>
</div>
<p>We implement tessellation by treating our water patch as a GL_PATCH primitive. In the control shader, we compute tessellation factors for our patch.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(<a class="code" href="structvec2.html">vec2</a> pos)</div>
<div class="line">{</div>
<div class="line">    pos *= uScale.xy;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> dist_to_cam = uCamPos - <a class="code" href="structvec3.html">vec3</a>(pos.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a>, 0.0, pos.<a class="code" href="structvec2.html#a6d28b12b511da692550fc9d37b4e9b1d">y</a>);</div>
<div class="line">    <span class="keywordtype">float</span> level = log2((<a class="code" href="gl2ext_8h.html#ab9c919755bde3b34349e23a32b4e0fa7">length</a>(dist_to_cam) + 0.0001) * uDistanceMod);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="noise_8cpp.html#ade5e5a7c2668edda2637fd3bdadb85e5">clamp</a>(level, 0.0, uMaxTessLevel.x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> tess_level(<span class="keywordtype">float</span> lod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> uMaxTessLevel.y * exp2(-lod);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> tess_level(<a class="code" href="structvec4.html">vec4</a> lod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> uMaxTessLevel.<a class="code" href="structvec4.html#a7328fe0e502fce92fa32016193052e92">y</a> * exp2(-lod);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For the outer tessellation factors, it is vital that the tessellation factors are exactly the same for patches which share edges, otherwise, we risk cracks in the water mesh, which is never a good sign.</p>
<p>To make this work, we find tessellation factors in the four corners of our patch. We then take the minimum LOD of two corners which belong to an edge, which decides the tessellation factor for that edge.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> l0 = <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(p0 + <a class="code" href="structvec2.html">vec2</a>(0.0, 1.0) * uPatchSize);</div>
<div class="line"><span class="keywordtype">float</span> l1 = <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(p0 + <a class="code" href="structvec2.html">vec2</a>(0.0, 0.0) * uPatchSize);</div>
<div class="line"><span class="keywordtype">float</span> l2 = <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(p0 + <a class="code" href="structvec2.html">vec2</a>(1.0, 0.0) * uPatchSize);</div>
<div class="line"><span class="keywordtype">float</span> l3 = <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(p0 + <a class="code" href="structvec2.html">vec2</a>(1.0, 1.0) * uPatchSize);</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> lods = <a class="code" href="structvec4.html">vec4</a>(l0, l1, l2, l3);</div>
<div class="line">vPatchLods = lods;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> outer_lods = <a class="code" href="noise_8cpp.html#ad601cfd7a14298c6bba5e0cad4c640c7">min</a>(lods.xyzw, lods.yzwx);</div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> tess_levels = tess_level(outer_lods);</div>
<div class="line"><span class="keywordtype">float</span> inner_level = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(<a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(tess_levels.<a class="code" href="structvec4.html#a36c650782a67137380c83b01545c94d6">x</a>, tess_levels.<a class="code" href="structvec4.html#a7328fe0e502fce92fa32016193052e92">y</a>), <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(tess_levels.<a class="code" href="structvec4.html#a12b318751110db034dddc450cdec455d">z</a>, tess_levels.<a class="code" href="structvec4.html#a0c92fe67e490d9768217a00c2e8abd49">w</a>));</div>
</div><!-- fragment --><p>In order to avoid processing patches which are outside the camera, we frustum cull in the control shader as well, and set tessellation factors to negative values which discards the patch outright.</p>
<p>In the evaluation shader, we interpolate the corner LODs calculated by the control shader to figure out which LOD we should sample the heightmap with.</p>
<div class="fragment"><div class="line">patch in <a class="code" href="structvec4.html">vec4</a> vPatchLods;</div>
<div class="line"></div>
<div class="line">mediump <a class="code" href="structvec2.html">vec2</a> <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(<a class="code" href="structvec2.html">vec2</a> tess_coord)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Bilinear interpolation.</span></div>
<div class="line">    mediump <a class="code" href="structvec2.html">vec2</a> x = mix(vPatchLods.yx, vPatchLods.zw, tess_coord.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a>);</div>
<div class="line">    mediump <span class="keywordtype">float</span> level = mix(x.x, x.y, tess_coord.<a class="code" href="structvec2.html#a6d28b12b511da692550fc9d37b4e9b1d">y</a>);</div>
<div class="line"></div>
<div class="line">    mediump <span class="keywordtype">float</span> floor_level = floor(level);</div>
<div class="line">    mediump <span class="keywordtype">float</span> fract_level = level - floor_level;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structvec2.html">vec2</a>(floor_level, fract_level);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When sampling the heightmap, we need to take extra care to make sure we avoid the swimming artifact. A simple and effective way to make sure this happens is that when we sample the heightmap, we sample the respective mipmaps between their texels so the bilinear interpolation is smooth and has a continuous first derivative. For this reason, we cannot use tri-linear filtering directly, but we can easily do this ourselves. Ideally, we would like uv = (0, 0) to land exactly on the first texel here since that would also map to first texel in the next miplevel, however, this is not the case with OpenGL ES. For this, reason, we apply the half-texel offsets independently for every level. The speed hit here is negligible, since tri-linear filtering generally does two texture lookups anyways.</p>
<div class="fragment"><div class="line">mediump <a class="code" href="structvec3.html">vec3</a> sample_height_displacement(<a class="code" href="structvec2.html">vec2</a> uv, <a class="code" href="structvec2.html">vec2</a> off, mediump <a class="code" href="structvec2.html">vec2</a> lod)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mix(</div>
<div class="line">            textureLod(uHeightmapDisplacement, uv + 0.5 * off, lod.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a>).xyz,</div>
<div class="line">            textureLod(uHeightmapDisplacement, uv + 1.0 * off, lod.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a> + 1.0).xyz,</div>
<div class="line">            lod.y);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second thing we need to take care of is using the appropriate subdivision type. Tessellation supports equal_spacing, fractional_even and fractional_odd. We opt for fractional_even here since it will interpolate towards an even number of edges which matches well with the textures we sample from. We want our vertex grid to match with the texel centers on the heightmap as much as possible.</p>
<div class="fragment"><div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(cw, quads, fractional_even_spacing) in;</div>
</div><!-- fragment --><h2><a class="anchor" id="oceanContinuousLOD"></a>
Continuous LOD Morphing Geo-MipMap</h2>
<p>For devices which do not support tessellation, we implement a heightmap rendering scheme which takes inspiration from tessellation, geomipmaping <a href="#ref4">[4]</a>, geomorphing <a href="#ref5">[5]</a> and CDLOD techniques <a href="#ref6">[6]</a>, using vertex shaders and instancing only.</p>
<div class="image">
<img src="oceanModifiedTess.png" alt="oceanModifiedTess.png"/>
</div>
<p>Like geomipmapping and geomorphing, the patch size is fixed, and we achieve LOD by subdividing the patch with different pre-made meshes. Like CDLOD, we transition between LODs by "morphing" the vertices so that before switching LOD, we warp the odd vertices towards the even ones so that the fully warped mesh is the same as the lower-detail mesh, which guarantees no popping artifacts. Morphing between LODs and using a fixed size patch is essentially what tessellation does, so this scheme can be seen as a subset of quad patch tessellation.</p>
<p>One of the main advantages of this scheme over CDLOD is its ability to use a different LOD function than pure distance since CDLOD uses a strict quad-tree structure purely based on distance. It is also simpler to implement as there is no tree structure which needs to be traversed. There is also no requirement for the patches to differ by only one LOD level as is the case with CDLOD, so it is possible to adjust the LOD where the heightmap is very detailed, and reduce vertex count for patches which are almost completely flat. This is a trivial "LOD bias" when processing the patches.</p>
<p>The main downsides of this algorithm however is that more patches are needed to be processed individually on CPU since there is no natural quad-tree structure (although it is possible to accelerate it with compute and indirect drawing) and for planetary style terrain with massive differences in zoom (e.g. from outside the atmosphere all the way into individual rocks), having a fixed patch size is not feasible.</p>
<p>To allow arbitrary LOD between patches, we need to know the LOD at all the four edges of the patch and the inner LOD before warping our vertex position. This info is put in a per-instance uniform buffer.</p>
<div class="fragment"><div class="line"><a class="code" href="structvec2.html">vec2</a> warp_position()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// aLODWeights is a vertex attribute that contains either (1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1) or (0, 0, 0, 0).</span></div>
<div class="line">    <span class="comment">// It is all zero when our vertices is inside the patch, and contains a 1 if our vertex lies on an edge.</span></div>
<div class="line">    <span class="comment">// For corners, we don&#39;t really care which edge we belong to since the corner vertices</span></div>
<div class="line">    <span class="comment">// will never be snapped anywhere.</span></div>
<div class="line">    <span class="comment">// Using a dot product, this lets us &quot;select&quot; an appropriate LOD factor.</span></div>
<div class="line">    <span class="comment">// For the inner lod, we can conditionally select this efficiently using the boolean mix() operator.</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> vlod = dot(aLODWeights, patches.data[gl_InstanceID].LODs);</div>
<div class="line">    vlod = mix(vlod, patches.data[gl_InstanceID].InnerLOD.x, all(equal(aLODWeights, <a class="code" href="structvec4.html">vec4</a>(0.0))));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// aPosition.xy holds integer positions locally in the patch with range [0, patch_size].</span></div>
<div class="line">    <span class="comment">// aPosition.zw are either 0 or 1. These select in which direction we will snap our vertices when warping to the lower LOD.</span></div>
<div class="line">    <span class="comment">// It is important that we always round towards the center of the patch, since snapping to one of the edges can lead to popping artifacts.</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> floor_lod = floor(vlod);</div>
<div class="line">    <span class="keywordtype">float</span> fract_lod = vlod - floor_lod;</div>
<div class="line">    uint ufloor_lod = uint(floor_lod);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Snap to grid corresponding to floor(lod) and ceil(lod).</span></div>
<div class="line">    <a class="code" href="structuvec2.html">uvec2</a> <a class="code" href="gl2ext_8h.html#ae1838b9db98fcca9cd79d66954101c9f">mask</a> = (<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ad458ce1be4fc1f4b3bb14a7f6124edc2">uvec2</a>(1u) &lt;&lt; <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ad458ce1be4fc1f4b3bb14a7f6124edc2">uvec2</a>(ufloor_lod, ufloor_lod + 1u)) - 1u;</div>
<div class="line">    uvec4 rounding = aPosition.zwzw * mask.xxyy; <span class="comment">// Either round towards 0 or +inf.</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> lower_upper_snapped = <a class="code" href="structvec4.html">vec4</a>((aPosition.xyxy + rounding) &amp; ~mask.xxyy);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Then lerp between them to create a smoothly morphing mesh.</span></div>
<div class="line">    <span class="keywordflow">return</span> mix(lower_upper_snapped.xy, lower_upper_snapped.zw, fract_lod);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We also want to sample our heightmap using a LOD level that closely matches the patch LOD. For this, we have a tiny GL_R8 LOD texture which has one texel per patch and we can linearly interpolate the LOD factors from there. We update this texture when processing the patches.</p>
<div class="fragment"><div class="line">mediump <a class="code" href="structvec2.html">vec2</a> <a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a3c6d34da2db4713bd3f3f7830fc9e133">lod_factor</a>(<a class="code" href="structvec2.html">vec2</a> position)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> uv = (position + patches.<a class="code" href="structvec2.html#a7bb6aba63933320eff066133eba98ec6">data</a>[gl_InstanceID].Offsets.zw) * uLodScaleOffset;</div>
<div class="line">    mediump <span class="keywordtype">float</span> level = textureLod(uLod, uv, 0.0).<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a> * (255.0 / 32.0); <span class="comment">// Rescale the UNORM value.</span></div>
<div class="line">    mediump <span class="keywordtype">float</span> floor_level = floor(level);</div>
<div class="line">    mediump <span class="keywordtype">float</span> fract_level = level - floor_level;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structvec2.html">vec2</a>(floor_level, fract_level);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Building the UBO is also quite simple. To select LODs we look at the four neighbor patches. The edge LOD is the maximum of the two neighbors. We need the maximum since otherwise there would not be enough vertices in one of the patches to correctly stitch together the edge.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> z = 0; z &lt; blocks_z; z++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> x = 0; x &lt; blocks_x; x++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!patches[z * blocks_x + x].visible)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Clamp to edge.</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> px = x ? (x - 1) : 0;</div>
<div class="line">        <span class="keywordtype">unsigned</span> pz = z ? (z - 1) : 0;</div>
<div class="line">        <span class="keywordtype">unsigned</span> nx = <a class="code" href="noise_8cpp.html#ad601cfd7a14298c6bba5e0cad4c640c7">min</a>(x + 1, blocks_x - 1);</div>
<div class="line">        <span class="keywordtype">unsigned</span> nz = <a class="code" href="noise_8cpp.html#ad601cfd7a14298c6bba5e0cad4c640c7">min</a>(z + 1, blocks_z - 1);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#a6358510bdde486b81c7951ee5c470ee4">left</a> = lod_buffer[z * blocks_x + px];</div>
<div class="line">        <span class="keywordtype">float</span> top = lod_buffer[nz * blocks_x + <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>];</div>
<div class="line">        <span class="keywordtype">float</span> right = lod_buffer[z * blocks_x + nx];</div>
<div class="line">        <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#abb624ded9ef662ce48c0c0ff27d35aaf">bottom</a> = lod_buffer[pz * blocks_x + <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>];</div>
<div class="line">        <span class="keywordtype">float</span> center = lod_buffer[z * blocks_x + <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>];</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> left_lod = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(left, center);</div>
<div class="line">        <span class="keywordtype">float</span> top_lod = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(top, center);</div>
<div class="line">        <span class="keywordtype">float</span> right_lod = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(right, center);</div>
<div class="line">        <span class="keywordtype">float</span> bottom_lod = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(bottom, center);</div>
<div class="line">        <span class="keywordtype">int</span> center_lod = <a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>(center);</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> &amp;lod = lod_meshes[center_lod];</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">unsigned</span> ubo_offset = center_lod * blocks_x * blocks_z;</div>
<div class="line"></div>
<div class="line">        ubo_data[ubo_offset + lod.full.instances].Offsets = <a class="code" href="structvec4.html">vec4</a>(</div>
<div class="line">                patches[z * blocks_x + x].pos + block_offset, <span class="comment">// Offset to world space.</span></div>
<div class="line">                patches[z * blocks_x + x].pos);</div>
<div class="line">        ubo_data[ubo_offset + lod.full.instances].LODs = <a class="code" href="structvec4.html">vec4</a>(left_lod, top_lod, right_lod, bottom_lod);</div>
<div class="line">        ubo_data[ubo_offset + lod.full.instances].InnerLOD = <a class="code" href="structvec4.html">vec4</a>(center);</div>
<div class="line"></div>
<div class="line">        lod.full.instances++;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While we could in theory use the LOD factor we generate in warp_position() to sample the heightmap, this would break the corner vertices on the patch. We need to make sure all vertices that are shared between patches compute the exact same vertex position. This is not the case with the vlod factor we compute in warp_position().</p>
<p>From here, we sample our heightmaps, etc as before, very similar to the evaluation shader implementation.</p>
<h1><a class="anchor" id="oceanShading"></a>
Shading Ocean Water</h1>
<p>While correctly shading ocean water is a big topic entirely on its own, this sample uses a simple approach of cubemap reflection against a pregenerated skydome. For more realistic specular shading, the fresnel factor is added in. No actual diffuse shading is used, and the only source of lighting is the skydome cube map.</p>
<p>The shader samples two normal (gradient) maps, one low-resolution map generated from the heightmap, and one high-frequency gradient map which is also generated using FFT.</p>
<h1><a class="anchor" id="oceanReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] J. Tessendorf - Simulating Ocean Water - <a href="http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf">http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf</a></p>
<p><a class="anchor" id="ref2"></a>[2] <a class="el" href="namespace_g_l_f_f_t.html">GLFFT</a> - Fast Fourier Transform library for OpenGL - <a href="https://github.com/Themaister/GLFFT">https://github.com/Themaister/GLFFT</a></p>
<p><a class="anchor" id="ref3"></a>[3] E. Bainville - OpenCL Fast Fourier Transform - <a href="http://www.bealto.com/gpu-fft.html">http://www.bealto.com/gpu-fft.html</a></p>
<p><a class="anchor" id="ref4"></a>[4] W. H. de Boer - Fast Terrain Rendering Using Geometrical MipMapping - <a href="http://www.flipcode.com/archives/article_geomipmaps.pdf">http://www.flipcode.com/archives/article_geomipmaps.pdf</a></p>
<p><a class="anchor" id="ref5"></a>[5] D. Wagner - Terrain Geomorphing in the <a class="el" href="struct_vertex.html">Vertex</a> <a class="el" href="class_shader.html">Shader</a> - <a href="https://www.ims.tuwien.ac.at/publications/tuw-138077.pdf">https://www.ims.tuwien.ac.at/publications/tuw-138077.pdf</a></p>
<p><a class="anchor" id="ref6"></a>[6] F. Strugar - Continous Distance-Dependent Level of Detail for Rendering Heightmaps (CDLOD) - <a href="http://www.vertexasylum.com/downloads/cdlod/cdlod_latest.pdf">http://www.vertexasylum.com/downloads/cdlod/cdlod_latest.pdf</a></p>
<p><a class="anchor" id="ref7"></a>[7] GL_EXT_tessellation_shader (now OpenGL ES 3.2) - <a href="https://www.khronos.org/registry/gles/extensions/EXT/EXT_tessellation_shader.txt">https://www.khronos.org/registry/gles/extensions/EXT/EXT_tessellation_shader.txt</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
