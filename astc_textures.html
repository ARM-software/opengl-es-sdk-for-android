<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: ASTC textures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('astc_textures.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ASTC textures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes usage of compressed ASTC textures.</p>
<h1><a class="anchor" id="astcTexturesIntroduction"></a>
Introduction</h1>
<p>This tutorial shows how Adaptive Scalable Texture Compression (ASTC) can be easily used in simple scene, which is a textured sphere spinning in 3D space. It simulates an earth globe lighted from one side with a camera zooming in and out on its surface.</p>
<dl class="section warning"><dt>Warning</dt><dd>In order to use ASTC formats you need to run your application on hardware which supports corresponding OpenGL ES extension(s):<ul>
<li>GL_KHR_texture_compression_astc_ldr or</li>
<li>GL_KHR_texture_compression_astc_hdr.</li>
</ul>
Otherwise, you will be getting messages about invalid format/internalformat passing through glCompressedTex* function to underlying graphics driver.</dd></dl>
<h1><a class="anchor" id="astcTexturesWhatIsAstc"></a>
What is ASTC?</h1>
<p>The ASTC algorithm represents a group of lossy block-based compressed texture image formats. For information on why texture compression is needed see chapter <a class="el" href="compressed_alpha_channels.html#compressedAlphaChannelsWhy">Why use texture compression?</a> Two and three dimensional textures may be encoded using low or heigh dynamic range. In this demonstrating example we take under consideration only 2D, LDR textures. Basic concept of encoding relies on division the compressed image into a number of blocks with a uniform size. Each block is stored with a fixed 16-bytes footprint, regardless of the block's dimensions. That's why it can represent a varying number of texels and bit rate is determined by block size (see below table), which allows content developers to fine-tune the tradeoff of space against quality.</p>
<table class="doxtable">
<tr>
<th align="center">Block size </th><th align="center">Bit rate  </th></tr>
<tr>
<td align="center">4x4 </td><td align="center">8.00 bpp </td></tr>
<tr>
<td align="center">5x4 </td><td align="center">6.40 bpp </td></tr>
<tr>
<td align="center">5x5 </td><td align="center">5.12 bpp </td></tr>
<tr>
<td align="center">6x5 </td><td align="center">4.27 bpp </td></tr>
<tr>
<td align="center">6x6 </td><td align="center">3.56 bpp </td></tr>
<tr>
<td align="center">8x5 </td><td align="center">3.20 bpp </td></tr>
<tr>
<td align="center">8x6 </td><td align="center">2.67 bpp </td></tr>
<tr>
<td align="center">8x8 </td><td align="center">2.00 bpp </td></tr>
<tr>
<td align="center">10x5 </td><td align="center">2.56 bpp </td></tr>
<tr>
<td align="center">10x6 </td><td align="center">2.13 bpp </td></tr>
<tr>
<td align="center">10x8 </td><td align="center">1.60 bpp </td></tr>
<tr>
<td align="center">10x10 </td><td align="center">1.28 bpp </td></tr>
<tr>
<td align="center">12x10 </td><td align="center">1.07 bpp </td></tr>
<tr>
<td align="center">12x12 </td><td align="center">0.89 bpp </td></tr>
</table>
<p>ASTC offers also support for 1 to 4 color channels, together with modes for uncorrelated channels for use in mask textures and normal maps. Decoding one texel requires data from a single block only, which highly simplifies cache design, reduces bandwidth and improves encoder throughput. Despite this, ASTC achieves peak signal-to-noise ratios (PSNR) better than or comparable to existing texture compression algorithms (e.g. ETC1/ETC2).</p>
<dl class="section note"><dt>Note</dt><dd>For more details on ASTC algorithm visit <a href="#ref1">[1]</a></dd></dl>
<h2><a class="anchor" id="astcTexturesTexturePreview"></a>
Texture preview</h2>
<p>You can preview and analyse your texture image how it looks like after decompression using Texture Compression Tool (TCT):</p>
<ol type="1">
<li>Download and install TCT from <a href="#ref2">[2]</a></li>
<li>Open your existing image file.</li>
<li>Specify compression options in the ASTC tab which appears after pressing F7. <div class="image">
<img src="TCTastcTab.png" alt="TCTastcTab.png"/>
</div>
</li>
<li>Confirm compression set up with OK. Preview is generated automatically.</li>
</ol>
<h2><a class="anchor" id="astcTexturesTextureEncoding"></a>
Texture encoding</h2>
<p>You can compress your texture image to ASTC format using command line interface:</p>
<ol type="1">
<li>Download and install ASTC evaluation codec from <a href="#ref3">[3]</a></li>
<li>Compress you input image file to ASTC format using following syntax: <div class="fragment"><div class="line">astcenc.exe -c &lt;inputfile&gt; &lt;outputfile&gt; &lt;rate&gt; [options]</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd>For more information on how to use ASTC encoder just type: <div class="fragment"><div class="line">astcenc.exe</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="astcTexturesLoadingTextures"></a>
Texture loading</h2>
<p>In this sample sphere is covered with color that is result of combining colors from three texture units: cloud and gloss unit, day time unit and night time unit. Hence, firstly all compressed ASTC textures have to be decoded and specified for targets in order to generate texture bindings that will be next bound to particular texture units. For doing it <a class="el" href="jni_2_astc_textures_8cpp.html#a53c03df8d006f4948786c597629d3e20" title="Define and retrieve compressed texture image. ">load_texture()</a> function is responsible, which follows the steps:</p>
<ul>
<li>Texture image file is opened and loaded into local memory buffer.</li>
<li>Local buffer is mapped on ASTC header in order to extract texture image properties like ASTC block dimensions and sizes. <div class="fragment"><div class="line"><span class="comment">/* ASTC header declaration. */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> magic[4];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blockdim_x;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blockdim_y;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blockdim_z;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> xsize[3];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ysize[3];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> zsize[3];</div>
<div class="line">} <a class="code" href="structastc__header.html">astc_header</a>;</div>
</div><!-- fragment --></li>
<li>Based on extracted texture properties the values of arguments passed to glCompressedTexImage2D are computed. Total number of bytes to be used by this call is computed by multiplying number of bytes per block and number of blocks which stands for: <div class="fragment"><div class="line"><span class="comment">/* Merge x,y,z-sizes from 3 chars into one integer value. */</span></div>
<div class="line">xsize = astc_data_ptr-&gt;xsize[0] + (astc_data_ptr-&gt;xsize[1] &lt;&lt; 8) + (astc_data_ptr-&gt;xsize[2] &lt;&lt; 16);</div>
<div class="line">ysize = astc_data_ptr-&gt;ysize[0] + (astc_data_ptr-&gt;ysize[1] &lt;&lt; 8) + (astc_data_ptr-&gt;ysize[2] &lt;&lt; 16);</div>
<div class="line">zsize = astc_data_ptr-&gt;zsize[0] + (astc_data_ptr-&gt;zsize[1] &lt;&lt; 8) + (astc_data_ptr-&gt;zsize[2] &lt;&lt; 16);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Compute number of blocks in each direction. */</span></div>
<div class="line">xblocks = (xsize + astc_data_ptr-&gt;blockdim_x - 1) / astc_data_ptr-&gt;blockdim_x;</div>
<div class="line">yblocks = (ysize + astc_data_ptr-&gt;blockdim_y - 1) / astc_data_ptr-&gt;blockdim_y;</div>
<div class="line">zblocks = (zsize + astc_data_ptr-&gt;blockdim_z - 1) / astc_data_ptr-&gt;blockdim_z;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Each block is encoded on 16 bytes, so calculate total compressed image data size. */</span></div>
<div class="line">n_bytes_to_read = xblocks * yblocks * zblocks &lt;&lt; 4;</div>
</div><!-- fragment --></li>
<li><p class="startli">Finally, glCompressedTexImage2D is invoked. </p>
<div class="fragment"><div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;to_id));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, to_id));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Upload texture data to ES. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCompressedTexImage2D(GL_TEXTURE_2D,</div>
<div class="line">                                0,</div>
<div class="line">                                compressed_data_internal_format,</div>
<div class="line">                                xsize,</div>
<div class="line">                                ysize,</div>
<div class="line">                                0,</div>
<div class="line">                                n_bytes_to_read,</div>
<div class="line">                                (<span class="keyword">const</span> GLvoid*) astc_data_ptr));</div>
</div><!-- fragment --><p class="startli">After a new texture ID has been generated texture object can be bound to target. Then, compressed data may be passed to driver.</p>
</li>
<li><p class="startli">Texture parameters are set up for GL_TEXTURE_2D target. </p>
<div class="fragment"><div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_REPEAT));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_REPEAT));</div>
</div><!-- fragment --><p class="startli">Texture magnification and minification function are set to GL_LINEAR, which correspond to linear filtering. Texture filtering is a process of calculating color fragments from streched or shrunken texture map. Linear filtering works by applying the weighted average of the texels surrounding the texture coordinates. Texture wrapping modes are set to GL_REPEAT, which means that the textures will be repeated across the object.</p>
</li>
</ul>
<h2><a class="anchor" id="astcTexturesTextureUpdating"></a>
Texture updating</h2>
<p>Once we have got all texture bindings for GL_TEXTURE_2D target we are able to use and switch them at our convenience. It's a job of <a class="el" href="jni_2_astc_textures_8cpp.html#a2004fbd0d4776e3ee5e8f69943e0dc06" title="Update texture bindings and text presented by text renderer. ">update_texture_bindings()</a> function.</p>
<div class="fragment"><div class="line"><span class="comment">/* Update texture units with new bindings. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="jni_2_astc_textures_8cpp.html#a97d760905a6933d095d43ec69570505c">texture_ids</a>[<a class="code" href="jni_2_astc_textures_8cpp.html#afd2b339b64043a84aa6797168d031ebc">current_texture_set_id</a>].cloud_and_gloss_texture_id));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE1));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="jni_2_astc_textures_8cpp.html#a97d760905a6933d095d43ec69570505c">texture_ids</a>[<a class="code" href="jni_2_astc_textures_8cpp.html#afd2b339b64043a84aa6797168d031ebc">current_texture_set_id</a>].earth_color_texture_id));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE2));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="jni_2_astc_textures_8cpp.html#a97d760905a6933d095d43ec69570505c">texture_ids</a>[<a class="code" href="jni_2_astc_textures_8cpp.html#afd2b339b64043a84aa6797168d031ebc">current_texture_set_id</a>].earth_night_texture_id));</div>
</div><!-- fragment --><p>In each 5 sec texture bindings for texture units are refreshed following block size order from the table in section <a class="el" href="astc_textures.html#astcTexturesWhatIsAstc">What is ASTC?</a></p>
<h1><a class="anchor" id="astcTexturesVisualOutput"></a>
Visual output</h1>
<p>You should see visual output similar to:</p>
<div class="image">
<img src="AstcTextures.png" alt="AstcTextures.png"/>
</div>
<h1><a class="anchor" id="astcTexturesAppendixMeshDataFlow"></a>
Appendix: Mesh data flow</h1>
<p>Generating vertex positions, texture coordinates and normal vectors is implemented based on spherical coordinate system. All mesh data are produced by solid sphere constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SolidSphere</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        SolidSphere(<span class="keyword">const</span> <span class="keywordtype">float</span> radius, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rings, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sectors);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Mesh data accessors. */</span></div>
<div class="line">        <span class="keywordtype">float</span>* getSphereVertexData(<span class="keywordtype">int</span>* vertex_data_size);</div>
<div class="line">        <span class="keywordtype">float</span>* getSphereNormalData(<span class="keywordtype">int</span>* normal_data_size);</div>
<div class="line">        <span class="keywordtype">float</span>* getSphereTexcoords (<span class="keywordtype">int</span>* texcoords_size);</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* getSphereIndices(<span class="keywordtype">int</span>* n_indices);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">float</span>* sphere_vertices;</div>
<div class="line">        <span class="keywordtype">float</span>* sphere_normals;</div>
<div class="line">        <span class="keywordtype">float</span>* sphere_texcoords;</div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* <a class="code" href="jni_2_astc_textures_8cpp.html#ae456dcd0a93d8de9630e2283360f8f6e">sphere_indices</a>;</div>
<div class="line">        <span class="keywordtype">int</span> sphere_vertex_data_size;</div>
<div class="line">        <span class="keywordtype">int</span> sphere_normal_data_size;</div>
<div class="line">        <span class="keywordtype">int</span> sphere_texcoords_size;</div>
<div class="line">        <span class="keywordtype">int</span> sphere_n_indices;</div>
<div class="line">};</div>
</div><!-- fragment --><p>User is responsible for passing radius, number of rings (parallels) and sectors (meridians) to the constructor. It computes coordinates for each vertex according to formulas:</p>
<div class="image">
<img src="sphericalCoordinates.png" alt="sphericalCoordinates.png"/>
</div>
<p>In such defined model space &Phi; changes from 0 to 360 degrees and &Theta; from 0 to 180 degrees. As it is depicted on figure, &Theta; range has to be divided by the number of rings and the range of &Phi; by the number of sectors. Smooth appearance of the sphere surface depends on a number of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> R = 1.0f / (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>)(rings - 1);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> S = 1.0f / (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>)(sectors - 1);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> = 0; <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> &lt; rings; <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (s = 0; s &lt; sectors; s++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a> = sinf(<a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> * <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> * R) * cosf(2 * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> * s * S);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = sinf(-M_PI_2 + <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> * <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> * R);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> z = sinf(2.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a> * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> * s * S) * sinf(<a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> * <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> * R);</div>
<div class="line"></div>
<div class="line">         texcoords++ = s * S;</div>
<div class="line">         texcoords++ = <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> * R;</div>
<div class="line"></div>
<div class="line">         <a class="code" href="_cube_8h.html#aebc90711c5df16dd4e6faa8b261cd828">vertices</a>++ = x * radius;</div>
<div class="line">         <a class="code" href="_cube_8h.html#aebc90711c5df16dd4e6faa8b261cd828">vertices</a>++ = y * radius;</div>
<div class="line">         <a class="code" href="_cube_8h.html#aebc90711c5df16dd4e6faa8b261cd828">vertices</a>++ = z * radius;</div>
<div class="line"></div>
<div class="line">         <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#ad42b87bfb03ed9e4b1c35311462cac74">normals</a>++ = <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">         <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#ad42b87bfb03ed9e4b1c35311462cac74">normals</a>++ = <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>;</div>
<div class="line">         <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#ad42b87bfb03ed9e4b1c35311462cac74">normals</a>++ = z;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>For a given vector position P on the sphere who's center is C, the normal is equal to norm(P - C), where norm normalizes the vector. Our sphere center is located at point C(0,0,0), which stands for normal(P - C) = norm(P) = vertices(x,y,z) / radius = (x,y,z). The reason why we generate normal vectors needed for light calculation is introduced in details here <a class="el" href="lighting.html#lightingNormals">Normals</a></p>
<p>Texture coordinates indicating how to map an image onto mesh primitives are precisely covered in section <a class="el" href="texture_cube.html#textureCubeLoadTexture">Load Texture Function</a></p>
<p>Solid sphere constructor is also responsible for generating indices required for glDrawElements function. It has been assumed that each four vertices form two triangle primitives (GL_TRIANGLES mode), so glDrawElements call needs six vertex indices to construct them:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> = 0; <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> &lt; rings; <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (s = 0; s &lt; sectors; s++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* First triangle. */</span></div>
<div class="line">         <a class="code" href="gl2ext_8h.html#a94ae715eebfc1eb65456c0ab9b97f1e9">indices</a>++ = <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>       * sectors + s;</div>
<div class="line">         <a class="code" href="gl2ext_8h.html#a94ae715eebfc1eb65456c0ab9b97f1e9">indices</a>++ = <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>       * sectors + (s + 1);</div>
<div class="line">         <a class="code" href="gl2ext_8h.html#a94ae715eebfc1eb65456c0ab9b97f1e9">indices</a>++ = (<a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> + 1) * sectors + s;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Second triangle. */</span></div>
<div class="line">         indices++ = <a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a>       * sectors + (s + 1);</div>
<div class="line">         indices++ = (<a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> + 1) * sectors + (s + 1);</div>
<div class="line">         indices++ = (<a class="code" href="gl2ext_8h.html#abe08814c2f72843fde4d8df41440d5a0">r</a> + 1) * sectors + s;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the next step generated vertex positions, normals and texture coordinates are loaded into buffer object.</p>
<div class="fragment"><div class="line"><span class="comment">/* Load generated mesh data from SolidSphere object. */</span></div>
<div class="line"><span class="keywordtype">float</span>* sphere_vertices  = <a class="code" href="jni_2_astc_textures_8cpp.html#afec3a1b5ec8072f074c3aeb62343d969">solid_sphere</a>-&gt;getSphereVertexData(&amp;sphere_vertices_size);</div>
<div class="line"><span class="keywordtype">float</span>* sphere_normals   = <a class="code" href="jni_2_astc_textures_8cpp.html#afec3a1b5ec8072f074c3aeb62343d969">solid_sphere</a>-&gt;getSphereNormalData(&amp;sphere_normals_size);</div>
<div class="line"><span class="keywordtype">float</span>* sphere_texcoords = <a class="code" href="jni_2_astc_textures_8cpp.html#afec3a1b5ec8072f074c3aeb62343d969">solid_sphere</a>-&gt;getSphereTexcoords(&amp;sphere_texcoords_size);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Size of the entire buffer. */</span></div>
<div class="line">GLsizei buffer_total_size = sphere_vertices_size + sphere_normals_size + sphere_texcoords_size;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Create buffer object to hold all mesh data. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="jni_2_astc_textures_8cpp.html#a47c3e70e74f07c3c6b3763a764d20aa7">bo_id</a>));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER, <a class="code" href="jni_2_astc_textures_8cpp.html#a47c3e70e74f07c3c6b3763a764d20aa7">bo_id</a>));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER, buffer_total_size, NULL, GL_STATIC_DRAW));</div>
</div><!-- fragment --><p>After the above listing has executed, bo_id contains the unique ID of a buffer object that has been initialized to represent buffer_total_size bytes of storage. Passing GL_ARRAY_BUFFER as a binding point to refer to the buffer object suggests to OpenGL ES that we are about to put data in order to feed vertex attributes. Expected usage pattern of the data store is set to GL_STATIC_DRAW which signalizes graphics driver that buffer content will be set once, but used frequently for drawing.</p>
<p>Then, place the mesh data into the buffer object at the corresponding offsets:</p>
<div class="fragment"><div class="line"><span class="comment">/* Upload subsets of mesh data to buffer object. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER, 0, sphere_vertices_size, sphere_vertices));</div>
<div class="line"></div>
<div class="line"><a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a> += sphere_vertices_size;</div>
<div class="line"></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER, <a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a>, sphere_normals_size, sphere_normals));</div>
<div class="line"></div>
<div class="line"><a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a> += sphere_normals_size;</div>
<div class="line"></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER, <a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a>, sphere_texcoords_size, sphere_texcoords));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In this step the data are copied from a local memory storage to update buffer object's content. Immediately after this, memory pointed by the sphere_vertices, sphere_normals and sphere_texcoords pointers may be freed.</dd></dl>
<p>Before we can go on, let's create a vertex array object to store vertex array state.</p>
<div class="fragment"><div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="jni_2_astc_textures_8cpp.html#ac97430dc005f065ac234be1f8ad0dcad">vao_id</a>));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray(<a class="code" href="jni_2_astc_textures_8cpp.html#ac97430dc005f065ac234be1f8ad0dcad">vao_id</a>));</div>
</div><!-- fragment --><p>Once it is generated and bound, we are able to fill in its content. The goal is to determine OpenGL ES to connect vertex attributes values directly with the data stored in the supplied buffer object.</p>
<div class="fragment"><div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="jni_2_astc_textures_8cpp.html#a65ef4a6e3a2b002afc65bb6f98a1a6b1">position_location</a>));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="jni_2_astc_textures_8cpp.html#a3b1dd85fa563d55f223a892fa3885428">normal_location</a>));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="jni_2_astc_textures_8cpp.html#abff26d3cf94854ec3ee75b13cf715394">texture_coords_location</a>));</div>
<div class="line"></div>
<div class="line"><a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a> = 0;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Populate attribute for position. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="jni_2_astc_textures_8cpp.html#a65ef4a6e3a2b002afc65bb6f98a1a6b1">position_location</a>, 3, GL_FLOAT, GL_FALSE, 0, (<span class="keyword">const</span> GLvoid*) <a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a>));</div>
<div class="line"></div>
<div class="line"><a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a> += sphere_vertices_size;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Populate attribute for normals. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="jni_2_astc_textures_8cpp.html#a3b1dd85fa563d55f223a892fa3885428">normal_location</a>, 3, GL_FLOAT, GL_FALSE, 0, (<span class="keyword">const</span> GLvoid*) <a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a>));</div>
<div class="line"></div>
<div class="line"><a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a> += sphere_normals_size;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Populate attribute for texture coordinates. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="jni_2_astc_textures_8cpp.html#abff26d3cf94854ec3ee75b13cf715394">texture_coords_location</a>, 2, GL_FLOAT, GL_FALSE, 0, (<span class="keyword">const</span> GLvoid*) <a class="code" href="_ground_mesh_8cpp.html#a3edf18f97b34e1141beee42d6d8d780d">buffer_offset</a>));</div>
</div><!-- fragment --><p>Automatic filling of the attributes is enabled with glEnableVertexAttribArray calls. Next, we have to inform graphics driver where the data is and turn on vertex fetching for all attributes. Whereas a non-zero buffer is currently bound to the GL_ARRAY_BUFFER target, last argument in glVertexAttribPointer function specifies an offset in the data store of that buffer.</p>
<h2><a class="anchor" id="astcTexturesSphereLighting"></a>
Sphere lighting</h2>
<p>This sample uses Phong lighting model which has been explained in details in section <a class="el" href="lighting.html">Lighting</a></p>
<h1><a class="anchor" id="astcTexturesReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://www.khronos.org/registry/gles/extensions/KHR/texture_compression_astc_hdr.txt">http://www.khronos.org/registry/gles/extensions/KHR/texture_compression_astc_hdr.txt</a></p>
<p><a class="anchor" id="ref2"></a>[2] <a href="http://malideveloper.arm.com/develop-for-mali/tools/asset-creation/mali-gpu-texture-compression-tool/">http://malideveloper.arm.com/develop-for-mali/tools/asset-creation/mali-gpu-texture-compression-tool/</a></p>
<p><a class="anchor" id="ref3"></a>[3] <a href="http://malideveloper.arm.com/develop-for-mali/tools/astc-evaluation-codec/">http://malideveloper.arm.com/develop-for-mali/tools/astc-evaluation-codec/</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
