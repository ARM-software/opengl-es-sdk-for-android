<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Using multiview rendering</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('multiview.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using multiview rendering </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample presents the GL_OVR_multiview and GL_OVR_multiview2 extensions and how they can be used to improve performance for virtual reality use cases.</p>
<h1><a class="anchor" id="multiviewIntroduction"></a>
Introduction</h1>
<p>Multiview rendering allows draw calls to render to several layers of an array texture simultaneously. The vertex shader can know what layer it is writing to, so that the rendering results can be different for each layer. This can be very useful for virtual reality applications where rendering the same scene from two different positions is necessary.</p>
<div class="image">
<img src="multiview_sample_screen.png" alt="multiview_sample_screen.png"/>
<div class="caption">
Multiview rendering sample.</div></div>
 <dl class="section warning"><dt>Warning</dt><dd>In order to use multiview rendering the GL_OVR_multiview extension is needed. This extension is however limited so that only the output gl_Position can depend on the view index. The extension GL_OVR_multiview2 removes this restriction, making it much more useful as lighting might depend on the position of the camera. Only the GL_OVR_multiview extension is required by this tutorial, as we only change the gl_Position output based on the view index in the sample code. The extension GL_OVR_multiview_multisampled_render_to_texture is also useful as it allows multiview rendering to multisampled textures. Details on thess extensions can be found here <a href="#ref1">[1]</a> and here <a href="#ref2">[2]</a>. Using multiview rendering also restricts you from using geometry and tessellation shaders.</dd></dl>
<h1><a class="anchor" id="multiviewWhatIsMultiview"></a>
What is multiview rendering and why is it useful?</h1>
<p>Virtual reality applications need to render all their scenes twice from different view angles in order to create the illusion of depth. Doing this by simply rendering everything twice with different view and perspective matrices is not optimal, as it requires setting up a mostly identical draw call multiple times. The GL_OVR_multiview extension adresses this issue by allowing one draw call to render to multiple texture layers of an array texture, removing the overhead of setting up multiple draw calls. The vertex and fragment shaders are then invoked once for each texture layer in the attached array texture, and have access to the variable gl_ViewID_OVR which can be used to select view dependent input for each layer. Using this mechanism, an array of view and projection matrices can be used instead of a single matrix, and the shader can choose the right matrix for each layer using gl_ViewID_OVR, allowing one draw call to render from multiple eye positions with little overhead. Rendering to multiple layers with only one draw call can also potentially be done using layered geometry shaders, but this presents a much larger overhead compared to using the multiview extension as geometry shaders are very demanding on performance and multiview is a fixed function solution which allows many internal optimizations compared to geometry shaders.</p>
<h1><a class="anchor" id="multiviewFBO"></a>
Setting up a multiview framebuffer object</h1>
<p>Before using the extension, one should check that it is available, this can be done with the following code, which looks for the GL_OVR_multiview extension. Similar code can be used for checking for the GL_OVR_multiview2 or GL_OVR_multiview_multisampled_render_to_texture extensions if needed.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> GLubyte* extensions = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetString(GL_EXTENSIONS));</div>
<div class="line"><span class="keywordtype">char</span> * found_extension = strstr ((<span class="keyword">const</span> <span class="keywordtype">char</span>*)extensions, <span class="stringliteral">&quot;GL_OVR_multiview&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (NULL == found_extension)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;OpenGL ES 3.0 implementation does not support GL_OVR_multiview extension.\n&quot;</span>);</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is however possible that the glFramebufferTextureMultiviewOVR function is not available in your GL headers even though the extension is supported. If this is the case, eglGetProc can be used to access the function as showed in the following code.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="gl2ext_8h.html#ad29ae09f59bd2e8dbbacd1c9d1c37c94">void</a> (*<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af0cc1fab6ab2ec8fe1bfdcbbaea6d196">PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVR</a>)(<a class="code" href="gl2ext_8h.html#a9fab7f13781659602d1d4ea54569ad01">GLenum</a>, <a class="code" href="gl2ext_8h.html#a9fab7f13781659602d1d4ea54569ad01">GLenum</a>, <a class="code" href="gl2ext_8h.html#adda687347282e5405e89b4fc19a1f8e2">GLuint</a>, GLint, GLint, GLsizei);</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af0cc1fab6ab2ec8fe1bfdcbbaea6d196">PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVR</a> <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af3d9860673af76ee364455278a01cf5b">glFramebufferTextureMultiviewOVR</a>;</div>
<div class="line"></div>
<div class="line">glFramebufferTextureMultiviewOVR =</div>
<div class="line">                (<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af0cc1fab6ab2ec8fe1bfdcbbaea6d196">PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVR</a>)eglGetProcAddress (<span class="stringliteral">&quot;glFramebufferTextureMultiviewOVR&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (!glFramebufferTextureMultiviewOVR)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;Can not get proc address for glFramebufferTextureMultiviewOVR.\n&quot;</span>);</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If this call is successful, the glFramebufferTextureMultiviewOVR can be used as a normal gl function.</p>
<p>The following code sets up a framebuffer object for rendering to multiview. Both the color attachment and the depth attachment are array textures with 2 layers, and both these layers will be rendered to by every draw call used on this framebuffer object. It is important that all attachments have the same number of layers as the framebuffer will not be complete otherwise. The framebuffer object has to be bound to the GL_DRAW_FRAMEBUFFER as otherwise the glFramebufferTextureMultiviewOVR call will give an INVALID_OPERATION error. It is also important that the number of views set up for the framebuffer object matches the number of views declared in the current shader program when drawing, as otherwise the draw call will give an INVALID_OPERATION error. The next section will show how to create a shader program that can be used for multiview rendering.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="_multisampled_f_b_o_8cpp.html#a1b4474f28e6eaa73d75171c3f0765532">setupFBO</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create array texture</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MIN_FILTER, GL_LINEAR));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MAG_FILTER, GL_LINEAR));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 1, GL_RGBA8, width, height, 2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Initialize FBO. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenFramebuffers(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a8d382b5bb41bb1c72aaa9f0f88797f1a">frameBufferObjectId</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Bind our framebuffer for rendering. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a8d382b5bb41bb1c72aaa9f0f88797f1a">frameBufferObjectId</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Attach texture to the framebuffer. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af3d9860673af76ee364455278a01cf5b">glFramebufferTextureMultiviewOVR</a>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                              <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>, 0, 0, 2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Create array depth texture */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 1, GL_DEPTH_COMPONENT24, width, height, 2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Attach depth texture to the framebuffer. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af3d9860673af76ee364455278a01cf5b">glFramebufferTextureMultiviewOVR</a>(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,</div>
<div class="line">                                              <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>, 0, 0, 2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Check FBO is OK. */</span></div>
<div class="line">    GLenum result = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER));</div>
<div class="line">    <span class="keywordflow">if</span> (result != GL_FRAMEBUFFER_COMPLETE)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Framebuffer incomplete at %s:%i\n&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">        <span class="comment">/* Unbind framebuffer. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="multiviewShaders"></a>
Using multiview in shaders to render to several layers</h1>
<p>The following code shows shaders used for multiview rendering. Only the vertex shader contains multiview specific code. It enables the GL_OVR_multiview extension and sets the num_views variable in the layout to 2. This number needs to be the same as the number of views attached to the framebuffer using glFramebufferTextureMultiviewOVR. The shader takes in an array of view projection matrices (view and projection matrices multiplied together), instead of just one, and selects the matrix to use by indexing with gl_ViewID_OVR which gives the index of the current texture layer being rendered to. This allows us to have different camera positions and projections for the different layers, making it possible to render from both eye positions in a VR application with one draw call. There is only one model matrix is this case as the model does not move for the different layers. Only the gl_Position is affected by the gl_ViewID_OVR value in this case, meaning this shader only requires the GL_OVR_multiview extension and not the GL_OVR_multiview2 extension. In order to also change the normal based on gl_ViewID_OVR (or other vertex outputs) the GL_OVR_multiview2 would be required.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#extension GL_OVR_multiview : enable</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(num_views = 2) in;</div>
<div class="line"></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> vertexPosition;</div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> vertexNormal;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> modelViewProjection[2];</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> model;</div>
<div class="line">out <a class="code" href="structvec3.html">vec3</a> v_normal;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = modelViewProjection[gl_ViewID_OVR] * <a class="code" href="structvec4.html">vec4</a>(vertexPosition, 1.0);</div>
<div class="line">    v_normal = (model * <a class="code" href="structvec4.html">vec4</a>(vertexNormal, 0.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>)).xyz;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> v_normal;</div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> f_color;</div>
<div class="line"></div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>(<a class="code" href="structvec3.html">vec3</a> <a class="code" href="gl2ext_8h.html#ac0a41baf8b02de6cb4211d7f15f4872e">n</a>, <a class="code" href="structvec3.html">vec3</a> l, <a class="code" href="structvec3.html">vec3</a> c)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> ndotl = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(dot(n, l), 0.0);</div>
<div class="line">    <span class="keywordflow">return</span> ndotl * c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> albedo = <a class="code" href="structvec3.html">vec3</a>(0.95, 0.84, 0.62);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> n = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(v_normal);</div>
<div class="line">    f_color.rgb = <a class="code" href="structvec3.html">vec3</a>(0.0);</div>
<div class="line">    f_color.rgb += <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>(n, <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="structvec3.html">vec3</a>(1.0)), <a class="code" href="structvec3.html">vec3</a>(1.0));</div>
<div class="line">    f_color.rgb += <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>(n, <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="structvec3.html">vec3</a>(-1.0, -1.0, 0.0)), <a class="code" href="structvec3.html">vec3</a>(0.2, 0.23, 0.35));</div>
<div class="line"></div>
<div class="line">    f_color.a = 1.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The program can be set up in the same way as any other program. The viewProjection matrices must be set up as a matrix array uniform as in the following code. In this example the projection matrices are the same, but for VR one would normally use different projection matrices for each eye. The example later in this tutorial will render to more than 2 layers, and will use different perspective matrices per layer, which is the reason for there being more than one perspective matrix here. The camera positions in this case are set at -1.5 and 1.5 in the x direction, both looking at the center of the scene.</p>
<div class="fragment"><div class="line"><span class="comment">/* M_PI_2 rad = 90 degrees. */</span></div>
<div class="line">projectionMatrix[0] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(M_PI_2, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line">projectionMatrix[1] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(M_PI_2, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Setting up model view matrices for each of the */</span></div>
<div class="line">Vec3f leftCameraPos =  {-1.5f, 0.0f, 4.0f};</div>
<div class="line">Vec3f rightCameraPos = {1.5f, 0.0f, 4.0f};</div>
<div class="line">Vec3f lookAt =         {0.0f, 0.0f, -4.0f};</div>
<div class="line">Vec3f upVec =          {0.0f, 1.0f, 0.0f};</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[0] = Matrix::matrixCameraLookAt(leftCameraPos,  lookAt, upVec);</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[1] = Matrix::matrixCameraLookAt(rightCameraPos, lookAt, upVec);</div>
<div class="line"></div>
<div class="line">modelViewProjectionMatrix[0] = projectionMatrix[0] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[0] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line">modelViewProjectionMatrix[1] = projectionMatrix[1] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[1] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a407d0471ea683fcb1964d843ebaea2a4">multiviewModelViewProjectionLocation</a> = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6a0070f9ff2cb98bb0289b9ce7a21cd7">multiviewProgram</a>, <span class="stringliteral">&quot;modelViewProjection&quot;</span>));</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a5add7810d8c94dae45ad582f25277e02">multiviewModelLocation</a>               = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6a0070f9ff2cb98bb0289b9ce7a21cd7">multiviewProgram</a>, <span class="stringliteral">&quot;model&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Upload matrices. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a407d0471ea683fcb1964d843ebaea2a4">multiviewModelViewProjectionLocation</a>, 2, GL_FALSE, modelViewProjectionMatrix[0].getAsArray()));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a5add7810d8c94dae45ad582f25277e02">multiviewModelLocation</a>, 1, GL_FALSE, modelMatrix.getAsArray()));</div>
</div><!-- fragment --><p>Anything rendered with this program while the multiview framebuffer object is bound will be rendered to both texture layers from different view angles without having to do do multiple draw calls. Having rendered your VR scene to separate layers for each eye, the results now need to be rendered to the screen. This is easily done by binding the texture and rendering with it as a 2D array texture. For a VR application, two viewports can be set up, and for each viewport the relevant texture layer is rendered to the screen. This can be a simple blitting of the texture to the screen, or it can do filtering or other post processing operations on the texture before displaying it. As the texture is an array, the texture sampling operation needs a <a class="el" href="structvec3.html">vec3</a> texture coordinate, where the last coordinate indexes into the array. In order for each draw call to choose different layers, a uniform with the layer index can be provided as in the following fragment shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line">precision mediump <a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>;</div>
<div class="line">precision mediump sampler2DArray;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vTexCoord;</div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragColor;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2DArray tex;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <span class="keywordtype">int</span> layerIndex;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    fragColor = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(tex, <a class="code" href="structvec3.html">vec3</a>(vTexCoord, layerIndex));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="multiviewMultipleFOV"></a>
Rendering to different fields-of-view for virtual reality</h1>
<p>A VR technique that can easily be achieved using multiview rendering is rendering with a higher resolution in the center of each eye's view, with gradually lower resolution further away from the center. Eyes are capable of observing higher resolutions in the center of their view, and this can therefore give better visual results than rendering the entire scene in one resolution. This can be achieved using the multiview extension by rendering to more than one texture layer per eye with different fields-of-view, and blending the resulting layers. One texture layer can be rendered to using a projection matrix giving a wide field of view, rendering the entire scene. Another texture layer can be rendered to using a narrower field of view, so that it only renders the center of the screen, where the eye will be able to see a higher resolution image. As each layer has the same dimensions, the layer with the narrow field of view will be a much higher resolution version of the center of the scene. These two layers can then be blended together to create an image with varying resolution. This method can also give a performance boost, as the FBO can use half the resolution while still getting the same dpi in the center of the screen. Even though you are rendering 4 layers instead of 2, this still cuts the total number of pixels in half. This technique also combines well with barrel distortion warping, which is a common virtual reality technique for making the virtual reality image look correct through a lens. The barrel distortion warping makes objects closer to the center of the viewport larger than objects in the edges. Combined with a varying resolution, this can give a higher resolution for the enlarged objects and a lower resolution for the objects that are made smaller by the barrel distortion warping.</p>
<p>To implement the varying resolution, we first set up a multiview framebuffer object in the same way as shown before, only with 4 layers instead of 2 as there are 2 layers per eye:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="_multisampled_f_b_o_8cpp.html#a1b4474f28e6eaa73d75171c3f0765532">setupFBO</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create array texture</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MIN_FILTER, GL_LINEAR));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MAG_FILTER, GL_LINEAR));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 1, GL_RGBA8, width, height, 4));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Initialize FBO. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenFramebuffers(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a8d382b5bb41bb1c72aaa9f0f88797f1a">frameBufferObjectId</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Bind our framebuffer for rendering. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a8d382b5bb41bb1c72aaa9f0f88797f1a">frameBufferObjectId</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Attach texture to the framebuffer. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af3d9860673af76ee364455278a01cf5b">glFramebufferTextureMultiviewOVR</a>(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                              <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#aa7cd4cec18756bfa7c2feeac421d25c4">frameBufferTextureId</a>, 0, 0, 4));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Create array depth texture */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 1, GL_DEPTH_COMPONENT24, width, height, 4));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Attach depth texture to the framebuffer. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af3d9860673af76ee364455278a01cf5b">glFramebufferTextureMultiviewOVR</a>(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,</div>
<div class="line">                                              <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#af558f16deb24e659a5725d4cbe8fc165">frameBufferDepthTextureId</a>, 0, 0, 4));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Check FBO is OK. */</span></div>
<div class="line">    GLenum result = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER));</div>
<div class="line">    <span class="keywordflow">if</span> (result != GL_FRAMEBUFFER_COMPLETE)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Framebuffer incomplete at %s:%i\n&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">        <span class="comment">/* Unbind framebuffer. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The shaders for rendering the scene are also the same except that the vertex shader specifies num_views to be 4 rather than 2, and takes in arrays of length 4 instead of 2 for the matrices:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#extension GL_OVR_multiview : enable</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(num_views = 4) in;</div>
<div class="line"></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> vertexPosition;</div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> vertexNormal;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> ModelViewProjection[4];</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> model;</div>
<div class="line">out <a class="code" href="structvec3.html">vec3</a> v_normal;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = ModelViewProjection[gl_ViewID_OVR] * <a class="code" href="structvec4.html">vec4</a>(vertexPosition, 1.0);</div>
<div class="line">    v_normal = (model * <a class="code" href="structvec4.html">vec4</a>(vertexNormal, 0.0)).xyz;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code then sets up the projection and view matrices for rendering the scene 4 times. The first two perspective matrices use a 90 degree field of view, rendering the entire scene for each eye. This will be used as the low resolution texture when creating the final image. The next two perspective matrices use a 53.13 degree field of view, as this gives a near plane that is exactly half the size of the 90 degree matrices (tan(53.13/2) * 2 == tan(90/2)). This will be used as the high resolution image. Making the high resolution near plane exactly half the size of the low resolution near plane makes interpolating between the images simpler, as the texture coordinates for the low resolution image can go from 0 to 1, while the texture coordinates for the high resolution image go from -0.5 to 1.5. The high resolution image will then only be sampled in the middle half of the screen, and its contents will match the content of the low resolution texture at the same screen coordinates, only with a higher resolution.</p>
<div class="fragment"><div class="line"><span class="comment">/* M_PI_2 rad = 90 degrees. */</span></div>
<div class="line">projectionMatrix[0] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(M_PI_2, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line">projectionMatrix[1] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(M_PI_2, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line"><span class="comment">/* 0.9272952188 rad = 53.1301024 degrees. This angle gives half the size for the near plane. */</span></div>
<div class="line">projectionMatrix[2] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(0.9272952188<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line">projectionMatrix[3] = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(0.9272952188<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, (<span class="keywordtype">float</span>)width / (<span class="keywordtype">float</span>)height, 0.1<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 100.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Setting up model view matrices for each of the */</span></div>
<div class="line">Vec3f leftCameraPos =  {-1.5f, 0.0f, 4.0f};</div>
<div class="line">Vec3f rightCameraPos = {1.5f, 0.0f, 4.0f};</div>
<div class="line">Vec3f lookAt =         {0.0f, 0.0f, -4.0f};</div>
<div class="line">Vec3f upVec =          {0.0f, 1.0f, 0.0f};</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[0] = Matrix::matrixCameraLookAt(leftCameraPos,  lookAt, upVec);</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[1] = Matrix::matrixCameraLookAt(rightCameraPos, lookAt, upVec);</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[2] = Matrix::matrixCameraLookAt(leftCameraPos,  lookAt, upVec);</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[3] = Matrix::matrixCameraLookAt(rightCameraPos, lookAt, upVec);</div>
<div class="line"></div>
<div class="line">modelViewProjectionMatrix[0] = projectionMatrix[0] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[0] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line">modelViewProjectionMatrix[1] = projectionMatrix[1] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[1] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line">modelViewProjectionMatrix[2] = projectionMatrix[2] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[2] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line">modelViewProjectionMatrix[3] = projectionMatrix[3] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a994944df96442a4465f97cceaa38f96f">viewMatrix</a>[3] * <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6432678cb9c74fb38c2289a6f75199d8">modelMatrix</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a407d0471ea683fcb1964d843ebaea2a4">multiviewModelViewProjectionLocation</a> = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6a0070f9ff2cb98bb0289b9ce7a21cd7">multiviewProgram</a>, <span class="stringliteral">&quot;modelViewProjection&quot;</span>));</div>
<div class="line"><a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a5add7810d8c94dae45ad582f25277e02">multiviewModelLocation</a>               = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a6a0070f9ff2cb98bb0289b9ce7a21cd7">multiviewProgram</a>, <span class="stringliteral">&quot;model&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Upload matrices. */</span></div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a407d0471ea683fcb1964d843ebaea2a4">multiviewModelViewProjectionLocation</a>, 4, GL_FALSE, modelViewProjectionMatrix[0].getAsArray()));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a5add7810d8c94dae45ad582f25277e02">multiviewModelLocation</a>, 1, GL_FALSE, modelMatrix.getAsArray()));</div>
</div><!-- fragment --><p>Every draw call using the shader and matrix setup shown above will render to all 4 layers of the framebuffer object using the different view and projection matrices. The resulting images will then be blended to the screen to create a varying resolution image for each eye using the following shaders.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>in <a class="code" href="structvec3.html">vec3</a> attributePosition;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> attributeLowResTexCoord;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> attributeHighResTexCoord;</div>
<div class="line">out <a class="code" href="structvec2.html">vec2</a> vLowResTexCoord;</div>
<div class="line">out <a class="code" href="structvec2.html">vec2</a> vHighResTexCoord;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    vLowResTexCoord = attributeLowResTexCoord;</div>
<div class="line">    vHighResTexCoord = attributeHighResTexCoord;</div>
<div class="line">    gl_Position = <a class="code" href="structvec4.html">vec4</a>(attributePosition, 1.0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line">precision mediump <a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>;</div>
<div class="line">precision mediump sampler2DArray;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vLowResTexCoord;</div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> vHighResTexCoord;</div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragColor;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2DArray tex;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <span class="keywordtype">int</span> layerIndex;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> lowResSample = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(tex, <a class="code" href="structvec3.html">vec3</a>(vLowResTexCoord, layerIndex));</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> highResSample = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(tex, <a class="code" href="structvec3.html">vec3</a>(vHighResTexCoord, layerIndex + 2));</div>
<div class="line">    <span class="comment">// Using squared distance to middle of screen for interpolating.</span></div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> distVec = <a class="code" href="structvec2.html">vec2</a>(0.5) - vHighResTexCoord;</div>
<div class="line">    <span class="keywordtype">float</span> squaredDist = dot(distVec, distVec);</div>
<div class="line">    <span class="comment">// Using the high res texture when distance from center is less than 0.5 in texture coordinates (0.25 is 0.5 squared).</span></div>
<div class="line">    <span class="comment">// When the distance is less than 0.2 (0.04 is 0.2 squared), only the high res texture will be used.</span></div>
<div class="line">    <span class="keywordtype">float</span> lerpVal = <a class="code" href="_translucency_2jni_2common_2matrix_8h.html#a9adb31f089bc3242295eb00cf26dfe98">smoothstep</a>(-0.25, -0.04, -squaredDist);</div>
<div class="line">    fragColor = mix(lowResSample, highResSample, lerpVal);</div>
<div class="line">}</div>
</div><!-- fragment --><p>A viewport for each eye is created, and for each viewport this shader program is used to draw a full screen textured quad. There are different texture coordinates for the high resolution and low resolution images, as the high resolution image should be drawn at half the size of the low resolution image and centered in the middle of the screen. This is achieved by the following texture coordinates:</p>
<div class="fragment"><div class="line"><span class="comment">/* Textured quad low resolution texture coordinates */</span></div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a4cbb788cae37d7c9ea4eafd62b48d9f0">texturedQuadLowResTexCoordinates</a>[] =</div>
<div class="line">{</div>
<div class="line">    0, 0,</div>
<div class="line">    1, 0,</div>
<div class="line">    1, 1,</div>
<div class="line"></div>
<div class="line">    0, 0,</div>
<div class="line">    1, 1,</div>
<div class="line">    0, 1</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Textured quad high resolution texture coordinates */</span></div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="tutorials_2_foveated_rendering_2jni_2_native_8cpp.html#a46ba7859b59935d7081e4075cb0c1bc4">texturedQuadHighResTexCoordinates</a>[] =</div>
<div class="line">{</div>
<div class="line">    -0.5, -0.5,</div>
<div class="line">     1.5, -0.5,</div>
<div class="line">     1.5,  1.5,</div>
<div class="line"></div>
<div class="line">    -0.5, -0.5,</div>
<div class="line">     1.5,  1.5,</div>
<div class="line">    -0.5,  1.5</div>
<div class="line">};</div>
</div><!-- fragment --><p>The layerIndex used to select the texture array layer is set up in the same way as in the earlier example, but the shader will sample both the layer at layerIndex and the one at layerIndex + 2, as the last 2 layers in the array texture contain the high resolution images. The sampled colors are then interpolated based on the distance to the middle of the screen. The shader calculates the squared distance to the middle of the screen rather than the actual distance as this removes the need for doing a square root operation. This works as long as the limits used in the smoothstep call are adjusted accordingly, which gives no extra work as these are constant values.</p>
<p>After drawing a full screen quad using this shader for each eye viewport, the high and low resolution images have been blended to give higher resolution in the center of the image where the eye is focused, with the resolution gradually decreasing further away from the center, where the eye is not focusing. The image in the introduction shows the result, where 3 rotating cubes have been drawn from each eye, and the center of each eye's viewport gets a higher resolution than the rest of the screen. The following image is a lower resolution version of the same scene, making it easier to see how the resolution increases towards the center of each eye's viewport.</p>
<div class="image">
<img src="low_res_multiview_sample_screen.png" alt="low_res_multiview_sample_screen.png"/>
<div class="caption">
Low resolution multiview rendering sample.</div></div>
<p> This technique can also be used to create a movable focal point, i.e. for directing the viewer's focus towards a certain part of the scene. To do this, the camera for the high resolution image would have to be moved around to capture different parts of the scene, and the texture coordinates used when blending would have to be adjusted accordingly.</p>
<h1><a class="anchor" id="multiviewReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://www.khronos.org/registry/gles/extensions/OVR/multiview.txt">http://www.khronos.org/registry/gles/extensions/OVR/multiview.txt</a></p>
<p><a class="anchor" id="ref2"></a>[2] <a href="http://www.khronos.org/registry/gles/extensions/OVR/multiview2.txt">http://www.khronos.org/registry/gles/extensions/OVR/multiview2.txt</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
