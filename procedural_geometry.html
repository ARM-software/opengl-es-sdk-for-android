<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Procedural modelling with geometry shaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('procedural_geometry.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Procedural modelling with geometry shaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample uses OpenGL ES 3.1 and the Android extension pack to procedurally generate complex geometry in real-time with geometry shaders.</p>
<div class="image">
<img src="proceduralGeometry-title.png" alt="proceduralGeometry-title.png"/>
</div>
<h1><a class="anchor" id="proceduralGeometryIntroduction"></a>
Introduction</h1>
<p>The Android extension pack adds many new features to the mobile platform. Some features have been exclusive to desktop OpenGL for a long time, such as geometry and tessellation shader stages. In this sample, we showcase the use of geometry shaders to generate meshes from procedural surfaces, in real-time.</p>
<p>The source for this sample can be found in the folder of the SDK.</p>
<h2><a class="anchor" id="proceduralGeometryGeometryShaders"></a>
Geometry shaders</h2>
<p>The geometry shader is an optional programmable stage in the pipeline, that allows the programmer to create new geometry on the fly, using the output of the vertex shader as input. For example, we could invoke the geometry shader with a set of N points using a single draw call,</p>
<div class="fragment"><div class="line">glDrawArrays(GL_POINTS, 0, N)</div>
</div><!-- fragment --><p>and output a triangle for each such point in the geometry shader,</p>
<div class="fragment"><div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(points) in;</div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> vs_position[];</div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> position = vs_position[0];</div>
<div class="line">    gl_Position = position - <a class="code" href="structvec4.html">vec4</a>(0.05, 0.0, 0.0);</div>
<div class="line">    EmitVertex();</div>
<div class="line">    gl_Position = position + <a class="code" href="structvec4.html">vec4</a>(0.05, 0.0, 0.0);</div>
<div class="line">    EmitVertex();</div>
<div class="line">    gl_Position = position + <a class="code" href="structvec4.html">vec4</a>(0.0, 0.05, 0.0);</div>
<div class="line">    EmitVertex();</div>
<div class="line">    EndPrimitive();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this demo, we use geometry shaders to output a variable number of triangles (up to 6), given a set of points in a grid as input. For a more in in-depth introduction to geometry shaders, see [6].</p>
<h1><a class="anchor" id="proceduralGeometryIsosurfaces"></a>
Isosurfaces</h1>
<p>In traditional 3D graphics, we are used to thinking about surfaces as a set of connected triangles. Modelling such surfaces involve meticulous placing of points, and connecting them together to make faces. For certain types of geometry, this works alright. But making natural-looking, organic geometry is a very tedious process in this representation.</p>
<p>In this demo, we will take advantage of recent advances in GPU hardware and use a more suitable surface representation, to generate complex surfaces in real-time. Instead of describing our surface as a set of triangles, we will define our surface as the set of points where a function of three spatial coordinates evaluates to zero. In mathematical terminology, this set is known as the isosurface of the function, and the function is referred to as a potential.</p>
<p>It might be difficult to imagine what that would look like, but think of it like this: An elevation map can be considered as a function, which takes a point (x, y) in the plane and gives the height at that point. The set of points where the height is equal to a specific value is called an isoline, because it traces out a curve in the plane. An isosurface is the same concept, but bumped up one dimension.</p>
<p>Isosurfaces are nothing new. They have been commonly used to visualize simulations in computational fluid dynamics, or in medical imaging to visualize regions of a particular density in a three-dimensional CT scan.</p>
<h2><a class="anchor" id="proceduralGeometryModellingIsosurfaces"></a>
Modelling isosurfaces</h2>
<p>I've criticized triangles as being unfit for modelling organic geometry, so I better prove to you that this isosurface stuff is somehow better! To that end, let's take a look at how you might make some simple terrain.</p>
<p>Let's begin with a plane. For that we need a function which is negative below the plane and positive above it. When a point is on the plane, the function is zero.</p>
<div class="image">
<img src="proceduralGeometry-making-1.png" alt="proceduralGeometry-making-1.png"/>
</div>
<p>In code this could be described as </p>
<pre class="fragment">surface = p.y;
</pre><p>where <code>p</code> is the sampling point in 3D space, and <code>surface</code> is the function value as stored in the 3D texture. Terrain usually has some valleys, so let's add a value that oscillates as the sampling point travels the xz-plane.</p>
<div class="image">
<img src="proceduralGeometry-making-2.png" alt="proceduralGeometry-making-2.png"/>
</div>
 <pre class="fragment">surface = p.y;
surface += 0.1 * sin(p.x * 2.0 * pi) * sin(p.z * 2.0 * pi);
</pre><p>Getting there, but this hardly looks like something you would find in nature. A common tool in procedural modelling is to use noise. There are many varieties of noise, such as simplex-, Perlin- or Worley-noise ([8], [9], [10]), that can be used to make interesting perturbations.</p>
<div class="image">
<img src="proceduralGeometry-making-3.png" alt="proceduralGeometry-making-3.png"/>
</div>
 <pre class="fragment">surface = p.y;
surface += 0.1 * sin(p.x * 2.0 * pi) * sin(p.z * 2.0 * pi);
surface += 0.075 * snoise(p * 4.0);
</pre><p>This is pretty good. But let's say we want the terrain to flatten out at the top. To do this, we can intersect the surface with a plane that is facing downwards and cutting the terrain through the tops.</p>
<div class="image">
<img src="proceduralGeometry-making-4.png" alt="proceduralGeometry-making-4.png"/>
</div>
 <pre class="fragment">surface = p.y;
surface += 0.1 * sin(p.x * 2.0 * pi) * sin(p.z * 2.0 * pi);
surface += 0.075 * snoise(p * 4.0);
surface = max(surface, -(p.y - 0.05));
</pre><p>We encourage the reader to have a look at Inigo Quilez's introduction to modelling with distance functions [5]. Our demo doesn't rely on the potential function being a distance field - that is, the value describes the distance to the closest surface - but the article describes some mathematical tricks that still apply. Nevertheless, this short exercise should have shown how compact we can represent the geometry, and how the representation allows for much easier experimentation, than a conventional triangle description.</p>
<h1><a class="anchor" id="proceduralGeometryVisualizingIsosurfaces"></a>
Visulizing isosurfaces</h1>
<p>Now that we have a sense of what isosurfaces are, and how we can make them, we need a way of drawing them. There are many methods for visualizing isosurfaces; some based on raytracing, some based on generating a polygonal mesh. We do not intend to give an overview of them here.</p>
<p>A famous method in the latter category is the marching cubes algorithm. Its popularity is perhaps best attributed to the splendid exposition by Paul Bourke [4], which does a fine job at explaining the technique, and provides a small and fast implementation as well.</p>
<p>In the demo, we use a different meshing technique known as surface nets. This technique appears to give similar mesh quality as marching cubes, but with considerably less geometry. Less geometry means less bandwidth, which is important to keep your mobile GPU happy.</p>
<h2><a class="anchor" id="proceduralGeometryNaiveSurfaceNets"></a>
Naive surface nets</h2>
<p>The marching cubes technique was initially published in 1987, and is getting rather old. Not surprisingly, a lot of research has been done on the subject since then, and new techniques have emerged. Surface nets is a technique that was first introduced by Sarah Frisken [1] in 1999. The large time gap between the two techniques might lead you to believe that there may be a similar gap in complexity. But surprisingly enough, the naive version of surface nets [7] is simple enough, that you may even have thought of it yourself! Let's first take a look at how it works in 2D.</p>
<div class="image">
<img src="proceduralGeometry-surface-nets-1.png" alt="proceduralGeometry-surface-nets-1.png"/>
</div>
<p>We begin by laying a grid over the surface domain. In every cell of the grid, we sample its four corners to obtain four values of the potential function. If all values have the same sign, then the cell is either completely inside or outside the surface. But if there is a sign change between two corners, then the function must have intersected the edge between them.</p>
<div class="image">
<img src="proceduralGeometry-surface-nets-2.png" alt="proceduralGeometry-surface-nets-2.png"/>
</div>
<p>If we place a single vertex in the center of each cell that contains an intersected edge, and connect neighbouring cells together, then we get a very rough approximation of the surface. The next step is to somehow smooth out the result. In the original paper, Gibson proposes an iterative relaxation scheme that minimizes a measure of the global surface "roughness". In each pass of this routine all vertices are perturbed closer to the surface, but kept inside their original box. The latter constraint is important to preserve sharp features on the surface.</p>
<p>However, global optimization like that can be quite hairy to implement in real-time. A simpler approach is to compute the surface intersection point on each edge in a cell, summing them up and computing the average. The figure below shows intersection points as x's and their average - the center of mass, if you will - as dashes.</p>
<div class="image">
<img src="proceduralGeometry-surface-nets-3.png" alt="proceduralGeometry-surface-nets-3.png"/>
</div>
<p>The vertex is then perturbed to the center of mass, as shown below. This turns out to work rather well. It gives a smoother mesh, while preserving sharp features by keeping vertices inside their cells.</p>
<div class="image">
<img src="proceduralGeometry-surface-nets-4.png" alt="proceduralGeometry-surface-nets-4.png"/>
</div>
<p>You can imagine how the technique extends itself to the third dimension. Each cell becomes a cube, and instead of linking neighbouring cells together by lines, they are connected by faces. The figure shows the process for a 3D sphere. On the left we show the mesh generated by linking together surface cells without the smoothing step. On the right, the vertices are perturbed towards the center of mass.</p>
<div class="image">
<img src="proceduralGeometry-surface-nets-3d-1.png" alt="proceduralGeometry-surface-nets-3d-1.png"/>
</div>
<p>This naive implementation - as it is called [7] - lends itself very well to parallelization, as described in the next section.</p>
<h2><a class="anchor" id="proceduralGeometryGPUImplementation"></a>
Implementing surface nets on the GPU</h2>
<p>Our GPU implementation works in three passes:</p>
<ol type="1">
<li>For each sample point in the grid (i.e. each corner of each cube): Sample the potential function, and store the result in a 3D texture.</li>
<li>For each cube in the grid: Fetch the function value at its 8 corners, and compute the center of mass. Store the result in another 3D texture.</li>
<li>For each cube in the grid that was on the surface: Construct faces by linking together neighbor cells that were on the surface too.</li>
</ol>
<p>The first two passes are implemented in compute shaders, while the third pass uses a geometry shader to produce faces on-the-fly. It was easy to create links between surface cells for the 2D case above, but it might require a stretch of your imagination to do the same in 3D. So let's elaborate a bit on that.</p>
<div class="image">
<img src="proceduralGeometry-triangles.png" alt="proceduralGeometry-triangles.png"/>
</div>
<p>Generally, each cube on the surface can connect to its six neighbors with 12 possible triangles. A triangle is only created if both relevant neighbors are also on the surface. But considering all triangles for each cube would give redundant and overlapping triangles. To simplify, we construct faces backwards from a cube, connecting with neighbors behind, below or to the left of it. This means that we consider three edges for each cube. If an edge exhibits a sign change, the vertices associated with the four cubes that contain the edge are joined to form a quad.</p>
<p>To speed up the third pass, we only process cells that we know to be on the surface. This is done by the use of indirect draw calls and atomic counters. In the second pass, if the surface intersects the cell, we write the cell's index to an index buffer and increment the count atomically.</p>
<div class="fragment"><div class="line">uint unique = atomicCounterIncrement(outCount);</div>
<div class="line"><span class="keywordtype">int</span> index = texel.z * N * N + texel.y * N + texel.x;</div>
<div class="line">outIndices[unique] = uint(index);</div>
</div><!-- fragment --><p>Here, N is the sidelength of the grid. When performing the draw call for the geometry shader, we bind a buffer containing the grid of points, the index buffer contaning which points to process, and an indirect draw call buffer contaning the draw call parameters.</p>
<div class="fragment"><div class="line">glBindBuffer(GL_ARRAY_BUFFER, <a class="code" href="_terrain_2jni_2main_8cpp.html#a2dbb6285ec1dd21efe5a1b54849a6700">app</a>-&gt;points_buffer);</div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <a class="code" href="_terrain_2jni_2main_8cpp.html#a2dbb6285ec1dd21efe5a1b54849a6700">app</a>-&gt;index_buffer);</div>
<div class="line">glBindBuffer(GL_DRAW_INDIRECT_BUFFER, <a class="code" href="_terrain_2jni_2main_8cpp.html#a2dbb6285ec1dd21efe5a1b54849a6700">app</a>-&gt;indirect_buffer);</div>
<div class="line">glDrawElementsIndirect(GL_POINTS, GL_UNSIGNED_INT, 0);</div>
</div><!-- fragment --><h1><a class="anchor" id="proceduralGeometryShading"></a>
Texturing and shading</h1>
<p>The resulting mesh can look slightly bland. An easy way to add texture is to use an altitude-based color lookup. In the demo, we map certain heights to certain colors using a 2D texture lookup. The height determines the u coordinate, and allow for the use of the v coordinate to add some variation.</p>
<div class="image">
<img src="proceduralGeometry-gradient.jpg" alt="proceduralGeometry-gradient.jpg"/>
</div>
<p>Lighting is done by approximating the gradient of the potential function in the geometry shader and normalizing, like so</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> v000 = texelFetch(inSurface, texel, 0).r;</div>
<div class="line"><span class="keywordtype">float</span> v100 = texelFetch(inSurface, texel + ivec3(1, 0, 0), 0).r;</div>
<div class="line"><span class="keywordtype">float</span> v010 = texelFetch(inSurface, texel + ivec3(0, 1, 0), 0).r;</div>
<div class="line"><span class="keywordtype">float</span> v001 = texelFetch(inSurface, texel + ivec3(0, 0, 1), 0).r;</div>
<div class="line">n = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="structvec3.html">vec3</a>(v100 - v000,</div>
<div class="line">                   v010 - v000,</div>
<div class="line">                   v001 - v000));</div>
</div><!-- fragment --><p>This gives a very faceted look, as the normal is only computed per face. A smoother normal could be computed by approximating the gradient at each generated vertex, and blending between them in the fragment shader. Alternatively - but costly - you could sample the gradient in the fragment shader.</p>
<h1><a class="anchor" id="proceduralGeometryFurtherReading"></a>
Further reading</h1>
<p>In this demo we have taken a look at how we can use potential functions to model complex geometry, and the rendering of such functions using mesh extraction with geometry shaders. There has been much research in the area of mesh extraction, and we have only taken a brief look at one technique.</p>
<p>More advanced meshing techniques, such as dual contouring [3], improve upon the shortcomings of surface nets, and allow for the use of adaptive octrees on much larger grids.</p>
<p>Triplanar projection mapping [2] can be used to map a texture onto all three axes of your geometry, with minimal distortion. It can add more fidelity and variation beyond simple altitude-based color lookups.</p>
<h1><a class="anchor" id="proceduralGeometryReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] Sarah F. Frisken Gibson. "Constrained Elastic Surface Nets", <a href="http://www.merl.com/publications/docs/TR99-24.pdf">available online</a>.</p>
<p><a class="anchor" id="ref2"></a>[2] Ryan Geiss. "Generating Complex Procedural Terrains Using the GPU", <a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html">available online</a>.</p>
<p><a class="anchor" id="ref3"></a>[3] T. Ju, F. Losasso, S. Schaefer, and J. Warren. "Dual Contouring of Hermite Data", <a href="http://www.frankpetterson.com/publications/dualcontour/dualcontour.pdf">available online</a>.</p>
<p><a class="anchor" id="ref4"></a>[4] Paul Bourke. "Polygonising a scalar field", <a href="http://paulbourke.net/geometry/polygonise/">available online</a>.</p>
<p><a class="anchor" id="ref5"></a>[5] Inigo Quilez. "Modeling with distance functions", <a href="http://iquilezles.org/www/articles/distfunctions/distfunctions.htm">available online</a>.</p>
<p><a class="anchor" id="ref6"></a>[6] open.gl. "Geometry shaders", <a href="https://open.gl/geometry">available online</a>.</p>
<p><a class="anchor" id="ref7"></a>[7] Mikola Lysenko. "Smooth Voxel Terrain", <a href="http://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/">available online</a>.</p>
<p><a class="anchor" id="ref8"></a>[8] Wikipedia. "Simplex noise", <a href="https://en.wikipedia.org/wiki/Simplex_noise">available online</a>.</p>
<p><a class="anchor" id="ref9"></a>[9] Wikipedia. "Perlin noise", <a href="https://en.wikipedia.org/wiki/Perlin_noise">available online</a>.</p>
<p><a class="anchor" id="ref10"></a>[10] Wikipedia. "Worley noise", <a href="https://en.wikipedia.org/wiki/Worley_noise">available online</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
