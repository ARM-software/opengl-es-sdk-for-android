<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Boids</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('boids.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Boids </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Demonstration of Transform Feedback functionality in OpenGL ES 3.0.</p>
<h1><a class="anchor" id="boidsIntroduction"></a>
Introduction</h1>
<p>It is assumed that you have read and understood all of the mechanisms described in <a class="el" href="assetLoading.html">Asset Loading</a> and <a class="el" href="simpleTriangle.html">Simple Triangle</a>.</p>
<h1><a class="anchor" id="boidsOverview"></a>
Overview</h1>
<div class="image">
<img src="Boids_android.png" alt="Boids_android.png"/>
<div class="caption">
The application displays 30 spheres: 1 leader and 29 followers.</div></div>
<p> Demonstration of Transform Feedback functionality in OpenGL ES 3.0.</p>
<p>Demonstrates the use of uniform buffers. The application displays 30 spheres on the screen. Locations and velocities of the spheres in 3D space are regularly updated to simulate bird flocking. There is 1 leader sphere (red) and 29 followers (green). The leader follows a set looping path and the followers 'flock' in relation to the leader and the other followers. The calculation of the locations of the boids is done on the GPU each frame using a vertex shader prior to rendering the scene.</p>
<p>All of the data for the boids stays in GPU memory (by using buffers) and is not transferred back to the CPU. Transform feedback buffers are used to store the movement information output from the vertex shader, and this data is then used as the input data on the next pass. The same data is used when rendering the scene.</p>
<h1><a class="anchor" id="boidsRenderGeometry"></a>
Render a Geometry</h1>
<p>To render any kind of geometry: quad, cube, sphere or any kind of more complicated model, the best way is to render triangles that make up the requested shape. So the very first thing we need to do is to generate the coordinates of those triangles. Please remember that it is very important to follow one order (clockwise or counter clockwise) while calculating the coordinates, otherwise (if you mix them), OpenGL ES may have some trouble with detecting front and back faces. We will use <em>counter clockwise</em> order as this is default for OpenGL ES.</p>
<p>The point coordinates of triangles which make up the geometry we want to render (in our case that would be a sphere) are generated within the following function</p>
<div class="fragment"><div class="line">    SphereModel::getTriangleRepresentation(radius,</div><div class="line">                                           <a class="code" href="_anti_alias_8cpp.html#aea98d73b1903ddaeda99c0784d60d78c">numberOfSamples</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a3df9207d1256298b35f33797a1527b33">numberOfSphereTriangleCoordinates</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ad2ff82617f36c361a25970bcacc50baa">numberOfSphereTrianglePoints</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a7c7fb59cfe09ebf69b556750de87e490">sphereTrianglesCoordinates</a>);</div></div><!-- fragment --><p> For more details please look into the implementation.</p>
<p>The next step is to transfer the generated data into a buffer object and use it whilst rendering. But let's describe the problem in basic steps.</p>
<p>Generate a buffer object.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffers. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab90465831e14c969c92180d991f51905">numberOfBufferObjectIds</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>));</div><div class="line"></div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a4dcd44ed38e7fd5cc22131fa51ef8b4e">sphereCoordinatesBufferObjectId</a>             = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[0];</div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a51a39b637b4100efb9f98a28f218ceea">sphereColorsBufferObjectId</a>                  = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[1];</div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a1f96df73fe8d202ffc09365c64cf75be">spherePingPositionAndVelocityBufferObjectId</a> = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[2];</div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a> = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[3];</div></div><!-- fragment --><p> In the application we will need more buffer objects, however at this point we are interested in only one, so you can use the below function instead.</p>
<div class="fragment"><div class="line"><a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenbuffers(1, &amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a4dcd44ed38e7fd5cc22131fa51ef8b4e">sphereCoordinatesBufferObjectId</a>));</div></div><!-- fragment --><p>Once the buffer object ID is generated, we can use that object to store the coordinates data.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a4dcd44ed38e7fd5cc22131fa51ef8b4e">sphereCoordinatesBufferObjectId</a>));</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a3df9207d1256298b35f33797a1527b33">numberOfSphereTriangleCoordinates</a>,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a7c7fb59cfe09ebf69b556750de87e490">sphereTrianglesCoordinates</a>,</div><div class="line">                          GL_STATIC_DRAW));</div></div><!-- fragment --><p> The next step is to associate the input data for a program object with a specific array buffer object and then enable the vertex attrib array. This can be done as follows.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a4dcd44ed38e7fd5cc22131fa51ef8b4e">sphereCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>,</div><div class="line">                                       3,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       0));</div></div><!-- fragment --><p> We will soon explain what value should be used for the <em>positionLocation</em> argument.</p>
<p>In the OpenGL ES 3.0 there is no rendering without program objects. First of all, we need to:</p>
<ol type="1">
<li>create program object ID, <div class="fragment"><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a> = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCreateProgram());</div></div><!-- fragment --></li>
<li>create shader objects' IDs (should be called twice for <em>shaderType</em> equal to <em>GL_FRAGMENT_SHADER</em> and <em>GL_VERTEX_SHADER</em>), <div class="fragment"><div class="line">        *shaderObjectIdPtr = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCreateShader(shaderType));</div></div><!-- fragment --></li>
<li>set shader source, <div class="fragment"><div class="line">        <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>[0]         = <a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#aceb8b27cd7d369c524624ede81a1299e">loadShader</a>(filename);</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glShaderSource(*shaderObjectIdPtr, 1, <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>, NULL));</div></div><!-- fragment --></li>
<li>compile shader (it is always a good idea to check whether the compilation succeeded: <em>GL_COMPILE_STATUS</em> set to <em>GL_TRUE</em>, <div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCompileShader(*shaderObjectIdPtr));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetShaderiv(*shaderObjectIdPtr, GL_COMPILE_STATUS, &amp;compileStatus));</div></div><!-- fragment --></li>
<li>attach shaders to program object, <div class="fragment"><div class="line">    <span class="comment">/* Attach vertex and fragment shaders to rendering program. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#acc1eb33f2e499064566b78ec020099a4">vertexShaderId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab4fa89f786e9fe64ec88be5363d3e79c">fragmentShaderId</a>));</div></div><!-- fragment --></li>
<li>link program object, <div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glLinkProgram(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>));</div></div><!-- fragment --></li>
<li>use program. <div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>));</div></div><!-- fragment --></li>
</ol>
<p>And now we are ready to tell you what the <em>positionLocation</em> (mentioned above) represents. This is a location of an attribute in the program object. We can retrieve this value by calling</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>          = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation   (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;attributePosition&quot;</span>));</div></div><!-- fragment --><p> The second argument, <em>attributePosition</em>, is the same name as used in the vertex shader. Please refer to the shader sources.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader source: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const int numberOfSpheres = 30;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;const float pi = 3.14159265358979323846;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in      vec4 attributePosition;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;in      vec4 attributeColor;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;out     vec4 vertexColor;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;uniform vec4 perspectiveVector;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;uniform vec3 scalingVector;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform vec3 cameraVector;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;/* </div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; * We use uniform block in order to reduce amount of memory transfers to minimum. </div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; * The uniform block uses data taken directly from a buffer object. </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; */</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;uniform BoidsUniformBlock</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;{</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    vec4 sphereLocation[numberOfSpheres];</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;};</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;void main()</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;{</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    float fieldOfAngle     = 1.0 / tan(perspectiveVector.x * 0.5);</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    vec3  locationOfSphere = vec3 (sphereLocation[gl_InstanceID].x, sphereLocation[gl_InstanceID].y, sphereLocation[gl_InstanceID].z);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    </div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    /* Set red color for leader and green color for followers. */</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    if(gl_InstanceID == 0)</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;        vertexColor = vec4(attributeColor.x, 0.5 * attributeColor.y, 0.5 * attributeColor.z, attributeColor.w);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    }</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    else</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    {</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        vertexColor = vec4(0.5 * attributeColor.x, attributeColor.y, 0.5 * attributeColor.z, attributeColor.w);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    /* Create transformation matrices. */</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    mat4 translationMatrix = mat4(1.0,                 0.0,                   0.0,                 0.0, </div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                                  0.0,                 1.0,                   0.0,                 0.0, </div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                                  0.0,                 0.0,                   1.0,                 0.0, </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                  locationOfSphere.x,  locationOfSphere.y,    locationOfSphere.z,  1.0);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                  </div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    mat4 cameraMatrix      = mat4(1.0,                 0.0,                   0.0,                 0.0, </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                  0.0,                 1.0,                   0.0,                 0.0, </div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                  0.0,                 0.0,                   1.0,                 0.0, </div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                  cameraVector.x,      cameraVector.y,        cameraVector.z,      1.0);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                                  </div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    mat4 scalingMatrix     = mat4(scalingVector.x,     0.0,                   0.0,                 0.0, </div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                                  0.0,                 scalingVector.y,       0.0,                 0.0, </div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                                  0.0,                 0.0,                   scalingVector.z,     0.0, </div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                                  0.0,                 0.0,                   0.0,                 1.0);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                                  </div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    mat4 perspectiveMatrix = mat4(fieldOfAngle/perspectiveVector.y,  0.0,            0.0,                                                                                              0.0, </div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                  0.0,                               fieldOfAngle,   0.0,                                                                                              0.0, </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                                  0.0,                               0.0,            -(perspectiveVector.w + perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z),       -1.0, </div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                  0.0,                               0.0,            (-2.0 * perspectiveVector.w * perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z), 0.0);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    /* Compute scaling. */</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    mat4 tempMatrix = scalingMatrix;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    </div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    /* Compute translation. */</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    tempMatrix      = translationMatrix * tempMatrix;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    tempMatrix      = cameraMatrix      * tempMatrix;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                </div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    /* Compute perspective. */</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    tempMatrix      = perspectiveMatrix * tempMatrix;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;                </div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    /* Return gl_Position. */</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    gl_Position     = tempMatrix * attributePosition;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div></div><!-- fragment --><p> Fragment shader source: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision mediump float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec4 vertexColor;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;out vec4 fragColor;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;void main()</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    fragColor = vertexColor;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div></div><!-- fragment --><p> In the vertex shader, there is one more attribute used. You should now know how to set input data for it. There are also some uniforms used and we will now describe how to deal with them. First of all, we need to retrieve their locations.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a724f005f28bad0859794976a8f1d26bd">scalingMatrixLocation</a>     = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation  (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;scalingVector&quot;</span>));</div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#aa013d331ba0a6b237a2bda27a4463586">perspectiveMatrixLocation</a> = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation  (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;perspectiveVector&quot;</span>));</div><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23b85ad3c8005978d28ccb9f788ff67f">cameraPositionLocation</a>    = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation  (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;cameraVector&quot;</span>));</div></div><!-- fragment --><p> Please note that it is always a good idea to verify whether the returned data is valid.</p>
<div class="fragment"><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>          != -1,               <span class="stringliteral">&quot;Could not retrieve attribute location: attributePosition&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#aed770808dcdc1a6d04f7573b54811587">sphereVertexColorLocation</a> != -1,               <span class="stringliteral">&quot;Could not retrieve attribute location: attributeColor&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a724f005f28bad0859794976a8f1d26bd">scalingMatrixLocation</a>     != -1,               <span class="stringliteral">&quot;Could not retrieve uniform location: scalingMatrixLocation&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#aa013d331ba0a6b237a2bda27a4463586">perspectiveMatrixLocation</a> != -1,               <span class="stringliteral">&quot;Could not retrieve uniform location: perspectiveMatrixLocation&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23b85ad3c8005978d28ccb9f788ff67f">cameraPositionLocation</a>    != -1,               <span class="stringliteral">&quot;Could not retrieve uniform location: cameraPositionLocation&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a9807822e02fe50cdfaf908f13b600ea8">movementUniformBlockIndex</a> != GL_INVALID_INDEX, <span class="stringliteral">&quot;Could not retrieve uniform block index: BoidsUniformBlock&quot;</span>)</div></div><!-- fragment --><p> Then, if we want to set data for the uniforms, it is enough to call</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a724f005f28bad0859794976a8f1d26bd">scalingMatrixLocation</a>,     1, scalingVector));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform4fv(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#aa013d331ba0a6b237a2bda27a4463586">perspectiveMatrixLocation</a>, 1, <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae15f2f915ccf408ec586b52131ea66b4">perspectiveVector</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23b85ad3c8005978d28ccb9f788ff67f">cameraPositionLocation</a>,    1, <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a9690d9fe1a3992583597abbe5df25707">cameraVector</a>));</div></div><!-- fragment --><p> Finally, we are ready to issue the draw call. Normally, we would call</p>
<div class="fragment"><div class="line"><a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ad2ff82617f36c361a25970bcacc50baa">numberOfSphereTrianglePoints</a>));</div></div><!-- fragment --><p>However, in this case, we want to render multiple instances of the same object (30 spheres). This is why we need to call</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES,</div><div class="line">                                   0,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ad2ff82617f36c361a25970bcacc50baa">numberOfSphereTrianglePoints</a>,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>));</div></div><!-- fragment --><p> Please note that most of the functions mentioned above should be called only when the requested program object is active (<em>glUseProgram()</em> was called with an argument corresponding to the program object ID).</p>
<p>After completing all the steps described above we will get 30 spheres drawn onto the screen: 1 red and 29 green. We are ready to move them a little bit.</p>
<h1><a class="anchor" id="boidsTransformFeedback"></a>
Transform Feedback</h1>
<p>The basic concept of the application is to simulate birds' flocking behaviour. There is one leader and some followers, all of them are trying to keep distance between the others. This is the idea, but how it is implemented?</p>
<p>The leader moves on a constant trajectory. Its position is updated per each frame. The new positions for the followers are calculated based on the leader's position, but there are also the other spheres positions taken into account (so that the distance between them is not too small).</p>
<p>We will now focus on the <em>Transform Feedback</em> mechanism rather than the algorithm itself. So let's start.</p>
<p>Transform feedback is used for setting position and velocity for each of the spheres. You cannot read from and write to the same buffer object at the same time, so we use a ping-pong approach. During the first call, the pong buffer is used for reading and ping buffer for writing. During the second call, the ping buffer is used for reading and the pong buffer for writing.</p>
<p>We have already created some buffer objects (please refer to <a class="el" href="boids.html#boidsRenderGeometry">Render a Geometry</a>) and we will use them now. First of all, we will have two buffer objects, named with <em>ping</em> and <em>pong</em> prefixes. Only one of them would need to be initialized with the original data (starting positions and velocities), the second one should however be prepared to store the updated values.</p>
<p>Set up buffer objects storage.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Buffers holding coordinates of sphere positions and velocities which are used by transform feedback</span></div><div class="line"><span class="comment">     * (to read from or write computed data). */</span></div><div class="line">    <span class="comment">/* Set buffers&#39; size and usage, but do not fill them with any data. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a1f96df73fe8d202ffc09365c64cf75be">spherePingPositionAndVelocityBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a597dc0e03e327179b45443145a9a2a28">spherePositionsAndVelocitiesLength</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          NULL,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a597dc0e03e327179b45443145a9a2a28">spherePositionsAndVelocitiesLength</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          NULL,</div><div class="line">                          GL_STATIC_DRAW));</div></div><!-- fragment --><p> Fill one of buffer objects with data.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer   (GL_ARRAY_BUFFER,</div><div class="line">                             <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER,</div><div class="line">                             0,</div><div class="line">                             <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ae6a7d5345dd42d614462b47ba00b867c">startPositionAndVelocity</a>),</div><div class="line">                             <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ae6a7d5345dd42d614462b47ba00b867c">startPositionAndVelocity</a>));</div></div><!-- fragment --><p> We want to store the updated values for sphere locations in space and their velocities. Please look into the vertex shader code that is used for calculation. As you remember, a program object requires both vertex and fragment shaders to be attached. However in this situation we do not really need any fragment operations, so the <em><a class="el" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main()</a></em> function of the fragment shader is left empty. The whole algorithm is implemented in the vertex shader as shown below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const int numberOfSpheres = 30;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; * We use uniform block in order to reduce amount of memory transfers to minimum. </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; * The uniform block uses data taken directly from a buffer object. </div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;uniform inputData</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  vec4 inLocation[numberOfSpheres]; /* Current location of spheres. */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  vec4 inVelocity[numberOfSpheres]; /* Current velocity of spheres. */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;};</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;out vec4 location; /* Transformed sphere location. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;out vec4 velocity; /* Transformed sphere velocity. */</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;uniform float time; /* Time value used for determining new leader&#39;s position. */</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;/* Boids fly toward center of the mass. */</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;vec4 moveToCenter()</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;{</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    vec4 center = vec4(0.0);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    /* Calculate the center of mass for all other boids (average of their locations). */</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    for (int i = 0; i &lt; numberOfSpheres; i++)</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        if (i != gl_InstanceID)</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            center = center + inLocation[i];</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        }</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    }</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    center = center / float(numberOfSpheres - 1);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    return (center - inLocation[gl_InstanceID]) / 100.0;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;/* Boids keep their distance from other boids. */</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;vec4 keepDistanceBetweenBoids()</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    vec4 result = vec4(0.0);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    for (int i = 0; i &lt; numberOfSpheres; i++)</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    {</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        if (i != gl_InstanceID)</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            /* Compute distance between boids. */</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            float xDistance   = inLocation[i].x - inLocation[gl_InstanceID].x;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            float yDistance   = inLocation[i].y - inLocation[gl_InstanceID].y;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            float zDistance   = inLocation[i].z - inLocation[gl_InstanceID].z;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;            float xyzDistance = sqrt(xDistance * xDistance + yDistance * yDistance + zDistance * zDistance);</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            </div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            /* If distance between boids is too small, update result vector. */</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            /* Radius of sphere (which represents a single boid) is set to 10, scaling factor is set to 0.1, which means that the boids start to overlap if the distance gets below 2. </div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            * Minimum distance is set to 4 so that boids start to run away from each other if the distance between them is too low. </div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            * We use smoothstep() function to smoothen the &quot;run-away&quot;.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            */</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            if (xyzDistance &lt; 4.0)</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                result = result - (1.1 - smoothstep(0.0, 4.0, xyzDistance)) * (inLocation[i] - inLocation[gl_InstanceID]);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            }</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    </div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    return result;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;/* Boids try to match velocity with other boids. */</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;vec4 matchVelocity()</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    vec4 result = vec4(0.0);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    </div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    /* Compute average velocity of all other boids. */</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    for (int i = 0; i &lt; numberOfSpheres; i++)</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        if (i != gl_InstanceID)</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            result = result + inVelocity[i];</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    </div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    result = result / float(numberOfSpheres - 1);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    </div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    return (result - inVelocity[gl_InstanceID]) / 2.0;     </div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;/* Compute followers&#39; positions and velocities. */</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;void setFollowersPosition()</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    vec4 result1 = moveToCenter();</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    vec4 result2 = keepDistanceBetweenBoids();</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    vec4 result3 = matchVelocity();</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        </div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    velocity = inVelocity[gl_InstanceID] + result1 + result2 + result3;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    location = inLocation[gl_InstanceID] + velocity;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;}</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;/* Calculate leader&#39;s position using a certain closed curve. */ </div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;void setLeaderPosition()</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;{</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    location = vec4(15.0 * (1.0 + cos(time) - 1.0), </div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                    15.0 * sin(time), </div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                    2.0 * 15.0 * sin(time / 2.0), </div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                    1.0);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    velocity = vec4(0.0);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;}</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;void main()</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    /* Use a different approach depending on whether we are dealing with a leader or a follower. */</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    if (gl_InstanceID == 0)</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        setLeaderPosition();</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    else</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        setFollowersPosition();</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div></div><!-- fragment --><p> In the API, we need to declare the output variables that will store the results from the <em>Transform Feedback</em> operations.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> GLchar* varyingNames[] = {<span class="stringliteral">&quot;location&quot;</span>, <span class="stringliteral">&quot;velocity&quot;</span>};</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Specify varyings which are used with transform feedback buffer.</span></div><div class="line"><span class="comment">     * In shader we are using uniform block for holding location and velocity data.</span></div><div class="line"><span class="comment">     * Uniform block takes data from buffer object. Buffer object is filled with position data for each sphere first, and then with velocity data for each sphere.</span></div><div class="line"><span class="comment">     * Setting mode to GL_SEPARATE_ATTRIBS indicates that data are written to output buffer in exactly the same way as in input buffer object.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTransformFeedbackVaryings(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23d38033eeeb86fb63aa3b013481f8fb">movementProgramId</a>,</div><div class="line">                                         2,</div><div class="line">                                         varyingNames,</div><div class="line">                                         GL_SEPARATE_ATTRIBS));</div></div><!-- fragment --><p> Please note that the <em>glTransformFeedbackVaryings()</em> function has no effect unless <em>glLinkProgram()</em> is called. So please be sure that the above function is followed by</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glLinkProgram(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23d38033eeeb86fb63aa3b013481f8fb">movementProgramId</a>));</div></div><!-- fragment --><p> OK, we are prepared for the actual rendering. Before a single frame is rendered, we need to set up the proper input and output data storage (as we cannot read from and write to the same buffer object, we are using the ping-pong technique described above).</p>
<p>Set output buffer object</p>
<div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Configure transform feedback.</span></div><div class="line"><span class="comment">     * Bind buffer object to first varying (location) of GL_TRANSFORM_FEEDBACK_BUFFER - binding point index equal to 0.</span></div><div class="line"><span class="comment">     * Use the first half of the data array, 0 -&gt; sizeof(float) * 4 * numberOfSpheresToGenerate (4 floating point position coordinates per sphere).</span></div><div class="line"><span class="comment">     * Bind buffer object to first varying (velocity) of GL_TRANSFORM_FEEDBACK_BUFFER - binding point index equal to 1.</span></div><div class="line"><span class="comment">     * Use the second half of the data array, from the end of the position data until the end of the velocity data.</span></div><div class="line"><span class="comment">     * The size of the velocity data is sizeof(float) * 4 * numberOfSpheresToGenerate values (4 floating point velocity coordinates per sphere).</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * The buffer bound here is used as an output from the movement vertex shader. The output variables in the shader that are bound to this buffer are</span></div><div class="line"><span class="comment">     * given by the call to glTransformFeedbackVaryings earlier.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ac90cb7ab28055cb5c2289496346d8ce1">usePingBufferForTransformFeedbackOutput</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER,</div><div class="line">                                   0,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a1f96df73fe8d202ffc09365c64cf75be">spherePingPositionAndVelocityBufferObjectId</a>,</div><div class="line">                                   0,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER,</div><div class="line">                                   1,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a1f96df73fe8d202ffc09365c64cf75be">spherePingPositionAndVelocityBufferObjectId</a>,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * numberOfSpheresToGenerate));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER,</div><div class="line">                                   0,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a>,</div><div class="line">                                   0,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER,</div><div class="line">                                   1,</div><div class="line">                                   <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a>,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>,</div><div class="line">                                   <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4 * numberOfSpheresToGenerate));</div><div class="line">    }</div></div><!-- fragment --><p> Set input buffer object</p>
<div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * The buffer bound here is used as the input to the movement vertex shader. The data is mapped to the uniform block, and as the size of the</span></div><div class="line"><span class="comment">     * arrays inside the uniform block is known, the data is mapped to the correct variables.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ac90cb7ab28055cb5c2289496346d8ce1">usePingBufferForTransformFeedbackOutput</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferBase(GL_UNIFORM_BUFFER, 0, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af16085c4b3d67ccb0c4976d7f603a6a6">spherePongPositionAndVelocityBufferObjectId</a>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBufferBase(GL_UNIFORM_BUFFER, 0, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a1f96df73fe8d202ffc09365c64cf75be">spherePingPositionAndVelocityBufferObjectId</a>));</div><div class="line">    }</div></div><!-- fragment --><p> Please be sure that the buffer object filled with the original data is used as an input when the first frame is being rendered.</p>
<p>We are now ready to issue the transform feedback.</p>
<div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Perform the boids transformation.</span></div><div class="line"><span class="comment">     * This takes the current boid data in the buffers and passes it through the movement vertex shader.</span></div><div class="line"><span class="comment">     * This fills the output buffer with the updated location and velocity information for each boid.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_RASTERIZER_DISCARD));</div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23d38033eeeb86fb63aa3b013481f8fb">movementProgramId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBeginTransformFeedback(GL_POINTS));</div><div class="line">        {</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1f(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af90abb15e4b2cde9321a5b7a3c726fd7">timeLocation</a>, timerTime));</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArraysInstanced(GL_POINTS, 0, 1, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a6199c5c8f64654b5d0d82ac8e2517182">numberOfSpheresToGenerate</a>));</div><div class="line">        }</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEndTransformFeedback());</div><div class="line">    }</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDisable(GL_RASTERIZER_DISCARD));</div></div><!-- fragment --><p> Now we are able to use the updated data as an input for the program object responsible for rendering the spheres. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
