<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Projected Lights</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('projectedLights.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Projected Lights </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Projected Lights effect using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="projectedLightsIntroduction"></a>
Introduction</h1>
<p>This tutorial assumes that you already have basic OpenGL ES knowledge, and have read and understood the <a class="el" href="normalMapping.html">Normal Mapping</a>, <a class="el" href="lighting.html">Lighting</a> and <a class="el" href="textureCube.html">Texture Cube</a> tutorials.</p>
<h1><a class="anchor" id="projectedLightsOverview"></a>
Overview</h1>
<div class="image">
<img src="ProjectedLights.png" alt="ProjectedLights.png"/>
<div class="caption">
Projected Lights effect: the direction of the projected lights changes during rendering.</div></div>
<p> The application shows the projected lights effect. There is a spot light effect adjusted to display the texture instead of the normal light colour. There is also a shadow map technique used to make the scene more realistic by applying some shadows.</p>
<p>The projected lights effect is implemented in two basic steps, described below:</p><ul>
<li>Calculating the shadow map.<ul>
<li>The scene is rendered from spot light's point of view.</li>
<li>The result is stored in the depth texture, which is called a <em>shadow map</em>.</li>
<li>The shadow map will be used in next steps to verify whether a fragment should be lit by the spot light or should be obscured by shadow.</li>
</ul>
</li>
<li><a class="el" href="class_scene.html">Scene</a> rendering.<ul>
<li>The scene (which consists of a plane, on top of which is placed a single cube) is rendered from camera's point of view.</li>
<li>Directional lighting is implemented to accentuate the 3D scene with the perspective.</li>
<li>A spot light effect is implemented, however it is adjusted to display texture rather than a simple colour.</li>
<li>Shadows are computed for the spot lighting (the result of the first step is now used).</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="projectedLightsRenderGeometry"></a>
Render geometry</h1>
<p>In the application we are rendering a horizontally located plane, on top of which we lay a single cube. Let us now focus on the geneating the geometry that will be rendered.</p>
<div class="image">
<img src="ProjectedLightsGeometry.png" alt="ProjectedLightsGeometry.png"/>
<div class="caption">
Vertex coordinates of the geometry that will be rendered.</div></div>
<p> First of all, we need to have the coordinates of vertices that make up a cubic or plane shape. Please note that there will also be lighting applied, which means that we will need normals as well.</p>
<p>Geometry data will be stored and then used by objects that are generated with the following commands:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffer objects. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div><div class="line"></div><div class="line">    <span class="comment">/* Generate vertex array objects. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div></div><!-- fragment --><p> Geometry data is then generated and copied to specific buffer objects. For more details of how the coordinates of vertices are calculated, please refer to the implementation of those functions.</p>
<div class="fragment"><div class="line"><span class="comment">/* Please see the specification above. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a8b381d688c25708f984193fd02de4d24">setupGeometryData</a>()</div><div class="line">{</div><div class="line">    <span class="comment">/* Get triangular representation of the scene cube. Store the data in the cubeCoordinates array. */</span></div><div class="line">    CubeModel::getTriangleRepresentation(&amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                                         &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a>,</div><div class="line">                                          <a class="code" href="_projected_lights_8h.html#a81f5339488d01568b19db90e599fcddf">CUBE_SCALING_FACTOR</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate normal vectors for the scene cube created above. */</span></div><div class="line">    CubeModel::getNormals(&amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div><div class="line">                          &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Get triangular representation of a square to draw plane in XZ space. Store the data in the planeCoordinates array. */</span></div><div class="line">    PlaneModel::getTriangleRepresentation(&amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a>,</div><div class="line">                                           <a class="code" href="_projected_lights_8h.html#a65dd2111a731c31a9409b72e6808a7b8">PLANE_SCALING_FACTOR</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate normal vectors for the plane. Store the data in the planeNormals array. */</span></div><div class="line">    PlaneModel::getNormals(&amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div><div class="line">                           &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Fill buffer objects with data. */</span></div><div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the scene cubes. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of normal vectors for each vertex of the scene cubes. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the plane. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of the plane&#39;s normal vectors. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div><div class="line">                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line">}</div></div><!-- fragment --><p> In the program object, geometry vertices are referred to via the attributes, which is rather obvious.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* ATTRIBUTES */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec4 vertexCoordinates; /* Attribute: holding coordinates of triangles that make up a geometry. */</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec3 vertexNormals;     /* Attribute: holding normals. */</div></div><!-- fragment --><p> This is why we need to query for the attribute location within the program object responsible for scene rendering (note that all of the following functions need to be called for the active program object).</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;attributeVertexCoordinates            = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation   (programObjectId, <span class="stringliteral">&quot;vertexCoordinates&quot;</span>));</div><div class="line">    locationsStoragePtr-&gt;attributeVertexNormals                = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation   (programObjectId, <span class="stringliteral">&quot;vertexNormals&quot;</span>));</div></div><!-- fragment --><p> As you can see above, we are querying for the coordinates only, without specifying the cube or plane ones. This is because we are using only one program object to render both the plane and cube. Rendering specific geometry is achieved by using proper <em><a class="el" href="struct_vertex.html">Vertex</a> Attrib Arrays</em>. Let's look at how it is implemented.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Enable cube VAAs. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray        (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates,</div><div class="line">                                       NUMBER_OF_POINT_COORDINATES,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       NULL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals,</div><div class="line">                                       NUMBER_OF_POINT_COORDINATES,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       NULL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals));</div><div class="line"></div><div class="line">    <span class="comment">/* Enable plane VAAs. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray        (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates,</div><div class="line">                                       NUMBER_OF_POINT_COORDINATES,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       NULL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals,</div><div class="line">                                       NUMBER_OF_POINT_COORDINATES,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       NULL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals));</div></div><!-- fragment --><p> And now, by calling <em>glBindVertexArray()</em> with the proper parameter, we can control which object: cube or plane is going to be rendered. Please refer to:</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set cube&#39;s coordinates to be used within a program object. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div></div><!-- fragment --><div class="fragment"><div class="line">        <span class="comment">/* Set plane&#39;s coordinates to be used within a program object. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div></div><!-- fragment --><p> The final thing is to make the actual draw call, which can be achieved by:</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div><div class="line">                              0,</div><div class="line">                              <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> / NUMBER_OF_POINT_COORDINATES));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div><div class="line">                              0,</div><div class="line">                              <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> / NUMBER_OF_POINT_COORDINATES));</div></div><!-- fragment --> <h1><a class="anchor" id="projectedLightsShadowMapping"></a>
Calculate a shadow map</h1>
<p>To calculate the shadow map we need to create a depth texture, which will be used to store the results. It is achieved in some basic steps, which you should already know, but let us describe this one more time.</p>
<p>Generate texture object and bind it to the <em>GL_TEXTURE_2D</em> target.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures  (1,</div><div class="line">                            &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div><div class="line">                             <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div></div><!-- fragment --><p> Specify the texture storage data type.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage2D(GL_TEXTURE_2D,</div><div class="line">                            1,</div><div class="line">                            GL_DEPTH_COMPONENT24,</div><div class="line">                            <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ad565a89aa1202926577ed750fd655d36">shadowMapWidth</a>,</div><div class="line">                            <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a47e6b1853ab9af278d2ed320e48b6858">shadowMapHeight</a>));</div></div><!-- fragment --><p> We wanted our shadow to be more precise, this is why the depth texture resolution is bigger than normal scene size. Please refer to:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Store window size. */</span></div><div class="line">    <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a> = <a class="code" href="gl2ext_8h.html#aa352f2804b9902ac30769c00dde75d5f">height</a>;</div><div class="line">    <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>  = <a class="code" href="gl2ext_8h.html#a9a82cf3caff84cabc4598e2619faac17">width</a>;</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Calculate size of a shadow map texture that will be used. */</span></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a47e6b1853ab9af278d2ed320e48b6858">shadowMapHeight</a> = 3 * <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ad565a89aa1202926577ed750fd655d36">shadowMapWidth</a>  = 3 * <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>;</div></div><!-- fragment --><p> Set texture object parameters. The new thing here is to set <em>GL_TEXTURE_COMPARE_MODE</em> to the value of <em>GL_COMPARE_REF_TO_TEXTURE</em> which leads to r texture coordinate to be compared to the value in the currently bound depth texture.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MIN_FILTER,</div><div class="line">                             GL_LINEAR));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MAG_FILTER,</div><div class="line">                             GL_LINEAR));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_S,</div><div class="line">                             GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_T,</div><div class="line">                             GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_R,</div><div class="line">                             GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_COMPARE_FUNC,</div><div class="line">                             GL_LEQUAL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_COMPARE_MODE,</div><div class="line">                             GL_COMPARE_REF_TO_TEXTURE));</div></div><!-- fragment --><p> The next thing we have to do to implement the <em>render to texture</em> mechanism is to:</p>
<ul>
<li>Generate framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenFramebuffers     (1,</div><div class="line">                                   &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.framebufferObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindFramebuffer     (GL_FRAMEBUFFER,</div><div class="line">                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.framebufferObjectId));</div></div><!-- fragment --><ul>
<li>Bind the depth texture object to the depth attachment of the framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glFramebufferTexture2D(GL_FRAMEBUFFER,</div><div class="line">                                    GL_DEPTH_ATTACHMENT,</div><div class="line">                                    GL_TEXTURE_2D,</div><div class="line">                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId,</div><div class="line">                                    0));</div></div><!-- fragment --><p> We have to use proper <em>view-projection matrices</em> while rendering. It is important to mention here that our spot light position is constant during the rendering process, but its direction is changing, which means the point at which the spot light is directed is updated per frame.</p>
<div class="fragment"><div class="line">        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix                = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(<a class="code" href="namespace_mali_s_d_k.html#a683f8db3cdf4522a549aa6b237661df4">degreesToRadians</a>(<a class="code" href="_projected_lights_8h.html#af637b1de3e6848ae304138c3e6662b8e">LIGHT_PERSPECTIVE_FOV_IN_DEGREES</a>),</div><div class="line">                                                                                        1.0f,</div><div class="line">                                                                                        <a class="code" href="_projected_lights_8h.html#a2a63d0f9e8c8889d4fdd2b668c23c289">NEAR_PLANE</a>,</div><div class="line">                                                                                        <a class="code" href="_projected_lights_8h.html#ae69d04c4d256d9db0ff98b5c97646a80">FAR_PLANE</a>);</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/* Please see the specification above. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a9c77072116f3207d39b6316ef0619a2e">updateSpotLightDirection</a>()</div><div class="line">{</div><div class="line">    <span class="comment">/* Time used to set light direction and position. */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> currentAngle = <a class="code" href="_astc_textures_8cpp.html#aaf7e0389622e8f7b78393ee10d8e93a4">timer</a>.getTime() / 4.0f;</div><div class="line"></div><div class="line">    <span class="comment">/* Update the look at point coordinates. */</span></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.x = <a class="code" href="_projected_lights_8h.html#a9194ff982aa795cad37fb21d65415668">SPOT_LIGHT_TRANSLATION_RADIUS</a> * sinf(currentAngle);</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.y = -1.0f;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.z = <a class="code" href="_projected_lights_8h.html#a9194ff982aa795cad37fb21d65415668">SPOT_LIGHT_TRANSLATION_RADIUS</a> * cosf(currentAngle);</div><div class="line"></div><div class="line">    <span class="comment">/* Update all the view, projection matrixes athat are connected with updated look at point coordinates. */</span></div><div class="line">    Vec4f <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a5e48ac4fbc968f9840b74f973dc9fb8b">lookAtPoint</a> = {<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.x,</div><div class="line">                         <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.y,</div><div class="line">                         <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.z,</div><div class="line">                         1.0f};</div><div class="line"></div><div class="line">    <span class="comment">/* Get lookAt matrix from the light&#39;s point of view, directed at the center of a plane.</span></div><div class="line"><span class="comment">     * Store result in viewMatrixForShadowMapPass. */</span></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix = Matrix::matrixLookAt(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.position,</div><div class="line">                                                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint,</div><div class="line">                                                          <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.upVector);</div><div class="line"></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix            = <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix * <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelMatrix;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix           = <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix * <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelMatrix;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewProjectionMatrix  = <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix * <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewProjectionMatrix = <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix * <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix;</div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.spotLightLookAtPointInEyeSpace               = Matrix::vertexTransform(&amp;lookAtPoint, &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewMatrix);</div><div class="line"></div><div class="line">    Matrix inverseCameraViewMatrix       = Matrix::matrixInvert(&amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewMatrix);</div><div class="line">    <span class="comment">/* [Define colour texture translation matrix] */</span></div><div class="line">    Matrix colorTextureTranslationMatrix = Matrix::createTranslation(<a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>,</div><div class="line">                                                                     0.0f,</div><div class="line">                                                                     <a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>);</div><div class="line">    <span class="comment">/* [Define colour texture translation matrix] */</span></div><div class="line"></div><div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: colour texture] */</span></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToColorTextureMatrix = Matrix::biasMatrix                   *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div><div class="line">                                                    colorTextureTranslationMatrix        *</div><div class="line">                                                    inverseCameraViewMatrix;</div><div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: colour texture] */</span></div><div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: depth texture] */</span></div><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToDepthTextureMatrix = Matrix::biasMatrix                   *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div><div class="line">                                                    inverseCameraViewMatrix;</div><div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: depth texture] */</span></div><div class="line">}</div></div><!-- fragment --><p> There are different matrices used for rendering cube and plane form spot light point of view. Call <em>glUniformMatrix4fv()</em> to update the uniform values. </p><div class="fragment"><div class="line">            <span class="comment">/* Use matrices specific for rendering a scene from spot light perspective. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix.getAsArray()));</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewProjectionMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewProjectionMatrix.getAsArray()));</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformNormalMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.normalMatrix.getAsArray()));</div></div><!-- fragment --><div class="fragment"><div class="line">            <span class="comment">/* Use matrices specific for rendering a scene from spot light perspective. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix.getAsArray()));</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewProjectionMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewProjectionMatrix.getAsArray()));</div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformNormalMatrix,</div><div class="line">                                        1,</div><div class="line">                                        GL_FALSE,</div><div class="line">                                        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.normalMatrix.getAsArray()));</div></div><!-- fragment --><p> Owing to the fact that the shadow map texture is bigger than the normal scene (as already mentioned above), we have to remember to adjust the viewport.</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set the view port to size of shadow map texture. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glViewport(0, 0, <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ad565a89aa1202926577ed750fd655d36">shadowMapWidth</a>, <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a47e6b1853ab9af278d2ed320e48b6858">shadowMapHeight</a>));</div></div><!-- fragment --><p> Our scene is rather simple: there is only one cube placed on the top of a plane. We can introduce some optimisation here, which means the back faces will be culled. We are also setting the polygon offset to eliminate z-fighting in the shadows. Those settings are used only if enabled.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Set the Polygon offset, used when rendering the into the shadow map</span></div><div class="line"><span class="comment">     * to eliminate z-fighting in the shadows (if enabled). */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glPolygonOffset(1.0f, 0.0f));</div><div class="line">    <span class="comment">/* Set back faces to be culled (only when GL_CULL_FACE mode is enabled). */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCullFace(GL_BACK));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_POLYGON_OFFSET_FILL));</div></div><!-- fragment --><p> What we need to do is to enable depth testing. When this is enabled, the depth values will be compared and the result will be stored in the depth buffer. </p><div class="fragment"><div class="line">    <span class="comment">/* Enable depth test to do comparison of depth values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_DEPTH_TEST));</div></div><!-- fragment --><p> In this step, we want to generate the depth values only, which means we are allowed to disable writing to each framebuffer colour component.</p>
<div class="fragment"><div class="line">        <span class="comment">/* Disable writing of each frame buffer colour component. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE));</div></div><!-- fragment --><p> Finally we are ready for the actual rendering.</p>
<div class="fragment"><div class="line">        <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#ae1c4792a30e6f97a1200800f5ef6dd08">drawCubeAndPlane</a>(<span class="keyword">false</span>);</div></div><!-- fragment --><p> If we would like to use the generated depth texture data in a program object, it is enough to query for a shadow sampler uniform location and set the depth texture object as input value for this uniform.</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;uniformShadowMap                      = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation  (programObjectId, <span class="stringliteral">&quot;shadowMap&quot;</span>));</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0 + <a class="code" href="_projected_lights_8h.html#abf6d8d3afe888d4e24bf78d0e32402d3">TEXTURE_UNIT_FOR_SHADOW_MAP_TEXTURE</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div><div class="line">                             <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i       (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformShadowMap,</div><div class="line">                                <a class="code" href="_projected_lights_8h.html#abf6d8d3afe888d4e24bf78d0e32402d3">TEXTURE_UNIT_FOR_SHADOW_MAP_TEXTURE</a>));</div></div><!-- fragment --><p> More details about the program object and the scene rendering will be described in the following sections: <a class="el" href="projectedLights.html#projectedLightsGeneraeColorTexture">Generate and use colour texture</a> and <a class="el" href="projectedLights.html#projectedLightsProjectingTexture">Projecting a texture</a>.</p>
<h1><a class="anchor" id="projectedLightsGeneraeColorTexture"></a>
Generate and use colour texture</h1>
<p>There is a colour texture projected onto the scene, which is why we need to generate a texture object filled with data. This is achieved in some basic steps as described below.</p>
<div class="image">
<img src="ProjectedLightsTexture.bmp" alt="ProjectedLightsTexture.bmp"/>
<div class="caption">
Image that will be projected onto a screen.</div></div>
<p> Set active texture unit for colour texture. </p><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0 + <a class="code" href="_projected_lights_8h.html#a4ef1e331f4c66eef9de854a40986936f">TEXTURE_UNIT_FOR_COLOR_TEXTURE</a>));</div></div><!-- fragment --><p> Generate and bind texture object.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures  (1,</div><div class="line">                            &amp;<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.colorTextureObjectId));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div><div class="line">                             <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.colorTextureObjectId));</div></div><!-- fragment --><p> Load BMP image data.</p>
<div class="fragment"><div class="line">    Texture::loadBmpImageData(<a class="code" href="_projected_lights_8h.html#aa30c0728c53a13bb1aca00543e8d0a0c">COLOR_TEXTURE_NAME</a>, &amp;imageWidth, &amp;imageHeight, &amp;textureData);</div></div><!-- fragment --><p> Set texture object data.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage2D (GL_TEXTURE_2D,</div><div class="line">                             1,</div><div class="line">                             GL_RGB8,</div><div class="line">                             imageWidth,</div><div class="line">                             imageHeight));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexSubImage2D(GL_TEXTURE_2D,</div><div class="line">                             0,</div><div class="line">                             0,</div><div class="line">                             0,</div><div class="line">                             imageWidth,</div><div class="line">                             imageHeight,</div><div class="line">                             GL_RGB,</div><div class="line">                             GL_UNSIGNED_BYTE,</div><div class="line">                             textureData));</div></div><!-- fragment --><p> Set texture object parameters.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MIN_FILTER,</div><div class="line">                             GL_LINEAR));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MAG_FILTER,</div><div class="line">                             GL_LINEAR));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_R,</div><div class="line">                             GL_REPEAT));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_S,</div><div class="line">                             GL_REPEAT));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_T,</div><div class="line">                             GL_REPEAT));</div></div><!-- fragment --><p> Now, if we would like to use the texture within the program object, we need to query for the colour texture object uniform sampler location (note that following commands are called for active program object).</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;uniformColorTexture                   = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation  (programObjectId, <span class="stringliteral">&quot;colorTexture&quot;</span>));</div></div><!-- fragment --><p> Then we are ready to associate uniform sampler with texture object by calling</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i       (<a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformColorTexture,</div><div class="line">                                <a class="code" href="_projected_lights_8h.html#a4ef1e331f4c66eef9de854a40986936f">TEXTURE_UNIT_FOR_COLOR_TEXTURE</a>));</div></div><!-- fragment --> <h1><a class="anchor" id="projectedLightsProjectingTexture"></a>
Projecting a texture</h1>
<p>Finally, we are ready to describe the mechanism of projecting a texture.</p>
<p>If you follow the instructions described in the previous sections (<a class="el" href="projectedLights.html#projectedLightsRenderGeometry">Render geometry</a>, <a class="el" href="projectedLights.html#projectedLightsShadowMapping">Calculate a shadow map</a>, <a class="el" href="projectedLights.html#projectedLightsGeneraeColorTexture">Generate and use colour texture</a>) you will be ready to focus on the projected lights mechanism.</p>
<p>We are using only one program object in this tutorial. The vertex shader is rather simple (presented below). It is used for translating coordinates into eye- and NDC-space (which is the eye-space with the perspective applied).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* [Define attributes] */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;/* ATTRIBUTES */</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec4 vertexCoordinates; /* Attribute: holding coordinates of triangles that make up a geometry. */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec3 vertexNormals;     /* Attribute: holding normals. */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* [Define attributes] */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* UNIFORMS */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;uniform mat4 modelViewMatrix;           /* Model * View matrix */</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform mat4 modelViewProjectionMatrix; /* Model * View * Projection matrix */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform mat4 normalMatrix;              /* transpose(inverse(Model * View)) matrix */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;/* OUTPUTS */</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;out vec3 normalInEyeSpace; /* Normal vector for the coordinates. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;out vec4 vertexInEyeSpace; /* Vertex coordinates expressed in eye space. */</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;void main()</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;{</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    /* Calculate and set output vectors. */</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    normalInEyeSpace = mat3x3(normalMatrix) * vertexNormals;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    vertexInEyeSpace = modelViewMatrix      * vertexCoordinates;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    /* Multiply model-space coordinates by model-view-projection matrix to bring them into eye-space. */</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    gl_Position = modelViewProjectionMatrix * vertexCoordinates;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div></div><!-- fragment --><p> Please note that depth values are calculated from spot light's point of view. If we would like to use them while rendering the scene from camera's point of view, we would have to apply a translation from one space to another. Please look at the schema below.</p>
<div class="image">
<img src="ProjectedLightsMatrixSchema.png" alt="ProjectedLightsMatrixSchema.png"/>
<div class="caption">
Camera and spot light spaces schema.</div></div>
<p> Our shadow map (the texture object containing depth values) is computed in spot light's NDC space, however we would need depth values in camera eye space. To achieve that, we would take a fragment from camera eye space and translate it to spot light NDC space in order to query for its depth value. We need to calculate a matrix which will help us with that. The idea is marked at the schema with red arrows.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToDepthTextureMatrix = Matrix::biasMatrix                   *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div><div class="line">                                                    inverseCameraViewMatrix;</div></div><!-- fragment --><p> The bias matrix is used to map values from a range &lt;-1, 1&gt; (eye space coordinates) to &lt;0, 1&gt; (texture coordinates).</p>
<div class="fragment"><div class="line">    <span class="comment">/* Bias matrix. */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> Matrix::biasArray[16] =</div><div class="line">    {</div><div class="line">        0.5f, 0.0f, 0.0f, 0.0f,</div><div class="line">        0.0f, 0.5f, 0.0f, 0.0f,</div><div class="line">        0.0f, 0.0f, 0.5f, 0.0f,</div><div class="line">        0.5f, 0.5f, 0.5f, 1.0f,</div><div class="line">    };</div></div><!-- fragment --><p> Analogous mechanism need to be used for sampling the colour texture. The only difference is that we want to fit the colour texture in the view, so that the texture is smaller and repeated multiple times.</p>
<div class="fragment"><div class="line">    Matrix colorTextureTranslationMatrix = Matrix::createTranslation(<a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>,</div><div class="line">                                                                     0.0f,</div><div class="line">                                                                     <a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>);</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToColorTextureMatrix = Matrix::biasMatrix                   *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div><div class="line">                                                    <a class="code" href="tutorials_2_projected_lights_2jni_2_native_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div><div class="line">                                                    colorTextureTranslationMatrix        *</div><div class="line">                                                    inverseCameraViewMatrix;</div></div><!-- fragment --><p> In the fragment shader, we are dealing with two types of lighting:</p><ul>
<li>Directional lighting, which is implemented as presented below. We will not focus on this type of lighting here, as it should be already well known to a reader. If not, please refer to previous tutorials.</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/** \brief Get the directional lighting factor.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; *</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; *  \return As per description.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vec4 calculateLightFactor()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    vec3  normalizedNormal         = normalize(normalInEyeSpace);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    vec3  normalizedLightDirection = normalize(directionalLightPosition - vertexInEyeSpace.xyz);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    vec4  result                   = vec4(directionalLightColor, 1.0) * max(dot(normalizedNormal, normalizedLightDirection), 0.0);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    return result * directionalLightAmbient;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><ul>
<li>Spot lighting, which is the same as projected texturing and will be now explained in more details.</li>
</ul>
<p>First of all, we need to verify whether the fragment is placed inside or outside the spot light cone. This is checked by calculating the angle between the vector from light source to the fragment and vector from light source to point into which light is directed. If the anngle is bigger than the spot light angle, it means the fragment is outside the spot light cone, if smaller - inside.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/** \brief Get cosine of the angle between the current fragment and spot light direction.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; *</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; *  \return As per description.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;float getFragmentToLightCosValue()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    vec4  fragmentToLightdirection = normalize(vertexInEyeSpace - spotLightPositionInEyeSpace);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    vec4  spotLightDirection       = normalize(spotLightLookAtPointInEyeSpace- spotLightPositionInEyeSpace);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    float cosine                   = dot(spotLightDirection, fragmentToLightdirection);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    return cosine;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><p> The next step is to verify whether the fragment should be shadowed or lit by the spot light. This is done by sampling shadow map texture and comparing the result with the scene depth.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    /* Depth value retrieved from the shadow map. */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    float shadowMapDepth = textureProj(shadowMap, normalizedVertexPositionInTexture);</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    /* Depth value retrieved from drawn model. */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    float modelDepth = normalizedVertexPositionInTexture.z;</div></div><!-- fragment --><p> If the fragment is inside the light cone and not in the shadow, the projected texture colour should be applied on it.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/** \brief Get projected texture colour sampled for a specific fragment.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; *</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; *  \return As per description.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vec4 calculateProjectedTexture()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    vec3 textureCoordinates           = (viewToColorTextureMatrix * vertexInEyeSpace).xyz;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    vec3 normalizedTextureCoordinates = normalize(textureCoordinates);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    vec4 textureColor                 = textureProj(colorTexture, normalizedTextureCoordinates);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    return textureColor;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/** \brief Get the spot lighting factor.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; *  \note  Can be called only if a fragment is placed in the spot light cone.</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; *</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; *  \param fragmentToLightCosValue Cosine of the angle between the current fragment and spot light direction.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; *</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; *  \return As per description.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;vec4 calculateSpotLight(float fragmentToLightCosValue)</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    const float constantAttenuation  = 0.01;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    const float linearAttenuation    = 0.001;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    const float quadraticAttenuation = 0.0004;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    vec4        result               = vec4(0.0);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    /* Calculate the distance from a spot light source to fragment. */</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    float distance             = distance(vertexInEyeSpace.xyz, spotLightPositionInEyeSpace.xyz);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    float factor               = clamp((fragmentToLightCosValue - spotLightCosAngle), 0.0, 1.0);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    float attenuation          = 1.0 / (constantAttenuation             +</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                        linearAttenuation    * distance +</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                                        quadraticAttenuation * distance * distance);</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    vec4 projectedTextureColor = calculateProjectedTexture();</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    result = (spotLightColor * 0.5 + projectedTextureColor)* factor * attenuation;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    return result;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    /* Apply spot lighting and shadowing if needed). */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    if ((fragmentToLightCosValue &gt; spotLightCosAngle) &amp;&amp; /* If fragment is in spot light cone. */</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;         modelDepth &lt; shadowMapDepth + EPSILON)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        vec4 spotLighting = calculateSpotLight(fragmentToLightCosValue);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        color += spotLighting;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    }</div></div><!-- fragment --><p> After those operations are applied, we get the result as shown on the images below.</p>
<div class="image">
<img src="ProjectedLightsResult.png" alt="ProjectedLightsResult.png"/>
<div class="caption">
The result of the rendering: when only the directional lighting is applied (on the left) and when projected lights are applied (on the right).</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
