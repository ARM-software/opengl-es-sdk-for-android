<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Thread Synchronisation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('thread_sync.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Thread Synchronisation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Illustrates the use of sync objects to synchronise the use of shared objects between multiple contexts in multiple threads.</p>
<h1><a class="anchor" id="threadSyncIntroduction"></a>
Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>This sample uses OpenGL ES 3.0.</dd></dl>
<p>The source for this sample can be found in the folder of the SDK.</p>
<p>As we move to more complex graphics applications there will be a moment when we will want to use multithreading (MT). A typical situation is when our graphics application needs to perform intensive mathematical operations. In such a case, performance may be improved by moving the intensive workload to a separate thread, different to the one devoted to managing the graphics operations. Another common case is when we want the Graphical User Interface (GUI) to run in a separate thread.</p>
<p>The benefits from multithreading are really important. MT allows us to keep the application process responsive and it is relevant not only in connection with the application's GUI. Any device is permanently executing a lot of extra tasks in the background especially network related services. It is then critical to perform heavy tasks in a secondary thread.</p>
<p>Nowadays more embedded devices come with a multi-processor architecture. If we really want to squeeze this entire horsepower then we definitely need MT. Technologies such as hyper-threading and multi-core processors can only be effectively exploited if the processors have to manage multiple concurrent threads.</p>
<p>The threaded programming model implicitly has the need of synchronization. Every multi-threaded application needs to manage its different threads in a coordinated way. The synchronization between threads can be performed by means of standard mutexes, semaphores and condition variables available in MT libraries.</p>
<p>This sample covers the scenario where all threads are devoted to graphics operations and use multiple rendering contexts and OpenGL ES 3.0 sync objects to help achieve synchronization.</p>
<h1><a class="anchor" id="threadSyncSyncObjects"></a>
Sync Objects</h1>
<p>Multiple rendering contexts are required when an application manages more than one rendering window and when multiple threads share OpenGL ES objects. To illustrate this latter case, let's think about a hypothetical application that renders a texture which is frequently updated. The user modifies a texture which is mapped to the face of the character. We would like to update the texture in a separate thread and synchronize this action with rendering happening on the main thread.</p>
<p>In the case described above when the application manages multiple contexts and multiple threads, or data are shared between OpenGL ES and other APIs such as OpenCL, it may be necessary to determine whether commands sent to the GPU have finished yet and whether the results of those commands are ready to be used. OpenGL ES includes two instructions to force the GPU to start working on commands or to finish working on commands that have been issued so far: glFlush() and glFinish(). The first ensures that all commands issued so far are at least placed into the start of the command queue and that they will eventually be executed. The second, on the other hand, actually ensures that all commands issued have been fully executed and that the command queue is empty but this can reduce performance drastically.</p>
<p>Commonly in applications with multiple threads and contexts, it is necessary to know whether OpenGL ES has finished executing a set of commands up to a given point, especially when contexts are sharing data. This kind of synchronization is performed by special objects known as sync objects. In OpenGL ES 2.0, synchronization objects are available only by means of extensions which are not always available on all platforms and devices. See for example KHR_fence_sync <a href="#ref1">[1]</a>, ANDROID_native_fence_sync <a href="#ref2">[2]</a>, and KHR_reusable_sync <a href="#ref3">[3]</a>.</p>
<p>In OpenGL ES 3.0 sync objects are already part of the API and their use has also been simplified. The available command to create a sync object is shown below:</p>
<div class="fragment"><div class="line"><a class="code" href="gl2ext_8h.html#a00d66f29b347e37c5884fd8f3141e063">GLsync</a> glFenceSync(GLenum <a class="code" href="gl2ext_8h.html#a3fd7759b3d6e5284475eee14a613b9f9">condition</a>, GLbitfield <a class="code" href="gl2ext_8h.html#aa9459b47e7388437191d2d9a69c10d98">flags</a>);</div>
</div><!-- fragment --><p>Synchronization objects have two possible states: signaled and unsignaled. When glFenceSync creates a sync object it is in the unsignaled state. It also inserts a fence command into the OpenGL ES command stream and associates it with the sync object. This state changes to signaled when the condition of the glFenceSync command is satisfied, i.e. all commands in the command stream up to the point of the fence are complete. According to Khronos' specification, "all effects from these commands on GL client and server state and the frame buffer are fully realized".</p>
<p>To cause OpenGL ES to wait for the sync object to become signaled, there are two functions that we can use:</p>
<div class="fragment"><div class="line">GLenum glClientWaitSync(<a class="code" href="gl2ext_8h.html#a00d66f29b347e37c5884fd8f3141e063">GLsync</a> sync, GLbitfield <a class="code" href="gl2ext_8h.html#aa9459b47e7388437191d2d9a69c10d98">flags</a>, <a class="code" href="gl2ext_8h.html#a634b16061a4dad7c89bc87a58b9341e4">GLuint64</a> <a class="code" href="gl2ext_8h.html#ad29bb0d8468b264a4e3d9204366cfaab">timeout</a>);</div>
</div><!-- fragment --><p>and </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> glWaitSync(<a class="code" href="gl2ext_8h.html#a00d66f29b347e37c5884fd8f3141e063">GLsync</a> sync, GLbitfield <a class="code" href="gl2ext_8h.html#aa9459b47e7388437191d2d9a69c10d98">flags</a>, <a class="code" href="gl2ext_8h.html#a634b16061a4dad7c89bc87a58b9341e4">GLuint64</a> <a class="code" href="gl2ext_8h.html#ad29bb0d8468b264a4e3d9204366cfaab">timeout</a>);</div>
</div><!-- fragment --><p>The function glClientWaitSync blocks all CPU operations until a sync object is signaled. If the sync object does not become signaled within the timeout time, the function returns a status code to indicate so.</p>
<p>For glWaitSync, the behaviour is slightly different. Graphics commands are performed on the GPU in strict order, so when a sync object is reached in the command stream, it is guaranteed that all preceding commands have been completed.</p>
<p>The application won't actually wait for the sync object to become signaled; only the GPU will. Therefore, glWaitSync will return to the application immediately. Because the application does not wait for the function to return, there is no danger of hanging, and so the flags value must be set to zero. Also, the timeout will actually be implementation dependent and so the special timeout value GL_TIMEOUT_IGNORED is specified to make this clear. The timeout value used by your implementation can be retrieved by calling glGet with the parameter GL_MAX_SERVER_WAIT_TIMEOUT.</p>
<p>If the fence command associated with a given sync object has completed, or if no glWaitSync or glClientWaitSync commands are blocking on sync, the object is deleted immediately. Otherwise, the sync object is flagged for deletion. To delete a fence object we have created the below command is used:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> glDeleteSync(<a class="code" href="gl2ext_8h.html#a00d66f29b347e37c5884fd8f3141e063">GLsync</a> sync);</div>
</div><!-- fragment --><p>After glDeleteSync returns, the name sync is invalid and can no longer be used to refer to the sync object.</p>
<p>Finally there is a command to query the properties of a sync object:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> glGetSynciv(<a class="code" href="gl2ext_8h.html#a00d66f29b347e37c5884fd8f3141e063">GLsync</a> sync, GLenum <a class="code" href="gl2ext_8h.html#a5f3a1e186f7f277157b8f38b305ff412">pname</a>, GLsizei <a class="code" href="gl2ext_8h.html#a09918d77dec487a91825343c8cfb2b2d">bufSize</a>, GLsizei *length, GLint *<a class="code" href="gl2ext_8h.html#a875a12becbd897c8760d054b49738856">values</a>);</div>
</div><!-- fragment --><p>On success, glGetSynciv replaces up to bufSize integers in values with the corresponding property values of the object being queried (GL_OBJECT_TYPE, GL_SYNC_STATUS and GL_SYNC_CONDITION).</p>
<h1><a class="anchor" id="threadSyncTheApplication"></a>
The Application</h1>
<p>The application in our example manages two threads. The main thread is responsible for rendering a spinning cube with a texture of circles with different colours. A second thread is devoted to modifying (by animating the colours) and uploading the texture. If no fence is implemented, we would expect some kind of artefacts when the rendering is taking place at the same time the texture is being updated. To avoid this undesirable effect, two fence objects are implemented. A simple touch on the screen will switch on/off the use of the fence objects.</p>
<p>A simplified version of the rendering function is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="_anti_alias_8cpp.html#ab43690393b1c3605bbbd8f77bbe4955c">renderFrame</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    GLbitfield <a class="code" href="gl2ext_8h.html#aa9459b47e7388437191d2d9a69c10d98">flags</a> = 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#a88e6b33f16192c273e3e39d47c9019d0">useFence</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="_thread_sync_8cpp.html#a01c5ff948ac1a2b7a73fb22b11be65e6">secondThreadSyncObj</a> != NULL)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glWaitSync(<a class="code" href="_thread_sync_8cpp.html#a01c5ff948ac1a2b7a73fb22b11be65e6">secondThreadSyncObj</a>, flags, <a class="code" href="gl2ext_8h.html#ad29bb0d8468b264a4e3d9204366cfaab">timeout</a>));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Shader program. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="_anti_alias_8cpp.html#a391fd187e1c163e1bc7dc26a34c402f2">programID</a>));</div>
<div class="line"></div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Reset viewport to the EGL window surface&#39;s dimensions. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0, 0, <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>, <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Clear the screen on the EGL surface. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glClearColor(0.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 0.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 1.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>, 1.0));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Ensure the correct texture is bound to texture unit 0. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="_thread_sync_8cpp.html#ac82ec1f99d313cc2f53895d108f262f2">iCubeTex</a>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Set the sampler to point at the 0th texture unit. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i(<a class="code" href="_frame_buffer_object_8cpp.html#a6030bc8d692b29291a4fa77a95fa5f81">iLocTexture</a>, 0));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* And draw the cube. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawElements(GL_TRIANGLE_STRIP, <span class="keyword">sizeof</span>(<a class="code" href="_e_g_l_preserve_8h.html#a37b458d465031d04ddc882b21e17b0a9">cubeIndices</a>) / <span class="keyword">sizeof</span>(GLubyte), GL_UNSIGNED_BYTE, <a class="code" href="_e_g_l_preserve_8h.html#a37b458d465031d04ddc882b21e17b0a9">cubeIndices</a>));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    flags = 0;</div>
<div class="line">    GLenum <a class="code" href="gl2ext_8h.html#a3fd7759b3d6e5284475eee14a613b9f9">condition</a> = GL_SYNC_GPU_COMMANDS_COMPLETE;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * This fence creates a sync object which is signalled when the fence</span></div>
<div class="line"><span class="comment">     * command reaches the end of the graphic pipeline.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#a88e6b33f16192c273e3e39d47c9019d0">useFence</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#aaa4d7256ea53db5c78efde72664d7de3">mainThreadSyncObj</a> == NULL)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;mainThreadSynobj == NULL at the end of renderframe.&quot;</span>)</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a class="code" href="_thread_sync_8cpp.html#aaa4d7256ea53db5c78efde72664d7de3">mainThreadSyncObj</a> = glFenceSync(condition, flags);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The instruction glWaitSync at the beginning of the render function will make the GPU wait for the sync object sndThreadSyncObj, which is signalled when the texture upload is complete. In the simplified code below, you can see the secondary thread's call to glFenceSync. This command creates the sndThreadSyncObj sync object after the texture has been uploaded with glTexImage2D. The sync object sndThreadSyncObj is signalled when the GPU reaches the equivalent fence sync command in the command stream. Only then will the graphics commands sent to the GPU in the function renderFrame be executed. In this way, we guarantee that the cube will be rendered only once the texture update has finished.</p>
<div class="fragment"><div class="line"><span class="comment">/* Secondary thread&#39;s working function. */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="_thread_sync_8cpp.html#a0ed3702bf1747578689bb73dcdf6e881">workingFunction</a>(<span class="keywordtype">void</span> *arg)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Secondary thread&#39;s surface and rendering context creation. */</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Flags to pass to glFenceSync must be zero as there are no flag defined yet.</span></div>
<div class="line"><span class="comment">     * The condition must be set to GL_SYNC_GPU_COMMANDS_COMPLETE.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    GLbitfield flags = 0;</div>
<div class="line">    GLenum condition = GL_SYNC_GPU_COMMANDS_COMPLETE;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(!<a class="code" href="_thread_sync_8cpp.html#a9b0c33fb137556072b0f72b51fb7e82d">exitThread</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Set texture change frequency to 60 frames/s. */</span></div>
<div class="line">        usleep(1000000 / 60);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Change texture. */</span></div>
<div class="line">        <a class="code" href="_thread_sync_8cpp.html#a8ef5251b35d43a59b8e3948c68ced5d3">animateTexture</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#a88e6b33f16192c273e3e39d47c9019d0">useFence</a>)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="_thread_sync_8cpp.html#aaa4d7256ea53db5c78efde72664d7de3">mainThreadSyncObj</a> != NULL)</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glWaitSync(<a class="code" href="_thread_sync_8cpp.html#aaa4d7256ea53db5c78efde72664d7de3">mainThreadSyncObj</a>, flags, <a class="code" href="gl2ext_8h.html#ad29bb0d8468b264a4e3d9204366cfaab">timeout</a>));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Upload texture. */</span></div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="_thread_sync_8cpp.html#ac82ec1f99d313cc2f53895d108f262f2">iCubeTex</a>));</div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, <a class="code" href="_thread_sync_8cpp.html#a1e7382f8cd4cdf4cd43dea39dfe0d78c">texWidth</a>, <a class="code" href="_thread_sync_8cpp.html#a48364b0621048c560500bb74f2c0902f">texHeight</a>, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureData));</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* This fence create a sync object which is signalled when the fence command reaches the end of the graphic pipeline. */</span></div>
<div class="line">            <a class="code" href="_thread_sync_8cpp.html#a01c5ff948ac1a2b7a73fb22b11be65e6">secondThreadSyncObj</a> = glFenceSync(condition, flags);</div>
<div class="line"></div>
<div class="line">            EGLint error = eglGetError();</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="_thread_sync_8cpp.html#a01c5ff948ac1a2b7a73fb22b11be65e6">secondThreadSyncObj</a> == NULL || error == GL_INVALID_ENUM  || error == GL_INVALID_VALUE )</div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;glFenceSync failed at workingFunction.\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* Upload texture. */</span></div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, <a class="code" href="_thread_sync_8cpp.html#ac82ec1f99d313cc2f53895d108f262f2">iCubeTex</a>));</div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, <a class="code" href="_thread_sync_8cpp.html#a1e7382f8cd4cdf4cd43dea39dfe0d78c">texWidth</a>, <a class="code" href="_thread_sync_8cpp.html#a48364b0621048c560500bb74f2c0902f">texHeight</a>, 0, GL_RGBA, GL_UNSIGNED_BYTE, textureData));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;Exiting secondary thread.\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We must also prevent any texture changes while the frame is being rendered. This is the reason we use a second sync object called mainThreadSyncObj. This is created at the end of the renderFrame function and is used before the texture update in the secondary thread to make sure that we do not start updating the texture while the frame is being rendered.</p>
<p>As you can see, by means of sync objects we can synchronize GPU actions in a very similar way to how mutual exclusives are used to synchronize behaviour between threads.</p>
<p>The use of fencing is on by default when the application starts. Every time the user touches the screen the use of fencing is toggled on and off. The current state of fencing is displayed at the bottom of the screen. The image below shows the effect of turning fencing on and off on a Nexus 10. As you can see, artifacts can be caused when the threads are not synchronized.</p>
<div class="image">
<img src="fencing.png" alt="fencing.png"/>
<div class="caption">
Left picture: fencing on. Right picture: fencing off.</div></div>
 <h1><a class="anchor" id="threadSyncContextManagament"></a>
OpenGL ES Context Management in Multi-threaded Environment</h1>
<p>Working in OpenGL ES within a multi-threaded environment requires some minor additional work in your application. In order to work with multiple threads in OpenGL ES, we must follow these rules:</p>
<ul>
<li>Only one rendering context can be current per thread.</li>
<li>A given context can be current to only one thread.</li>
</ul>
<p>In the case of multiple threads sharing a single rendering context, we must unbind the context from the thread where it is current before making it current to any other thread. The order of operations is as follows:</p>
<ol type="1">
<li>Make the context current to thread 1:</li>
</ol>
<div class="fragment"><div class="line">eglMakeCurrent(display, surface, surface, context);</div>
</div><!-- fragment --><ol type="1">
<li>Perform OpenGL ES operations in thread 1.</li>
<li>Unbind the context from thread 1:</li>
</ol>
<div class="fragment"><div class="line">eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);</div>
</div><!-- fragment --><ol type="1">
<li>Make the context current to thread 2:</li>
</ol>
<div class="fragment"><div class="line">eglMakeCurrent(display, surface, surface, context);</div>
</div><!-- fragment --><ol type="1">
<li>Perform OpenGL ES operations in thread 2.</li>
</ol>
<p>This sample focuses on a different situation; each thread has its own rendering context and as the contexts are different both can be current at the same time. Creating a separate rendering context per thread has clear advantages. Firstly, we do not need to worry about unbinding and binding from one thread to another the only existing rendering context which is a common cause of application hanging. Secondly, which is more important we do not harm the performance as we can keep the command queue fed uninterruptedly. Every time the rendering context is unbound from a thread this thread can't perform any graphics operation. This kind of context switching can degrade the application performance especially if it takes place very frequently.</p>
<p>In our main application thread, the rendering context is created and initialized in the MaliSamplesView class in <a class="el" href="_mali_samples_view_8java.html">MaliSamplesView.java</a> file. We are using the OpenGL ES APIs provided by the Android framework.</p>
<p>A second thread is created during the main thread graphics set up by calling the function <a class="el" href="_thread_sync_8cpp.html#a64cad4cd67afd58d95914f50ca546f3a">createTextureThread()</a>. At the beginning of the new thread's working function a new pixel buffer surface and rendering context are created as shown below.</p>
<div class="fragment"><div class="line">    EGLConfig config = <a class="code" href="_thread_sync_8h.html#a82799781691845ef6782fda5dc5200aa">findConfig</a>(<a class="code" href="_thread_sync_8cpp.html#a89ad3412cc14f8ace50d7beada7b70e2">mainDisplay</a>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line">    <a class="code" href="_thread_sync_8cpp.html#acca1576baab9744a76e5a14bb386caf5">pBufferSurface</a> = eglCreatePbufferSurface(<a class="code" href="_thread_sync_8cpp.html#a89ad3412cc14f8ace50d7beada7b70e2">mainDisplay</a>, config, <a class="code" href="_thread_sync_8h.html#a11226333c02bd09cce2cea67cb333319">pBufferAttributes</a>);</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#acca1576baab9744a76e5a14bb386caf5">pBufferSurface</a> == EGL_NO_SURFACE)</div>
<div class="line">    {</div>
<div class="line">        EGLint error = eglGetError();</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;eglGetError(): %i (0x%.4x)\n&quot;</span>, (<span class="keywordtype">int</span>)error, (<span class="keywordtype">int</span>)error);</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Failed to create EGL pixel buffer surface at %s:%i\n&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;PBuffer surface created successfully.\n&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Unconditionally bind to OpenGL ES API. */</span></div>
<div class="line">    eglBindAPI(EGL_OPENGL_ES_API);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* [Creating rendering context] */</span></div>
<div class="line">    <span class="comment">/* Sharing OpenGL ES objects with main thread&#39;s rendering context. */</span></div>
<div class="line">    <a class="code" href="_thread_sync_8cpp.html#a50bea9afd4f6f6688c4476fc4199c7d5">pBufferContext</a> = eglCreateContext(<a class="code" href="_thread_sync_8cpp.html#a89ad3412cc14f8ace50d7beada7b70e2">mainDisplay</a>, config, <a class="code" href="_thread_sync_8cpp.html#a02d6df1da831e4ba479e4c483f4e4cd4">mainContext</a>, <a class="code" href="_thread_sync_8h.html#a2805a4dd9c88b22f2060fd1063267fe4">contextAttributes</a>);</div>
<div class="line">    <span class="comment">/* [Creating rendering context] */</span></div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_thread_sync_8cpp.html#a50bea9afd4f6f6688c4476fc4199c7d5">pBufferContext</a> == EGL_NO_CONTEXT)</div>
<div class="line">    {</div>
<div class="line">        EGLint error = eglGetError();</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;eglGetError(): %i (0x%.4x)\n&quot;</span>, (<span class="keywordtype">int</span>)error, (<span class="keywordtype">int</span>)error);</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Failed to create EGL pBufferContext at %s:%i\n&quot;</span>, __FILE__, __LINE__);</div>
<div class="line">        exit(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;PBuffer context created successfully sharing GLES objects with the main context.\n&quot;</span>);</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(eglMakeCurrent(<a class="code" href="_thread_sync_8cpp.html#a89ad3412cc14f8ace50d7beada7b70e2">mainDisplay</a>, <a class="code" href="_thread_sync_8cpp.html#acca1576baab9744a76e5a14bb386caf5">pBufferSurface</a>, <a class="code" href="_thread_sync_8cpp.html#acca1576baab9744a76e5a14bb386caf5">pBufferSurface</a>, <a class="code" href="_thread_sync_8cpp.html#a50bea9afd4f6f6688c4476fc4199c7d5">pBufferContext</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5512e59d578a380a441a70256af997d0">LOGI</a>(<span class="stringliteral">&quot;PBuffer context made current successfully.\n&quot;</span>);</div>
</div><!-- fragment --><p> In the secondary thread we do not perform any drawing operation on a window surface so we create a small off-screen pixel buffer surface. If you are working with an off-screen surface you can experience problems in creating it. In this case the recommended procedure is to start from a minimal set of attributes, for example indicating only the width and height, and once you get a valid surface you can try to add more attributes. During this procedure it is better to try first with values that are power of 2 as according to the OpenGL ES 3.0 specification "if the underlying OpenGL ES implementation does not support non-power-of-two textures, both the width and height will be a power of 2". In our case the ARM Mali-T600 Series of GPUs supports non-power-of-two values of PBuffer's width and height.</p>
<div class="fragment"><div class="line">EGLint <a class="code" href="_thread_sync_8h.html#a11226333c02bd09cce2cea67cb333319">pBufferAttributes</a>[] =</div>
<div class="line">{</div>
<div class="line">    EGL_WIDTH, 2,</div>
<div class="line">    EGL_HEIGHT, 2,</div>
<div class="line">    EGL_TEXTURE_FORMAT, EGL_TEXTURE_RGBA,</div>
<div class="line">    EGL_TEXTURE_TARGET, EGL_TEXTURE_2D,</div>
<div class="line">    EGL_NONE</div>
<div class="line">};</div>
</div><!-- fragment --><p> Once a valid surface is created the next step is to create the rendering context. </p>
<div class="fragment"><div class="line">    <span class="comment">/* Sharing OpenGL ES objects with main thread&#39;s rendering context. */</span></div>
<div class="line">    <a class="code" href="_thread_sync_8cpp.html#a50bea9afd4f6f6688c4476fc4199c7d5">pBufferContext</a> = eglCreateContext(<a class="code" href="_thread_sync_8cpp.html#a89ad3412cc14f8ace50d7beada7b70e2">mainDisplay</a>, config, <a class="code" href="_thread_sync_8cpp.html#a02d6df1da831e4ba479e4c483f4e4cd4">mainContext</a>, <a class="code" href="_thread_sync_8h.html#a2805a4dd9c88b22f2060fd1063267fe4">contextAttributes</a>);</div>
</div><!-- fragment --><p> The third parameter passed to eglCreateContext is the rendering context of the main thread. It means that the rendering context of the secondary thread will share OpenGL ES objects with the rendering context of the main thread. In our application, both threads are sharing the texture object.</p>
<h1><a class="anchor" id="threadSyncConclusions"></a>
Conclusions</h1>
<p>OpenGL ES rendering commands are assumed to be asynchronous. If any drawing operation is invoked there is not any guarantee that the rendering has finished by the time the call returns. Very often there is a need of synchronizing CPU-GPU or GPU-GPU actions in a MT environment. OpenGL ES provides an explicit synchronization mechanism with the glFinish() and glFlush() commands. However, these should be used with care as they can hurt performance. Some other functions implicitly force synchronization. Nevertheless, in some cases, and especially in the MT environment, there is a need to perform the kind of synchronization that OpenGL ES itself does implicitly, i.e. to sync to a specific point in the command stream. This is the purpose of the fence objects which are explained in this tutorial. Additionally the sample illustrates how to work with multiple contexts in a MT application.</p>
<h1><a class="anchor" id="threadSyncReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://www.khronos.org/registry/vg/extensions/KHR/EGL_KHR_fence_sync.txt">http://www.khronos.org/registry/vg/extensions/KHR/EGL_KHR_fence_sync.txt</a></p>
<p><a class="anchor" id="ref2"></a>[2] <a href="http://www.khronos.org/registry/egl/extensions/ANDROID/EGL_ANDROID_native_fence_sync.txt">http://www.khronos.org/registry/egl/extensions/ANDROID/EGL_ANDROID_native_fence_sync.txt</a></p>
<p><a class="anchor" id="ref3"></a>[3] <a href="http://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_reusable_sync.txt">http://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_reusable_sync.txt</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
