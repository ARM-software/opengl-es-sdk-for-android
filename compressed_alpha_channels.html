<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Texture Compression and Alpha Channels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('compressed_alpha_channels.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Texture Compression and Alpha Channels </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the related samples "ETCAtlasAlpha", "ETCCompressedAlpha", and "ETCUncompressedAlpha", which illustrate three different ways of handling alpha channels when using ETC1 compression.</p>
<h1><a class="anchor" id="compressedAlphaChannelsIntroduction"></a>
Introduction</h1>
<p>The source for this sample can be found in the folders of the SDK.</p>
<p>This document is a guide to getting the most out of your partially transparent texture maps when developing software for the Mali GPU, by using hardware texture compression.</p>
<h1><a class="anchor" id="compressedAlphaChannelsWhy"></a>
Why use texture compression?</h1>
<p>Just as the compression on a JPEG image allows more images to fit on a disk, texture compression allows more textures to fit inside graphics hardware, which on mobile platforms is particularly important. The Mali GPU has built in hardware texture decompression, allowing the texture to remain compressed in graphics hardware and decompress the required samples on the fly. On the Mali Developer site there is a texture compression tool for compressing textures into the format recognised by the Mali GPU, the Ericsson Texture Compression format.</p>
<h1><a class="anchor" id="compressedAlphaChannelsETC1Standard"></a>
The ETC1 standard</h1>
<p>Ericsson Texture Compression version 1 or ETC1 is an open standard supported by Khronos and widely used on mobile platforms. It is a lossy algorithm designed for perceptive quality, based on the fact that the human eye is more responsive to changes in luminance than chrominance.</p>
<p>One minor problem with this standard however is that textures compressed in the ETC1 format lose any alpha channel information, and can have no transparent areas. As there are quite a few clever things that can be done using alpha channels in textures, this has led many developers to use other texture compression algorithms, many of which are proprietary formats with limited hardware support.</p>
<p>This document and associated code samples show several methods of getting transparency into textures compressed with the ETC1 standard.</p>
<h1><a class="anchor" id="compressedAlphaChannelsBasics"></a>
The Basics</h1>
<p>The Mali Developer code samples already contain an example of loading an ETC1 texture and associated prescaled mipmaps, so for clarity the snippets for these methods, and the full examples provided to illustrate a full implementation, are based on that simple ETC1 loading example.</p>
<h1><a class="anchor" id="compressedAlphaChannelsExtractingAlpha"></a>
Extracting the alpha channel</h1>
<p>The first step in any of these methods is extracting the alpha channel from your textures. Since the alpha channel is not packed in the compressed texture, it has to be delivered alongside it. The alpha channel can be extracted with most graphics programs, but since performing that task would be quite arduous this functionality is integrated into the ARM Mali Texture Compression Tool (from version 3.0). Whether, and how, the alpha channel is extracted may be selected by choosing an Alpha handling option the Compression Options dialog. This is shown in Figure 1.</p>
<div class="image">
<img src="tct_compression_options.png" alt="tct_compression_options.png"/>
<div class="caption">
Figure 1 Alpha handling options in the Texture Compression Tool</div></div>
<p> The Texture Compression Command Line Tool also supports extracting the alpha channel. For full information about using these options see the Texture Compression Tool User Guide.</p>
<h1><a class="anchor" id="compressedAlphaChannelsTextureAtlas"></a>
Method 1: Texture Atlas</h1>
<h2><a class="anchor" id="compressedAlphaChannelsTextureAtlasSum"></a>
Summary</h2>
<p>The alpha channel is converted to a visible greyscale image, which is then concatenated onto the original texture, making the texture graphic taller.</p>
<div class="image">
<img src="Method1TextureAtlas.png" alt="Method1TextureAtlas.png"/>
</div>
<h2><a class="anchor" id="compressedAlphaChannelsTextureAtlasBenefits"></a>
Benefits</h2>
<ul>
<li>Still only one file (minimal changes to texture loading procedure)</li>
<li>Only change to code needed is scaling in the shader code</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsTextureAtlasDrawbacks"></a>
Drawbacks</h2>
<ul>
<li>Texture samples will only wrap properly in one direction.</li>
<li>Scaling slows down shader execution.</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsTextureAtlasMethod"></a>
Method</h2>
<p>To create compressed images suitable for use with this method select "Create atlas" in the Texture Compression Tool.</p>
<p>The sample "ETCAtlasAlpha" reads an image using this method.</p>
<p>This is the easiest method to implement as when the texture atlas image has been compressed, the only change required in your code is a remapping of texture coordinates in the shader, such that:</p>
<div class="fragment"><div class="line">gl_FragColor = texture2D(u_s2dTexture, v_v2TexCoord);</div>
</div><!-- fragment --><p>Becomes:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> colour = texture2D(u_s2dTexture, v_v2TexCoord * <a class="code" href="structvec2.html">vec2</a>(1.0, 0.5));</div>
<div class="line">colour.a = texture2D(u_s2dTexture,</div>
<div class="line">v_v2TexCoord * <a class="code" href="structvec2.html">vec2</a>(1.0, 0.5) + v_v2TexCoord * <a class="code" href="structvec2.html">vec2</a>(0.0, 0.5)).r;</div>
<div class="line">gl_FragColor = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
</div><!-- fragment --><p>This scales texture coordinates to use the top half and then shifts that down to the bottom half of the image for a second sample where the alpha channel is. This example uses the red channel of the image mask to set the alpha channel.</p>
<p>More practically, you could instead add a second varying value to your vertex shader.</p>
<p>Making your vertex shader look like this:</p>
<div class="fragment"><div class="line">attribute <a class="code" href="structvec4.html">vec4</a> a_v4Position;</div>
<div class="line">attribute <a class="code" href="structvec2.html">vec2</a> a_v2TexCoord;</div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> v_v2TexCoord;</div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> v_v2AlphaCoord;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    v_v2TexCoord = a_v2TexCoord * <a class="code" href="structvec2.html">vec2</a>(1.0, 0.5);</div>
<div class="line">    v_v2AlphaCoord = v_v2TexCoord + <a class="code" href="structvec2.html">vec2</a>(0.0, 0.5);</div>
<div class="line">    gl_Position = a_v4Position;</div>
<div class="line">}</div>
</div><!-- fragment --><p>And your fragment shader can then use the two varying coordinates:</p>
<div class="fragment"><div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D u_s2dTexture;</div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> v_v2TexCoord;</div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> v_v2AlphaCoord;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> colour = texture2D(u_s2dTexture, v_v2TexCoord);</div>
<div class="line">    colour.a = texture2D(u_s2dTexture, v_v2AlphaCoord).r;</div>
<div class="line">    gl_FragColor = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This uses a little more bandwidth for the extra varying <a class="el" href="structvec2.html">vec2</a>, but makes better use of pipelining, particularly as most developers tend to do more work in their fragment shaders than their vertex shaders. With these minor changes most applications should run just fine with the texture atlas files.</p>
<p>However, there are cases when you might want to maintain the ability to wrap a texture over a large area. For that there are the other two methods, discussed below.</p>
<h1><a class="anchor" id="compressedAlphaChannelsSeparatelyAlpha"></a>
Method 2: Separately Packed Alpha</h1>
<h2><a class="anchor" id="compressedAlphaChannelsSeparatelyAlphaSum"></a>
Summary</h2>
<p>The alpha channel is delivered as a second packed texture, both textures are then combined in the shader code.</p>
<div class="image">
<img src="Method2SeparatelyPackedAlpha.png" alt="Method2SeparatelyPackedAlpha.png"/>
</div>
<h2><a class="anchor" id="compressedAlphaChannelsSeparatelyAlphaBenefits"></a>
Benefits</h2>
<ul>
<li>More flexible, allows alpha/colour channels to be mixed and matched</li>
<li>Allows for texture wrapping in both directions</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsSeparatelyAlphaDrawbacks"></a>
Drawbacks</h2>
<ul>
<li>Requires a second texture sampler in the shader.</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsSeparatelyAlphaMethod"></a>
Method</h2>
<p>To create compressed images suitable for use with this method select "Create separate compressed image" in the Texture Compression Tool.</p>
<p>The sample "ETCCompressedAlpha" reads an image using this method.</p>
<p>When loading the second texture be sure to call <code>glActiveTexture(GL_TEXTURE1)</code> before <code>glBindTexture</code> and <code>glCompressedTexImage2D</code> in order to ensure that the alpha channel is allocated in a different hardware texture slot.</p>
<div class="fragment"><div class="line">glActiveTexture(GL_TEXTURE0);</div>
<div class="line">loadCompressedMipmaps(TEXTURE_FILE, TEXTURE_FILE_SUFFIX, &amp;iTexName);</div>
<div class="line">glActiveTexture(GL_TEXTURE1);</div>
<div class="line">loadCompressedMipmaps(ALPHA_FILE, TEXTURE_FILE_SUFFIX, &amp;iAlphaName);</div>
</div><!-- fragment --><p>When setting your shader uniform variables, you will need to allocate a second texture sampler and bind it to the second texture unit:</p>
<div class="fragment"><div class="line"><a class="code" href="_e_t_c_atlas_alpha_8cpp.html#aa065ff467ac57cf594bcd3439dbd3d6e">iLocSampler</a> = glGetUniformLocation(iProgName, <span class="stringliteral">&quot;u_s2dTexture&quot;</span>);</div>
<div class="line">glUniform1i(<a class="code" href="_e_t_c_atlas_alpha_8cpp.html#aa065ff467ac57cf594bcd3439dbd3d6e">iLocSampler</a>, 0);</div>
<div class="line">iLocSamplerAlpha = glGetUniformLocation(iProgName, <span class="stringliteral">&quot;u_s2dAlpha&quot;</span>);</div>
<div class="line">glUniform1i(iLocSamplerAlpha, 1);</div>
</div><!-- fragment --><p>Then inside your fragment shader, once again merge the two samples, this time from different textures:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> colour = texture2D(u_s2dTexture, v_v2TexCoord);</div>
<div class="line">colour.a = texture2D(u_s2dAlpha, v_v2TexCoord).r;</div>
<div class="line">gl_FragColor = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
</div><!-- fragment --><h1><a class="anchor" id="compressedAlphaChannelsSeparateRawAlpha"></a>
Method 3: Separate Raw Alpha</h1>
<h2><a class="anchor" id="compressedAlphaChannelsSeparateRawAlphaSum"></a>
Summary</h2>
<p>The alpha channel is provided as a raw 8 bit single-channel image, combined with the texture data in the shader.</p>
<div class="image">
<img src="Method3SeparateRawAlpha.png" alt="Method3SeparateRawAlpha.png"/>
</div>
<h2><a class="anchor" id="compressedAlphaChannelsSeparateRawAlphaBenefits"></a>
Benefits</h2>
<ul>
<li>More flexible, allows alpha/colour information to be mixed and matched.</li>
<li>Allows uncompressed alpha, in case lossy ETC1 compression caused artefacts.</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsSeparateRawAlphaDrawbacks"></a>
Drawbacks</h2>
<ul>
<li>Requires a second texture sampler in the shader.</li>
<li>Uncompressed alpha takes up more space than compressed (although still far less than an uncompressed RGBA texture).</li>
</ul>
<h2><a class="anchor" id="compressedAlphaChannelsSeparateRawAlphaMethod"></a>
Method</h2>
<p>To create compressed images suitable for use with this method select "Create separate compressed image" in the Texture Compression Tool.</p>
<p>Depending what other options are selected this will produce either single a PGM file, or a PGM file for each mipmap level, or a single KTX file containing all mipmap levels as uncompressed data. PGM format is described in <a href="http://netpbm.sourceforge.net/doc/pgm.html">http://netpbm.sourceforge.net/doc/pgm.html</a>. KTX format is described in <a href="http://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/">http://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/</a>.</p>
<p>You will need to implement a new method to load and bind this texture, but given the uncompressed nature of the texture loading is fairly trivial:</p>
<p>The sample "ETCCompressedAlpha" reads an image using this method.</p>
<div class="fragment"><div class="line">FILE *pFile = NULL;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pTexData = NULL;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iWidth = 0;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iHeight = 0;</div>
<div class="line"><span class="keywordtype">size_t</span> result = 0;</div>
<div class="line">pFile = fopen(pFilename, <span class="stringliteral">&quot;rb&quot;</span>);</div>
<div class="line"><span class="comment">// Read the header. The header is text. Fields are magic number, width, height,</span></div>
<div class="line"><span class="comment">// maximum gray value.</span></div>
<div class="line"><span class="comment">// See http://netpbm.sourceforge.net/doc/pgm.html for format details.</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iRange = 0;</div>
<div class="line"><span class="keywordtype">int</span> iReadCount = fscanf(pFile, <span class="stringliteral">&quot;P5 %d %d %d&quot;</span>, &amp;iWidth, &amp;iHeight, &amp;iRange);</div>
<div class="line"><span class="keywordflow">if</span>(iReadCount != 3) {</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Error reading file header of %s&quot;</span>, pFilename);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(iRange != 255) {</div>
<div class="line">    <span class="comment">// We can only handle a maximum gray/alpha value of 255, as generated by</span></div>
<div class="line">    <span class="comment">// the Texture Compression Tool</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Alpha file %s has wrong maximum gray value, must be 255&quot;</span>, pFilename);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Read and thow away the single header terminating character</span></div>
<div class="line">fgetc(pFile);</div>
<div class="line">pTexData = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)calloc(iWidth * iHeight, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));</div>
<div class="line">result = fread(pTexData, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), iWidth * iHeight, pFile);</div>
<div class="line"><span class="keywordflow">if</span> (result != iWidth * iHeight)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Error reading %s&quot;</span>, pFilename);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, pTexName));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(GL_TEXTURE_2D, *pTexName));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, iWidth, iHeight,</div>
<div class="line">0,GL_LUMINANCE,GL_UNSIGNED_BYTE, pTexData ));</div>
<div class="line"><a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenerateMipmap(GL_TEXTURE_2D));</div>
<div class="line">free(pTexData);</div>
</div><!-- fragment --><p>Allowing the textures to be loaded into separate active textures like before:</p>
<div class="fragment"><div class="line">glActiveTexture(GL_TEXTURE0);</div>
<div class="line">loadCompressedMipmaps(TEXTURE_FILE, TEXTURE_FILE_SUFFIX, &amp;iTexName);</div>
<div class="line">glActiveTexture(GL_TEXTURE1);</div>
<div class="line">loadRawLuminance(ALPHA_FILE, &amp;iAlphaName);</div>
</div><!-- fragment --><p>And once again loading them separately into the fragment shader:</p>
<div class="fragment"><div class="line"><a class="code" href="_e_t_c_atlas_alpha_8cpp.html#aa065ff467ac57cf594bcd3439dbd3d6e">iLocSampler</a> = glGetUniformLocation(iProgName, <span class="stringliteral">&quot;u_s2dTexture&quot;</span>);</div>
<div class="line">glUniform1i(<a class="code" href="_e_t_c_atlas_alpha_8cpp.html#aa065ff467ac57cf594bcd3439dbd3d6e">iLocSampler</a>, 0);</div>
<div class="line">iLocSamplerAlpha = glGetUniformLocation(iProgName, <span class="stringliteral">&quot;u_s2dAlpha&quot;</span>);</div>
<div class="line">glUniform1i(iLocSamplerAlpha, 1);</div>
</div><!-- fragment --><p>Then inside your fragment shader merge the two samples, again from the two different textures:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> colour = texture2D(u_s2dTexture, v_v2TexCoord);</div>
<div class="line">colour.a = texture2D(u_s2dAlpha, v_v2TexCoord).r;</div>
<div class="line">gl_FragColor = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
