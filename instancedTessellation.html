<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Instanced Tessellation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('instancedTessellation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Instanced Tessellation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The application displays a rotating solid torus with a low-polygon wireframed mesh surrounding it. The torus is drawn by means of instanced tessellation technique using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="instancedTessellationIntro"></a>
Introduction</h1>
<p>It's assumed that you have read and understood all of the mechanisms described in <a class="el" href="assetLoading.html">Asset Loading</a>,<a class="el" href="simpleTriangle.html">Simple Triangle</a> and <a class="el" href="textureCube.html">Texture Cube</a>.</p>
<h1><a class="anchor" id="instancedTessellationOverview"></a>
Overview</h1>
<div class="image">
<img src="InstancedTessellation_android.png" alt="InstancedTessellation_android.png"/>
<div class="caption">
The application displays a rotating solid torus with a low-polygon wireframed mesh surrounding it.</div></div>
<p> To perform instanced tessellation, we need to divide our model into several patches. Each patch is densely packed with triangles and improves the effect of round surfaces. In the first stage of tessellation, patches consist of vertices placed in a form of a square. Once passed to the shader, they are transformed into Bezier surfaces on the basis of control points stored in uniform blocks. Each instance of a draw call renders next part of the torus.</p>
<p>The following application instantiates two classes, these manage both the solid torus model and the wireframe that surrounds it. The first class is responsible for configuration of a program with shaders capable of instanced drawing, initialization of data buffers and handling instanced draw calls. To simplify the mathematics and satisfy conditions for C1 continuity between patches, we assume that torus is constructed by 12 circles, each also defined by 12 points. In that manner, we are able to divide "big" and "small" circle of torus into four quadrants and build Bezier surfaces that approximate perfectly round shapes. For that purpose, the control points cannot lay on the surface of the torus, but have to be distorted as appropriate.</p>
<p>The second class manages components corresponding to the wireframe. It uses vertices placed on the surface of torus and uses a simple draw call with GL_LINES mode. The size of its "small circle" is slightly bigger than the corresponding dimension of the solid torus, so there is a space between both the models.</p>
<p>Common elements for both classes are placed in an abstract <a class="el" href="class_torus.html" title="Abstract class that draws torus on the screen. It stores generic data describing the drawn torus: ...">Torus</a> class.</p>
<h1><a class="anchor" id="instancedTessellationSetupGraphics"></a>
Setup Graphics</h1>
<p>First of all, we need to generate coordinates of the model that we will render. This is achieved in constructors of <em><a class="el" href="class_wireframe_torus.html" title="Class derived from the Torus abstract class. It manages drawing of a rotating wireframed unicolor tor...">WireframeTorus</a></em> and <em><a class="el" href="class_instanced_solid_torus.html" title="Class derived form Torus abstract class. It manages drawing of a rotating solid torus, built from separate patches. Each patch is modelled as a Bezier surface approximating surface of a perfect torus. To satisfy the C1 continuity between neighbour patches, the number of circles creating the torus and also the number of points in each circle is restricted to 12. It allows us to divide both circles of torus (&quot;big&quot; and &quot;small&quot;) into 4 quadrants and approximate each of it using bicubic Bezier curves. Control mesh vertices has to be distored, so the derivatives on the patch edges are equal and resulting image is round. That is why we cannot use the regular way to determine control points. The patches are in fact very dense square-shaped meshes, used as input attributes by vertex shader. The shader changes their shape on the basis of the distorted control mesh and places them next to each other, forming a round torus. The class, apart from inherited components, manages: ">InstancedSolidTorus</a></em> classes.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_instanced_tessellation_2jni_2_native_8cpp.html#ad7286281f5506d5a0d1b005d945ba86c">wireframeTorus</a> = <span class="keyword">new</span> <a class="code" href="class_wireframe_torus.html">WireframeTorus</a>(torusRadius, circleRadius + distance);</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="tutorials_2_instanced_tessellation_2jni_2_native_8cpp.html#a734b0346b7557c8d45e38bc3a09bfef7">solidTorus</a>     = <span class="keyword">new</span> <a class="code" href="class_instanced_solid_torus.html">InstancedSolidTorus</a>(torusRadius, circleRadius);</div></div><!-- fragment --><p> Please note that we wanted the wireframe object to be a little bit larger than the solid one, this is why the <em>circleRadius</em> is increased by <em>distance</em>. Thanks to that we will see a solid object which is surrounded by the wireframe object.</p>
<p>The coordinates are generated in the same way for both models as shown below</p>
<div class="fragment"><div class="line">    <span class="keywordtype">void</span> TorusModel::generateVertices(<span class="keywordtype">float</span> torusRadius, <span class="keywordtype">float</span> circleRadius, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> circlesCount, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pointsPerCircleCount, <span class="keywordtype">float</span>* <a class="code" href="_cube_8h.html#aebc90711c5df16dd4e6faa8b261cd828">vertices</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (vertices == NULL)</div><div class="line">        {</div><div class="line">            <a class="code" href="_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Cannot use null pointer while calculating torus vertices.&quot;</span>);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Index variable. */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> componentIndex = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> horizontalIndex = 0; horizontalIndex &lt; circlesCount; ++horizontalIndex)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Angle in radians on XZ plane. */</span></div><div class="line">            <span class="keywordtype">float</span> xyAngle = (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>) horizontalIndex * 2.0f * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / circlesCount;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verticalIndex = 0; verticalIndex &lt; pointsPerCircleCount; ++verticalIndex)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Angle in radians on XY plane. */</span></div><div class="line">                <span class="keywordtype">float</span> theta  = (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>) verticalIndex * 2.0f * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a> / pointsPerCircleCount;</div><div class="line"></div><div class="line">                <span class="comment">/* X coordinate. */</span></div><div class="line">                vertices[componentIndex++] = (torusRadius + circleRadius * cosf(theta)) * cosf(xyAngle);</div><div class="line">                <span class="comment">/* Y coordinate. */</span></div><div class="line">                vertices[componentIndex++] = circleRadius * sinf(theta);</div><div class="line">                <span class="comment">/* Z coordinate. */</span></div><div class="line">                vertices[componentIndex++] = (torusRadius + circleRadius * cosf(theta)) * sinf(xyAngle);</div><div class="line">                <span class="comment">/* W coordinate. */</span></div><div class="line">                vertices[componentIndex++] = 1.0f;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> There are separate program objects that are used while rendering a requested model. There is no lighting applied on the wireframe model nor complicated vertex translations which makes things much easier. Please look at the shaders that are used while rendering the wireframe model.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader source for the wireframe torus</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Input vertex coordinates. */ </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec4 position;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;/* Constant transformation matrices. */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;uniform mat4 cameraMatrix;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;uniform mat4 projectionMatrix;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;uniform mat4 scaleMatrix;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;/* Coefficients of rotation needed for configuration of rotation matrix. */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform vec3 rotationVector;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;void main()</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;{</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    mat4 modelViewMatrix;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    mat4 modelViewProjectionMatrix;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    </div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    /* Matrix rotating Model-View matrix around X axis. */</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    mat4 xRotationMatrix = mat4(1.0,  0.0,                            0.0,                            0.0, </div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                0.0,  cos(radians(rotationVector.x)), sin(radians(rotationVector.x)), 0.0, </div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;                                0.0, -sin(radians(rotationVector.x)), cos(radians(rotationVector.x)), 0.0, </div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                                0.0,  0.0,                            0.0,                            1.0);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    /* Matrix rotating Model-View matrix around Y axis. */</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    mat4 yRotationMatrix = mat4( cos(radians(rotationVector.y)), 0.0, -sin(radians(rotationVector.y)), 0.0, </div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                 0.0,                            1.0,  0.0,                            0.0, </div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                 sin(radians(rotationVector.y)), 0.0,  cos(radians(rotationVector.y)), 0.0, </div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;                                 0.0,                            0.0,  0.0,                            1.0);</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    </div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    /* Matrix rotating Model-View matrix around Z axis. */</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    mat4 zRotationMatrix = mat4( cos(radians(rotationVector.z)), sin(radians(rotationVector.z)), 0.0, 0.0, </div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                -sin(radians(rotationVector.z)), cos(radians(rotationVector.z)), 0.0, 0.0, </div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                 0.0,                            0.0,                            1.0, 0.0, </div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                 0.0,                            0.0,                            0.0, 1.0);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    /* Model-View matrix transformations. */</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    modelViewMatrix = scaleMatrix;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    modelViewMatrix = xRotationMatrix  * modelViewMatrix;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    modelViewMatrix = yRotationMatrix  * modelViewMatrix;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    modelViewMatrix = zRotationMatrix  * modelViewMatrix;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    modelViewMatrix = cameraMatrix     * modelViewMatrix;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    /* Configure Model-View-ProjectionMatrix. */</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    </div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    /* Set vertex position in Model-View-Projection space. */</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    gl_Position = modelViewProjectionMatrix * position;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div></div><!-- fragment --><p> Fragment shader source for the wireframe torus</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision mediump float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uniform vec4 color;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* Output variable. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;out vec4 fragColor;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void main()</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    fragColor = color;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div></div><!-- fragment --><p> If we now would like to render the wireframe torus on the screen, it's enough to issue the <em>glDrawElements()</em> call using <em>GL_LINES</em> mode. Of course there should be a proper program object and vertex array object used.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_wireframe_torus.html#a40f3a9260390b34b251237d532f0370b">WireframeTorus::draw</a>(<span class="keywordtype">float</span>* rotationVector)</div><div class="line">{</div><div class="line">    GLint <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#a7b2d47fb9ecf5a9433b2e47a06427647">rotationVectorLocation</a> = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="class_torus.html#a626ebe7a0ee31f7de6da7dc5c53ea311">programID</a>, <span class="stringliteral">&quot;rotationVector&quot;</span>));</div><div class="line"></div><div class="line">    <span class="comment">/* Set required elements to draw mesh torus. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram(<a class="code" href="class_torus.html#a626ebe7a0ee31f7de6da7dc5c53ea311">programID</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="class_torus.html#a854ca8b8051565f1eb96ba9fd806c2b6">vaoID</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <a class="code" href="class_wireframe_torus.html#a3ed5ab91368775f0ceee4eb217f87a1d">indicesBufferID</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Pass Model-View matrix elements to the shader. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(rotationVectorLocation, 1, rotationVector));</div><div class="line"></div><div class="line">    <span class="comment">/* Draw lines described by previously determined indices. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawElements(GL_LINES, <a class="code" href="class_wireframe_torus.html#a972ccf0a54536b2078982a705e989ccc">indicesCount</a>, GL_UNSIGNED_INT, 0));</div><div class="line">}</div></div><!-- fragment --><p> Please look into the shader objects that we are using to render the solid torus. The situation here is more complicated as there is some lighting applied and instanced drawing technique with vertices transformed into Bezier surface is issued.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader source for the solid torus</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Number of control points in one dimension for a patch.. */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;const uint patchDimension = 4u;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* Total number of control points in a patch. */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;const uint controlPointsPerPatchCount = patchDimension * patchDimension;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* Number of quads in a patch. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;const uint quadsInPatchCount = (patchDimension - 1u) * (patchDimension - 1u);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* Total number of vertices in a patch. */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;const uint verticesCount = 144u;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;/* Input patch vertex coordinates. */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;in vec2 patchUVPosition;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;/* Constant transofrmation matrices. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;uniform mat4 cameraMatrix;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;uniform mat4 projectionMatrix;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;uniform mat4 scaleMatrix;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;/* Coefficients of rotation needed for configuration of rotation matrix. */</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;uniform vec3 rotationVector;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;/* Uniform block that stores control mesh indices. */</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;uniform ControlPointsIndices</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    uint indices[controlPointsPerPatchCount * verticesCount / quadsInPatchCount];</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;};</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;/* Uniform block that stores control mesh vertices. */</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;uniform ControlPointsVertices</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;{</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    vec4 vertices[verticesCount];</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;};</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;/* Normal vector set in Model-View-Projection space. */</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;out vec3 modelViewProjectionNormalVector;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;void main()</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    const float pi = 3.14159265358979323846;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    </div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    mat4 modelViewMatrix;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    mat4 modelViewProjectionMatrix;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    </div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    /* Array storing control vertices of current patch. */</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    vec4 controlVertices[controlPointsPerPatchCount];</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    </div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    /* Initialize array of current control vertices. */</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    for (uint i = 0u; i &lt; controlPointsPerPatchCount; ++i)</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        controlVertices[i] = vertices[indices[uint(gl_InstanceID) * controlPointsPerPatchCount + i]];</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    }</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    </div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    /* Coefficients of Bernstein polynomials. */</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    vec2 bernsteinUV0 = (1.0 - patchUVPosition) * (1.0 - patchUVPosition) * (1.0 - patchUVPosition);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    vec2 bernsteinUV1 =  3.0 * patchUVPosition  * (1.0 - patchUVPosition) * (1.0 - patchUVPosition);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    vec2 bernsteinUV2 =  3.0 * patchUVPosition  *        patchUVPosition  * (1.0 - patchUVPosition);</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    vec2 bernsteinUV3 =        patchUVPosition  *        patchUVPosition  *        patchUVPosition ;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    </div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    /* Position of a patch vertex on Bezier surface. */</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    vec3 position = bernsteinUV0.x * (bernsteinUV0.y * controlVertices[ 0].xyz + bernsteinUV1.y * controlVertices[ 1].xyz + bernsteinUV2.y * controlVertices[ 2].xyz + bernsteinUV3.y * controlVertices[ 3].xyz) +</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                    bernsteinUV1.x * (bernsteinUV0.y * controlVertices[ 4].xyz + bernsteinUV1.y * controlVertices[ 5].xyz + bernsteinUV2.y * controlVertices[ 6].xyz + bernsteinUV3.y * controlVertices[ 7].xyz) +</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                    bernsteinUV2.x * (bernsteinUV0.y * controlVertices[ 8].xyz + bernsteinUV1.y * controlVertices[ 9].xyz + bernsteinUV2.y * controlVertices[10].xyz + bernsteinUV3.y * controlVertices[11].xyz) +</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                    bernsteinUV3.x * (bernsteinUV0.y * controlVertices[12].xyz + bernsteinUV1.y * controlVertices[13].xyz + bernsteinUV2.y * controlVertices[14].xyz + bernsteinUV3.y * controlVertices[15].xyz);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    </div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    /* Matrix rotating Model-View matrix around X axis. */</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    mat4 xRotationMatrix = mat4(1.0,  0.0,                            0.0,                            0.0, </div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                0.0,  cos(radians(rotationVector.x)), sin(radians(rotationVector.x)), 0.0, </div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                0.0, -sin(radians(rotationVector.x)), cos(radians(rotationVector.x)), 0.0, </div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                0.0,  0.0,                            0.0,                            1.0);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    /* Matrix rotating Model-View matrix around Y axis. */</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    mat4 yRotationMatrix = mat4( cos(radians(rotationVector.y)), 0.0, -sin(radians(rotationVector.y)), 0.0, </div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                                 0.0,                            1.0,  0.0,                            0.0, </div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                 sin(radians(rotationVector.y)), 0.0,  cos(radians(rotationVector.y)), 0.0, </div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                                 0.0,                            0.0,  0.0,                            1.0);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    /* Matrix rotating Model-View matrix around Z axis. */</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    mat4 zRotationMatrix = mat4( cos(radians(rotationVector.z)), sin(radians(rotationVector.z)), 0.0, 0.0, </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                                -sin(radians(rotationVector.z)), cos(radians(rotationVector.z)), 0.0, 0.0, </div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                0.0,                             0.0,                            1.0, 0.0, </div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                0.0,                             0.0,                            0.0, 1.0);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    </div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    /* Model-View matrix transformations. */</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    modelViewMatrix = scaleMatrix;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    modelViewMatrix = xRotationMatrix * modelViewMatrix;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    modelViewMatrix = yRotationMatrix * modelViewMatrix;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    modelViewMatrix = zRotationMatrix * modelViewMatrix;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    modelViewMatrix = cameraMatrix    * modelViewMatrix;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    /* Configure Model-View-ProjectionMatrix. */</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    /* Set vertex position in Model-View-Projection space. */</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    /* Angle on the &quot;big circle&quot; of torus. */</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    float phi = (patchUVPosition.x + mod(float(gl_InstanceID), 4.0)) * pi / 2.0;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    /* Angle on the &quot;small circle&quot; of torus. */</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    float theta = (patchUVPosition.y + mod(float(gl_InstanceID / 4), 4.0)) * pi / 2.0;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    /* Horizontal tangent to torus. */</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    vec3 dBdu = vec3(-sin(phi), 0.0, cos(phi));</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    /* Vertical tangent to torus. */</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    vec3 dBdv = vec3(cos(phi) * (-sin(theta)), cos(theta), sin(phi) * (-sin(theta)));</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    /* Calculate normal vector. */</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    vec3 normalVector = normalize(cross(dBdu, dBdv));</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    /* Calculate normal matrix. */</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    mat3 normalMatrix = transpose(inverse(mat3x3(modelViewMatrix)));</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    /* Transform normal vector to Model-View-Projection space. */</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    modelViewProjectionNormalVector = normalize(normalMatrix * normalVector);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div></div><!-- fragment --><p> Fragment shader source for the solid torus</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision mediump float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* Input normal vector. */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec3 modelViewProjectionNormalVector;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;/* Structure storing directional light parameters. */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;struct Light</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    vec3  lightColor;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    vec3  lightDirection;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    float ambientIntensity;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;};</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;/* Color of the drawn torus. */</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;uniform vec4  color;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;/* Uniform representing light parameters. */</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;uniform Light light;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;/* Output variable. */</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;out vec4 fragColor;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;void main()</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    /* Calculate the value of diffuse intensity. */</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    float diffuseIntensity = max(0.0, -dot(modelViewProjectionNormalVector, normalize(light.lightDirection)));</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    /* Calculate the output color value considering the light. */</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    fragColor = color * vec4(light.lightColor * (light.ambientIntensity + diffuseIntensity), 1.0);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div></div><!-- fragment --><p> If we now would like to render the solid torus on the screen, it's enough to issue the <em>glDrawElementsInstanced()</em> call using <em>GL_TRIANGLES</em> mode. Of course there should be proper program object and vertex array object used.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_instanced_solid_torus.html#ae08fc72349bddb25c0c1cf2b65959d29">InstancedSolidTorus::draw</a>(<span class="keywordtype">float</span>* rotationVector)</div><div class="line">{</div><div class="line">    <span class="comment">/* Location of rotation vector. */</span></div><div class="line">    GLint rotationVectorLocation = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="class_torus.html#a626ebe7a0ee31f7de6da7dc5c53ea311">programID</a>, <span class="stringliteral">&quot;rotationVector&quot;</span>));</div><div class="line"></div><div class="line">    <span class="comment">/* Set required OpenGL ES state. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram     (<a class="code" href="class_torus.html#a626ebe7a0ee31f7de6da7dc5c53ea311">programID</a>                                    ));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="class_torus.html#a854ca8b8051565f1eb96ba9fd806c2b6">vaoID</a>                                        ));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer     (GL_ELEMENT_ARRAY_BUFFER, <a class="code" href="class_instanced_solid_torus.html#a56f7ca664b77d5bdc2640209e1ccc409">patchIndicesBufferID</a>));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rotationVectorLocation != -1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Pass rotation parameters to the shader. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(rotationVectorLocation, 1, rotationVector));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#ae02538a80ad5fc009caec73487d11a8d">LOGE</a>(<span class="stringliteral">&quot;Could not locate \&quot;rotationVector\&quot; uniform in program [%d]&quot;</span>, <a class="code" href="class_torus.html#a626ebe7a0ee31f7de6da7dc5c53ea311">programID</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Draw patchInstancesCount instances of patchTriangleIndicesCount triangles. */</span> </div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawElementsInstanced(GL_TRIANGLES, <a class="code" href="class_instanced_solid_torus.html#a5c9d386960906547907a19edb0e73b7d">patchTriangleIndicesCount</a>, GL_UNSIGNED_INT, 0, <a class="code" href="class_instanced_solid_torus.html#a68c50184ab32fdf064ea7b1d279a5d07">patchInstancesCount</a>));</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="instancedTessellationResult"></a>
Result</h1>
<p>We wanted the model to rotate, which is why we need to calculate a new rotation angle each frame. Once we have a rotation vector generated, it's used to update the vertices position for both: wireframe and solid torus.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Increment rotation angles. */</span></div><div class="line">    <a class="code" href="_frame_buffer_object_8cpp.html#a9a57f322df958dc574c9843c6ab4b1c2">angleX</a> += 0.5;</div><div class="line">    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#adb82b6f9a59b4ebab80b0ea796dbe066">angleY</a> += 0.5;</div><div class="line">    <a class="code" href="_frame_buffer_object_8cpp.html#aa67cf2b62fb9fc5f61976d3d3984975e">angleZ</a> += 0.5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_frame_buffer_object_8cpp.html#a9a57f322df958dc574c9843c6ab4b1c2">angleX</a> &gt;= 360.0f) <a class="code" href="_frame_buffer_object_8cpp.html#a9a57f322df958dc574c9843c6ab4b1c2">angleX</a> = 0.0f;</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#adb82b6f9a59b4ebab80b0ea796dbe066">angleY</a> &gt;= 360.0f) <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#adb82b6f9a59b4ebab80b0ea796dbe066">angleY</a> = 0.0f;</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="_frame_buffer_object_8cpp.html#aa67cf2b62fb9fc5f61976d3d3984975e">angleZ</a> &gt;= 360.0f) <a class="code" href="_frame_buffer_object_8cpp.html#aa67cf2b62fb9fc5f61976d3d3984975e">angleZ</a> = 0.0f;</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> rotationVector[] = {<a class="code" href="_frame_buffer_object_8cpp.html#a9a57f322df958dc574c9843c6ab4b1c2">angleX</a>, <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#adb82b6f9a59b4ebab80b0ea796dbe066">angleY</a>, <a class="code" href="_frame_buffer_object_8cpp.html#aa67cf2b62fb9fc5f61976d3d3984975e">angleZ</a>};</div></div><!-- fragment --><p> The calculated values are then used while drawing the requested models.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_instanced_tessellation_2jni_2_native_8cpp.html#ad7286281f5506d5a0d1b005d945ba86c">wireframeTorus</a>-&gt;<a class="code" href="class_torus.html#ab451be801d21125b75e12e402afaa1a5">draw</a>(rotationVector);</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="tutorials_2_instanced_tessellation_2jni_2_native_8cpp.html#a734b0346b7557c8d45e38bc3a09bfef7">solidTorus</a>-&gt;<a class="code" href="class_torus.html#ab451be801d21125b75e12e402afaa1a5">draw</a>(rotationVector);</div></div><!-- fragment --> <div class="image">
<img src="InstancedTessellation_result.png" alt="InstancedTessellation_result.png"/>
<div class="caption">
The result model consists of both: wireframe and solid torus.</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
