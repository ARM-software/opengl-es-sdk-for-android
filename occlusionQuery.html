<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Occlusion Query</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occlusionQuery.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Occlusion Query </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Demonstration of Occlusion Query functionality in OpenGL ES 3.0.</p>
<h1><a class="anchor" id="occlusionQueryIntroduction"></a>
Introduction</h1>
<p>It's assumed that you have read and understood all of the mechanisms described in <a class="el" href="assetLoading.html">Asset Loading</a>,<a class="el" href="simpleTriangle.html">Simple Triangle</a> and <a class="el" href="textureCube.html">Texture Cube</a>.</p>
<h1><a class="anchor" id="occlusionQueryOverview"></a>
Overview</h1>
<div class="image">
<img src="OcclusionQuery_android.png" alt="OcclusionQuery_android.png"/>
<div class="caption">
We are rendering a horizontally located plane, on top of which we lay some rounded cubes.</div></div>
<p> The main purpose of the application is to show the difference in performance when the occlusion query mode is on or off. If the occlusion query mode is on, then only the cubes that are visible to the viewer are rendered. In the other case, when the occlusion query mode is off, then all of the cubes are rendered, which leads to a massive decrease in performance.</p>
<ul>
<li>In the case where occlusion query mode in on: if there is a small number of objects visible for a viewer, the application runs very smooth; the larger the number of the visible objects, the slower the animation is, but still the performance is better than in the following case.</li>
<li>In the case where occlusion query mode in off: the performance is constant (very low), regardless of the number of visible cubes (all of them are always rendered).</li>
</ul>
<p>We are rendering rounded cubes - the objects are more complicated than the normal cubes, which means the time needed for rendering this kind of objects is longer. We are using this fact to demonstrate the occlusion query mode. When we want to verify whether the object is visible for a viewer, we can draw a simpler object (located in the same position as the requested one and being almost of the same size and shape), and once we get the results, we are able to render only those rounded cubes which passed the test.</p>
<p>There is also text displayed (at the bottom left corner of the screen) showing whether the occlusion query mode is currently on or off. The mode changes every 10 seconds.</p>
<h1><a class="anchor" id="occlusionQueryRenderGeometry"></a>
Render a Geometry</h1>
<p>In the application we are rendering a plane, cubes and rounded cubes. The "normal" cubes are rendered only in occlusion query mode to verify whether the object is visible for a viewer, but they are not visible on the screen: more detail is provided in the following section <a class="el" href="occlusionQuery.html#occlusionQueryOcclusionQueries">Occlusion Queries</a>.</p>
<p>The first step we should take is to generate the coordinates of the objects we would like to render and prepare them for the draw calls. Let's describe the mechanism based on an example of a plane object as all of the objects should be prepared in the same way.</p>
<p>We want to draw a plane which is laid horizontally, which in the 3D space means it should be located in XZ space. Please note that there will also be lighting applied, which means that we will need normals as well.</p>
<div class="image">
<img src="OcclusionQueriesGeometry_plane.png" alt="OcclusionQueriesGeometry_plane.png"/>
<div class="caption">
Schema presenting plane vertices in XZ space.</div></div>
<p> The basic OpenGL ES rendering technique is based on drawing triangles that make up a requested shape. This will be our next step. It's important to mention here that whilst describing plane triangle vertices, you should follow the clockwise or counter-clockwise order, otherwise OpenGL ES will have trouble in detecting the front and back faces. In this example we are using clockwise (CW) order to describe plane coordinates as this is the default for OpenGL ES.</p>
<div class="fragment"><div class="line">    PlaneModel::getTriangleRepresentation(&amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a3197f898ee4cefcb497079412333f2f1">numberOfPlaneVertices</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ad1ee992f09d60c5acb314e73168894a9">numberOfPlaneVertexCoordinates</a>,</div><div class="line">                                          &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ae68dfb684191ed58e7ef660108a7b322">planeVertices</a>);</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="keywordtype">void</span> PlaneModel::getTriangleRepresentation(<span class="keywordtype">int</span>* numberOfPoints, <span class="keywordtype">int</span>* numberOfCoordinates, <span class="keywordtype">float</span>** coordinates)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Example:</span></div><div class="line"><span class="comment">         *  z   D __________ C</span></div><div class="line"><span class="comment">         *  .    |        / |</span></div><div class="line"><span class="comment">         * / \   |     /    |</span></div><div class="line"><span class="comment">         *  |    |  /       |</span></div><div class="line"><span class="comment">         *  |    |/_________|</span></div><div class="line"><span class="comment">         *  |   A            B</span></div><div class="line"><span class="comment">         *  |----------&gt; x</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(coordinates != NULL, <span class="stringliteral">&quot;Cannot use null pointer while calculating coordinates.&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Define point coordinates. */</span></div><div class="line">        <span class="keyword">const</span> Vec4f pointA = {-1.0f, 0.0f, -1.0f, 1.0f};</div><div class="line">        <span class="keyword">const</span> Vec4f pointB = { 1.0f, 0.0f, -1.0f, 1.0f};</div><div class="line">        <span class="keyword">const</span> Vec4f pointC = { 1.0f, 0.0f,  1.0f, 1.0f};</div><div class="line">        <span class="keyword">const</span> Vec4f pointD = {-1.0f, 0.0f,  1.0f, 1.0f};</div><div class="line"></div><div class="line">        <span class="comment">/* 2 triangles, 3 points of triangle, 4 coordinates for each point. */</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> numberOfSquarePoints      = numberOfSquareTriangles *</div><div class="line">                                              numberOfTrianglePoints;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> numberOfSquareCoordinates = numberOfSquarePoints    *</div><div class="line">                                              numberOfPointCoordinates;</div><div class="line"></div><div class="line">        <span class="comment">/* Allocate memory for result array. */</span></div><div class="line">        *coordinates = (<span class="keywordtype">float</span>*) malloc (numberOfSquareCoordinates * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line"></div><div class="line">        <span class="comment">/* Is allocation successful? */</span></div><div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(*coordinates != NULL, <span class="stringliteral">&quot;Could not allocate memory for result array.&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* Index of an array we will put new point coordinates at. */</span></div><div class="line">        <span class="keywordtype">int</span> currentIndex = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* First triangle. */</span></div><div class="line">        <span class="comment">/* A */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointA.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.w;</div><div class="line">        <span class="comment">/* B */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointB.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointB.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointB.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointB.w;</div><div class="line">        <span class="comment">/* C */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointC.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.w;</div><div class="line"></div><div class="line">        <span class="comment">/* Second triangle. */</span></div><div class="line">        <span class="comment">/* A */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointA.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointA.w;</div><div class="line">        <span class="comment">/* C */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointC.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointC.w;</div><div class="line">        <span class="comment">/* D */</span></div><div class="line">        (*coordinates)[currentIndex++] = pointD.x;</div><div class="line">        (*coordinates)[currentIndex++] = pointD.y;</div><div class="line">        (*coordinates)[currentIndex++] = pointD.z;</div><div class="line">        (*coordinates)[currentIndex++] = pointD.w;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (numberOfPoints != NULL)</div><div class="line">        {</div><div class="line">            *numberOfPoints = numberOfSquarePoints;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (numberOfCoordinates != NULL)</div><div class="line">        {</div><div class="line">            *numberOfCoordinates = numberOfSquareCoordinates;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> We will need plane normals as well.</p>
<div class="fragment"><div class="line">    PlaneModel::getNormals(&amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a4a166afa614b9cbc392e6c613df60873">sizeOfPlaneNormalsArray</a>,</div><div class="line">                           &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a5ad4e734fe55629da8387e54fa588f08">planeNormalVectors</a>);</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="keywordtype">void</span> PlaneModel::getNormals(<span class="keywordtype">int</span>* numberOfCoordinates, <span class="keywordtype">float</span>** normals)</div><div class="line">    {</div><div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(normals != NULL, <span class="stringliteral">&quot;Cannot use null pointer while calculating coordinates.&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* 2 triangles, 3 points of triangle, 3 coordinates for each point. */</span></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> numberOfNormalsCoordinates = numberOfSquareTriangles *</div><div class="line">                                               numberOfTrianglePoints  *</div><div class="line">                                               numberOfPointCoordinates;</div><div class="line"></div><div class="line">        <span class="comment">/* Index of an array we will put new point coordinates at. */</span></div><div class="line">        <span class="keywordtype">int</span> currentIndex = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Allocate memory for result array. */</span></div><div class="line">        *normals = (<span class="keywordtype">float</span>*) malloc (numberOfNormalsCoordinates * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line"></div><div class="line">        <span class="comment">/* Is allocation successful? */</span></div><div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(*normals != NULL, <span class="stringliteral">&quot;Could not allocate memory for result array.&quot;</span>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numberOfNormalsCoordinates; i += numberOfPointCoordinates)</div><div class="line">        {</div><div class="line">            (*normals)[currentIndex++] = 0.0f;</div><div class="line">            (*normals)[currentIndex++] = 1.0f;</div><div class="line">            (*normals)[currentIndex++] = 0.0f;</div><div class="line">            (*normals)[currentIndex++] = 1.0f;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (numberOfCoordinates != NULL)</div><div class="line">        {</div><div class="line">            *numberOfCoordinates = numberOfNormalsCoordinates;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> Once we have generated the plane coordinates we should focus on the API. We need buffer objects to store the generated data. But we will need <a class="el" href="struct_vertex.html">Vertex</a> Array objects as well to easily determine which vertex data (stored in buffer objects) should be used for a specific draw command. As written in the OpenGL ES 3.0 documentation: <em>The buffer objects that are to be used by the vertex stage of the GL are collected together to form a vertex array object</em>. To generate <a class="el" href="struct_vertex.html">Vertex</a> Array object we need to call</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>));</div></div><!-- fragment --><p> As mentioned before, we will need buffer objects to store generated data. To create ones we need to issue</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a808b6b890a128f2fca69d93a99bd98fd">planeVerticesBufferId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a034838659d1554058f0b3e5ea748b176">planeNormalVectorsBufferId</a>));</div></div><!-- fragment --><p> What we need to do now is to copy plane coordinates and plane normals to the specific buffer objects.</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a808b6b890a128f2fca69d93a99bd98fd">planeVerticesBufferId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ad1ee992f09d60c5acb314e73168894a9">numberOfPlaneVertexCoordinates</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ae68dfb684191ed58e7ef660108a7b322">planeVertices</a>,</div><div class="line">                                       GL_STATIC_DRAW));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a034838659d1554058f0b3e5ea748b176">planeNormalVectorsBufferId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a4a166afa614b9cbc392e6c613df60873">sizeOfPlaneNormalsArray</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a5ad4e734fe55629da8387e54fa588f08">planeNormalVectors</a>,</div><div class="line">                                       GL_STATIC_DRAW));</div></div><!-- fragment --><p> To define an array of generic vertex attribute data, we need to call</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer(verticesAttributeLocation,</div><div class="line">                                       4,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       0));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer(normalAttributeLocation,</div><div class="line">                                       4,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       0));</div></div><!-- fragment --><p> Please note that these commands should be called for a specific buffer object being currently bound, which means the call hierarchy should look like follows</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a808b6b890a128f2fca69d93a99bd98fd">planeVerticesBufferId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ad1ee992f09d60c5acb314e73168894a9">numberOfPlaneVertexCoordinates</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ae68dfb684191ed58e7ef660108a7b322">planeVertices</a>,</div><div class="line">                                       GL_STATIC_DRAW));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer(verticesAttributeLocation,</div><div class="line">                                       4,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       0));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a034838659d1554058f0b3e5ea748b176">planeNormalVectorsBufferId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData         (GL_ARRAY_BUFFER,</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a4a166afa614b9cbc392e6c613df60873">sizeOfPlaneNormalsArray</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                                       <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a5ad4e734fe55629da8387e54fa588f08">planeNormalVectors</a>,</div><div class="line">                                       GL_STATIC_DRAW));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer(normalAttributeLocation,</div><div class="line">                                       4,</div><div class="line">                                       GL_FLOAT,</div><div class="line">                                       GL_FALSE,</div><div class="line">                                       0,</div><div class="line">                                       0));</div></div><!-- fragment --><p> In the <em>glVertexAttribPointer()</em> calls we use <em>verticesAttributeLocation</em> and <em>normalAttributeLocation</em> as arguments. These values indicate the locations of the attributes within a program object that are used for rendering the specific geometry. We will describe the problem in more details at the end of this section.</p>
<p>The next step is to bind vertex array object</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>));</div></div><!-- fragment --><p> and enable vertex attrib arrays</p>
<div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(verticesAttributeLocation));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(normalAttributeLocation));</div></div><!-- fragment --><p> When we want to render the plane, we need to make sure that the specific vertex array object is currently bound and then issue the draw call.</p>
<div class="fragment"><div class="line">    {</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray (<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform4fv      (<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#ae12bc50ab339652877fbf871649403f0">colorUniformLocation</a>,</div><div class="line">                                    1,</div><div class="line">                                    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a308deba5c04da6a13f1d2b36815d20a7">planeColor</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#abc3deefd56dff2f3bd24e2d5b51ea36b">normalMatrixUniformLocation</a>,</div><div class="line">                                    1,</div><div class="line">                                    GL_FALSE,</div><div class="line">                                    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a641552595ecca1d7d6d1b9f1feb6190e">planeNormalMatrix</a>.getAsArray()));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a969b54ea994ead5c5cad48b81764e410">worldInverseMatrixUniformLocation</a>,</div><div class="line">                                    1,</div><div class="line">                                    GL_FALSE,</div><div class="line">                                    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#aad090dd8c7360156534fa2a6fa4f0abe">planeWorldInverseMatrix</a>.getAsArray()));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a70b7e81f367dace3aaab89367b16d148">mvpMatrixUniformLocation</a>,</div><div class="line">                                    1,</div><div class="line">                                    GL_FALSE,</div><div class="line">                                    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#adaed5c728c7bdcf6c5c37a40a5ba416f">planeMvpMatrix</a>.getAsArray()));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays      (GL_TRIANGLES,</div><div class="line">                                    0,</div><div class="line">                                    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a3197f898ee4cefcb497079412333f2f1">numberOfPlaneVertices</a>));</div><div class="line">    }</div></div><!-- fragment --><p> At this point, the reader should be already aware of how to prepare and use program objects. Let us briefly describe the mechanism.</p>
<ol type="1">
<li>Create program object: <div class="fragment"><div class="line">    <a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a> = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCreateProgram());</div></div><!-- fragment --></li>
<li>Create shader object: <div class="fragment"><div class="line">        *shaderObjectIdPtr = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCreateShader(shaderType));</div></div><!-- fragment --></li>
<li>Set shader source: <div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glShaderSource(*shaderObjectIdPtr, 1, <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>, NULL));</div></div><!-- fragment -->Please note that the <em>strings</em> variable is storing the shader source read from a file. <div class="fragment"><div class="line">        <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>[0]         = <a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#aceb8b27cd7d369c524624ede81a1299e">loadShader</a>(filename);</div></div><!-- fragment --></li>
<li>Compile shader: <div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCompileShader(*shaderObjectIdPtr));</div></div><!-- fragment -->It's always a good idea to check whether compilation succeeded by checking <em>GL_COMPILE_STATUS</em> (<em>GL_TRUE</em> is expected). <div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetShaderiv(*shaderObjectIdPtr, GL_COMPILE_STATUS, &amp;compileStatus));</div></div><!-- fragment --></li>
</ol>
<p>Once you have called the functions for both fragment and vertex shaders, you should now attach both to a program object, </p><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#acc1eb33f2e499064566b78ec020099a4">vertexShaderId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab4fa89f786e9fe64ec88be5363d3e79c">fragmentShaderId</a>));</div></div><!-- fragment --><p> link the program object, </p><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glLinkProgram(<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>));</div></div><!-- fragment --><p> and set the program object to be used (active). </p><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUseProgram (<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>));</div></div><!-- fragment --><p> The <em>verticesAttributeLocation</em> and <em>normalAttributeLocation</em> arguments used in the <em>glVertexAttribPointer()</em> calls are attrib locations which are retrieved with the following call.</p>
<div class="fragment"><div class="line">    GLuint normalAttributeLocation   = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation (<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>, <span class="stringliteral">&quot;normal&quot;</span>));</div><div class="line">    GLuint verticesAttributeLocation = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation (<a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a7b323a585c4b161fa33338ac823567df">programId</a>, <span class="stringliteral">&quot;vertex&quot;</span>));</div></div><!-- fragment --><p> The second argument corresponds to the attribute name used in the vertex shader.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader code</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Vertex and normal vector attributes sent from the program. */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec4 vertex;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;in vec4 normal;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* This matrix is used to set the perspective up and is sent from the program. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;uniform mat4 projectionMatrix;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;/* This matrix is used to set the view up and is sent from the program. */</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform mat4 viewMatrix;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform mat4 modelMatrix;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;uniform mat4 normalMatrix;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;uniform mat4 mvpMatrix;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;/* Output normal vector (used to compute light). */</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;out vec3 normalOut;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;/* Vertex position in world space that we pass to fragment shader. */</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;out vec4 modelPosition;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;/* Inverted model-view-projection matrix passed to the fragment shader to compute light. */</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;out mat4 worldInverse;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;void main()</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;{</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    /* Calculate normal vector in world space (used to calculate light). */</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    normalOut = vec3(normalMatrix * normal);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    gl_Position = mvpMatrix * vertex;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div></div><!-- fragment --><p> Fragment shader code</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision highp float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* These values are passed to the fragment shader from the vertex shader. */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec3 normalOut;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;in vec4 modelPosition;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* Color of a geometry. */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;uniform vec4 color;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;/* Inverted model-view-projection matrix that will be used to compute light. */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform mat4 worldInverseMatrix;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;/* Output object&#39;s color. */</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;out vec4 outColor;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;/* Structure that describes the light source. */</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;struct lightSource</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;{</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    vec4 position;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    vec4 diffuse;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    vec4 specular;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;};</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;/* Structure that describes material. */</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;struct material</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;{</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    vec4 ambient;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    vec4 diffuse;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    vec4 specular;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    float shininess;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;};</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;void main()</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    /* Ambient light factor. */</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    vec4 sceneAmbient = vec4(0.2, 0.2, 0.2, 1.0);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    /* Light source with hard coded parameters. */</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    lightSource light = lightSource(vec4(50.0, 100.0, 50.0, 0.0),</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                                    vec4( 1.0,   1.0,  1.0, 1.0),</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                    vec4( 1.0,   1.0,  1.0, 1.0));</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    /* New material with hard coded parameters. */</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    material frontMaterial = material(vec4(0.2, 0.2, 0.2, 1.0),</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                      color,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                                      vec4(1.0, 1.0, 1.0, 1.0),</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                                      25.0);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    /* Set vectors up. */</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    vec3 normalDirection = normalize(normalOut);</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    /* We need a direction to the viewer. That&#39;s why we compute difference between the camera position (worldInverseMatrix) and vertex position (modelPosition). */</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    vec3 viewDirection   = normalize(vec3(worldInverseMatrix * vec4(0.0, 0.0, 0.0, 1.0) - modelPosition));</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    vec3 lightDirection;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    </div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    float attenuation;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    /* Check if it&#39;s a directional light. */</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    if (0.0 == light.position.w)</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        /* No attenuation. */</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        attenuation = 1.0;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        /* Setup light direction. */</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        lightDirection = normalize(vec3(light.position));</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    } </div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    /* Compute ambient factor of the light. It&#39;s done by multiplying sceneAmbient color and material ambient color. */</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    vec3 ambientLighting = vec3(sceneAmbient) * vec3(frontMaterial.ambient);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    /* Compute diffuse reflection. Diffuse reflection = attenuation * lightDiffuse * materialDiffuse * (normalDirection o lightDirection). */</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    vec3 diffuseReflection = attenuation                 *</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                             vec3(light.diffuse)         *</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                             vec3(frontMaterial.diffuse) *</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                             clamp(dot(normalDirection, lightDirection), 0.0, 1.0);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    /* Check if the light source is on the proper side. */</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    vec3 specularReflection = vec3(0.0, 0.0, 0.0);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    if (dot(normalDirection, lightDirection) &gt;= 0.0)</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        /* If it&#39;s on the right side, compute specularReflection. Specular reflection = attenuation * lightSpecular * materialSpecular * (-lightDirection o normalDirection). */</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        specularReflection = attenuation                  *</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                             vec3(light.specular)         *</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                             vec3(frontMaterial.specular) *</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                             pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), frontMaterial.shininess);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    /* Set the final color of the object. */</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    outColor = vec4(ambientLighting + diffuseReflection + specularReflection, 1.0);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;}</div></div><!-- fragment --> <h1><a class="anchor" id="occlusionQueryOcclusionQueries"></a>
Occlusion Queries</h1>
<p>As already mentioned before, the main purpose of the application is to show the difference in the performance when the occlusion query mode is on or off. The occlusion query mechanism is used to verify whether an object is visible for a viewer or if it is occluded by other objects (in this case there is no need to render it as we are not able to see it anyway). If all of the objects which are not visible are ignored, then the application runs much faster in comparison to rendering all of the objects. This is where we are able to use an optimization trick. We want to render rounded cubes on a screen, which is rather a complicated geometry and rendering it takes some time. But we can use a very similar shape, that is much easier to render: the normal cube, only to verify the occlusion. But let us describe the problem in details.</p>
<p>First of all, we need to generate the query objects.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenQueries(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>, <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a69ae9c46eefb275c6f8b91ecc73668da">cubeQuery</a>));</div></div><!-- fragment --><p> When we want the occlusion query mode to be issued, we are render the normal cubes as well, so we need to set a proper vertex array object to be active.</p>
<div class="fragment"><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a5f40f367f5f3a6a884f1a590aabcb6a6">normalCubeVertexArrayObjectId</a>));</div></div><!-- fragment --><p> We don't want the normal cubes to be visible on screen, this is why we are calling</p>
<div class="fragment"><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE));</div></div><!-- fragment --><p> Then we can enable the query test and render each cube (separately).</p>
<div class="fragment"><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>; i++)</div><div class="line">            {</div><div class="line">                <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a70ee96cdfea3bddc865611f4ae2ca07d">sendCubeLocationVectorToUniform</a>(i);</div><div class="line">                <span class="comment">/* Begin occlusion query. */</span></div><div class="line">                <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBeginQuery(GL_ANY_SAMPLES_PASSED, <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a69ae9c46eefb275c6f8b91ecc73668da">cubeQuery</a>[i]));</div><div class="line">                {</div><div class="line">                    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#abf79cbe865f20186497045d3c65b7695">numberOfCubeVertices</a>));</div><div class="line">                }</div><div class="line">                <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEndQuery(GL_ANY_SAMPLES_PASSED));</div><div class="line">                <span class="comment">/* End occlusion query. */</span></div><div class="line">            }</div></div><!-- fragment --><p> Then we restore the color mask, so that the next draw call results will be visible on screen.</p>
<div class="fragment"><div class="line">            <span class="comment">/* Clear depth buffer and enable color mask to make rounded cubes visible. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE));</div></div><!-- fragment --><p> We would like to draw the rounded cubes now, so the proper vertex array object should be used.</p>
<div class="fragment"><div class="line">            <span class="comment">/* Draw rounded cubes. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#af39652d49cce88bd9fbbddcdd72ca9c9">roundedCubeVertexArrayObjectId</a>));</div></div><!-- fragment --><p> Now, for each cube, we need to verify whether it should be rendered or not. We need to get the query result.</p>
<div class="fragment"><div class="line">                <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetQueryObjectuiv(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a69ae9c46eefb275c6f8b91ecc73668da">cubeQuery</a>[i], GL_QUERY_RESULT, &amp;queryResult));</div></div><!-- fragment --><p> And in case, the <em>GL_TRUE</em> is returned (which means the cube is visible), we can issue the draw call</p>
<div class="fragment"><div class="line">                    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div><div class="line">                                          0,</div><div class="line">                                          <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a2b70e03841e579a1e75bfa0cccf59fc3">numberOfRoundedCubesVertices</a>));</div></div><!-- fragment --><p> In the application, we are doing one more thing to make the occlusion test work properly. We are sorting the cubes' positions from the nearest to the furthest (relative to the viewer's position). This should be issued before the occlusion test.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Sort the cubes&#39; positions. We have to do it in every frame because camera constantly moves around the scene.</span></div><div class="line"><span class="comment">     * It is important that the cubes are rendered front to back because the occlusion test is done per draw call.</span></div><div class="line"><span class="comment">     * If the cubes are draw out of order then some cubes may pass the occlusion test even when they end up being</span></div><div class="line"><span class="comment">     * occluded by geometry drawn later. */</span></div><div class="line">    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a28ac2162a6ebbcb6207f117af77b641a">sortCubePositions</a>(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#abc94c5b9ece0394183ba35b4a9c0a01a">sortedCubesPositions</a>);</div></div><!-- fragment --><p> If we now would want to turn off the occlusion query mode, we should just simply render all of the rounded cubes.</p>
<div class="fragment"><div class="line">            <span class="comment">/* Draw all rounded cubes without using occlusion queries. */</span></div><div class="line">            <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#af39652d49cce88bd9fbbddcdd72ca9c9">roundedCubeVertexArrayObjectId</a>));</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>; i++)</div><div class="line">            {</div><div class="line">                <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a70ee96cdfea3bddc865611f4ae2ca07d">sendCubeLocationVectorToUniform</a>(i);</div><div class="line"></div><div class="line">                <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div><div class="line">                                      0,</div><div class="line">                                      <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a2b70e03841e579a1e75bfa0cccf59fc3">numberOfRoundedCubesVertices</a>));</div><div class="line">            }</div><div class="line"></div><div class="line">            <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a68a7ddc5af87117cba4bf1e483729ac5">numberOfRoundedCubesDrawn</a> = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>;</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
