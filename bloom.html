<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Bloom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bloom.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Bloom </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Bloom effect using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="bloomIntroduction"></a>
Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>This sample uses OpenGL ES 3.0.</dd></dl>
<p>The source for this sample can be found in the folder of the SDK.</p>
<p>This tutorial assumes you know how to create a new project (if not, please start with <a class="el" href="first_native.html">First Android Native Application</a>) and you have read and understood both <a class="el" href="simple_cube.html">Simple Cube</a> and <a class="el" href="lighting.html">Lighting</a>.</p>
<h1><a class="anchor" id="bloomOverview"></a>
Overview</h1>
<div class="image">
<img src="Bloom.png" alt="Bloom.png"/>
<div class="caption">
Bloom effect: the intensity changes from very weak to very strong.</div></div>
<p> The application shows a bloom effect implementation. It draws cubes arranged in a two-dimensional 5x5 array, from which only the diagonal ones are bloomed. The intensity of the bloom effect changes from very weak, where each cube affected by the effect looks exactly as the normal ones, to very strong, when bloomed cubes make up an X shape.</p>
<p>The bloom effect is implemented as follows:</p>
<ol type="1">
<li>A scene (5x5 array of cubes: cubes on diagonals are white, others are blue) is drawn to a render target.</li>
<li>Elements that should be bloomed (the brighter ones, in this case cubes placed on diagonals) are drawn into downscaled texture object (where the rest of the scene is black).</li>
<li>The result texture from step 2 is horizontally blurred - the outcome is stored in a texture which is then used for the vertical blur. This step can be repeated as described later (*).</li>
<li>Both the texture in which the vertically &amp; horizontally blurred image has been stored (result of step 3), and the texture from step 1 are blended (horizontally &amp; vertically) and drawn into the back buffer.</li>
</ol>
<p>(*) The blend effect is not constant during the rendering process: it changes from very weak to very strong. This is achieved by repeating step 3 a varying amount of times (depending on the required intensity of the effect) - the only difference is that for the n-th iteration the generated result of (n-th - 1) is taken as a source for the horizontal blur. To make the bloom effect more smooth, we also use continuous sampling of the textures. The results of the last two iterations from step 3 are used for the final combination pass. The colours of those two textures are mixed together with an appropriate factor value. (for more details please see the mix() function description in the OpenGL ES Shading Language documentation).</p>
<p>Besides the bloom effect, the application also shows:</p>
<ul>
<li>matrix calculations (e.g. used for perspective view),</li>
<li>instanced drawing (each cube drawn on a screen is an instance of the same object),</li>
<li>lighting (the model is lit by a directional light),</li>
<li>rendering into a texture.</li>
</ul>
<h1><a class="anchor" id="bloomInstancedDrawing"></a>
Instanced Drawing</h1>
<p>Each cube drawn on the screen is an instance of the same object. Let's go through the whole mechanism step by step.</p>
<p>It is assumed that all of below functions are called for an active program object responsible for scene rendering.</p>
<p>We want to draw a 5x5 two-dimensional array of cubes. It is important to mention that white and blue cubes are still the instances of the same object (the difference in colours will be described later). In the code we are using define</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#define NUMBER_OF_CUBES (25)</span></div>
</div><!-- fragment --><p> Generate a cubic shape. For more details how the cube vertices are created please refer to <a class="el" href="simple_cube.html">Simple Cube</a>. We want our cubes to be a little bit smaller to fit in a screen. In this simple model, we could achieve that in many ways, but let's use the simplest one - scale the cube using multiplier. Thanks to that cube vertices will not be spread in a range from &lt;-1, -1, -1&gt; to &lt;1, 1, 1&gt;, but adjusted accordingly to used multiplier.</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#define CUBE_SCALAR (0.8f)</span></div>
</div><!-- fragment --><p> Please look into <b><a class="el" href="tutorials_2_bloom_2jni_2_cube_model_8cpp.html">tutorials/Bloom/jni/CubeModel.cpp</a></b> to see how the cube triangle vertices are retrieved.</p>
<p>Now we need to transfer generated info into an array buffer object. </p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffer object and fill it with cube vertex coordinates data. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1,</div>
<div class="line">                         &amp;<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#ae020ce39e34f3936f2998df7075de904">bufferObjectIdCubeCoords</a>) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#ae020ce39e34f3936f2998df7075de904">bufferObjectIdCubeCoords</a>) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2a5b4255b941236cc08b49e36794f3b2">nOfCubeCoordinates</a> * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div>
<div class="line">                (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>*)<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ac87fdf3e5d1c8a06037a3ab9b913da78">cubeCoordinates</a>,</div>
<div class="line">                          GL_STATIC_DRAW) );</div>
</div><!-- fragment --><p> Define an array of generic vertex attribute data. Make sure that a proper buffer object (one which contains cube vertices data) is currently bound to GL_ARRAY_BUFFER. In our application we are re-binding it many times, so before calling <b>glVertexAttribPointer()</b> we bind it again. In one of the next steps we will describe what the <em>sceneRenderingProgramLocationsPtr-&gt;attribCubeVertexCoordinates</em> stands for, so don't worry about it now (it will be described in <a class="el" href="bloom.html#bloomInstancedDrawingShaderObjects">Shader Objects used for Instanced Drawing</a>).</p>
<div class="fragment"><div class="line">    <span class="comment">/* Cube coordinates are constant during rendering process. Set them now. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer         (GL_ARRAY_BUFFER,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#ae020ce39e34f3936f2998df7075de904">bufferObjectIdCubeCoords</a>) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2c951a451ea9bfb73fe3f756ad261322">sceneRenderingProgramLocations</a>.<a class="code" href="struct_scene_rendering_program_locations.html#ac0d4eebf4260895ff27ba5ab482aa3d6">attribCubeVertexCoordinates</a>,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a4c57e0aed74fca370d0509d7819e0b71">NUMBER_OF_COMPONENTS_PER_VERTEX</a>,</div>
<div class="line">                                   GL_FLOAT,</div>
<div class="line">                                   GL_FALSE,</div>
<div class="line">                                   0,</div>
<div class="line">                                   NULL) );</div>
</div><!-- fragment --><p> When this is ready, we have to enable vertex attrib array.</p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2c951a451ea9bfb73fe3f756ad261322">sceneRenderingProgramLocations</a>.<a class="code" href="struct_scene_rendering_program_locations.html#ac0d4eebf4260895ff27ba5ab482aa3d6">attribCubeVertexCoordinates</a>) );</div>
</div><!-- fragment --><p> We are now ready to draw multiple instanced of the same object. We use a special function for that, which is <b>glDrawArraysInstanced()</b></p>
<div class="fragment"><div class="line">        <span class="comment">/* Draw scene. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES,</div>
<div class="line">                                       0,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2a5b4255b941236cc08b49e36794f3b2">nOfCubeCoordinates</a>,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>) );</div>
</div><!-- fragment --><p> We wanted the cubes to be arranged in 5x5 two-dimensional array. We have to calculate location for each cube. This is done in <em><a class="el" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a1a1ce8f8840ce8299b2b4a4e7104cf1b" title="Calculate the world space locations of all the cubes that we will be rendering. The cubes are arrange...">getCubeLocations()</a></em> function. </p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>* <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a1a1ce8f8840ce8299b2b4a4e7104cf1b">getCubeLocations</a>(GLint   numberOfColumns,</div>
<div class="line">                                 GLint   numberOfRows,</div>
<div class="line">                                 <a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> cubeScalar,</div>
<div class="line">                                 <a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> distanceBetweenCubes,</div>
<div class="line">                                 GLint*  numberOfCubeLocationCoordinatesPtr)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(numberOfCubeLocationCoordinatesPtr != NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#a744fbed01658cb96bb8ba7e85a86d1dc">distance</a>                 = distanceBetweenCubes + 2 * cubeScalar; <span class="comment">/* A single cube spreads out from</span></div>
<div class="line"><span class="comment">                                                                                   * &lt;-cubeScalar, -cubeScalar, -cubeScalar&gt; to</span></div>
<div class="line"><span class="comment">                                                                                   * &lt;cubeScalar,   cubeScalar,  cubeScalar&gt;,</span></div>
<div class="line"><span class="comment">                                                                                   * with &lt;0, 0, 0&gt; representing the center of the cube.</span></div>
<div class="line"><span class="comment">                                                                                   * We have to enlarge the requested distance between cubes</span></div>
<div class="line"><span class="comment">                                                                                   * (2 * cubeScalar) times. */</span></div>
<div class="line">    <span class="keywordtype">int</span>         <a class="code" href="gl2ext_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a>                           = 0;</div>
<div class="line">    <span class="keywordtype">int</span>         numberOfCubeLocationCoordinates = 0;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>   numberOfPointCoordinates        = 2;</div>
<div class="line">    <a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>*    result                          = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> xStart                          = -( <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>(numberOfColumns - 1) / 2.0f * <a class="code" href="gl2ext_8h.html#a744fbed01658cb96bb8ba7e85a86d1dc">distance</a>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> yStart                          = -( <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>(numberOfRows    - 1) / 2.0f * <a class="code" href="gl2ext_8h.html#a744fbed01658cb96bb8ba7e85a86d1dc">distance</a>);</div>
<div class="line"></div>
<div class="line">    numberOfCubeLocationCoordinates = numberOfPointCoordinates * numberOfColumns * numberOfRows;</div>
<div class="line">    result                          = (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>*) malloc(numberOfCubeLocationCoordinates * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Make sure memory allocation succeeded. */</span></div>
<div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(result != NULL);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rowIndex = 0; rowIndex &lt; numberOfRows; rowIndex++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> columnIndex = 0; columnIndex &lt; numberOfColumns; columnIndex++)</div>
<div class="line">        {</div>
<div class="line">            result[index++] = xStart + (rowIndex    * <a class="code" href="gl2ext_8h.html#a744fbed01658cb96bb8ba7e85a86d1dc">distance</a>);</div>
<div class="line">            result[index++] = yStart + (columnIndex * <a class="code" href="gl2ext_8h.html#a744fbed01658cb96bb8ba7e85a86d1dc">distance</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    *numberOfCubeLocationCoordinatesPtr = numberOfCubeLocationCoordinates;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The result is then passed to uniform buffer object </p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate uniform buffer object and fill it with cube positions data. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1,</div>
<div class="line">                         &amp;<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#a591a999425ea75b2de187dddbf5e0026">bufferObjectIdElementLocations</a>) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_UNIFORM_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#a591a999425ea75b2de187dddbf5e0026">bufferObjectIdElementLocations</a>) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_UNIFORM_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ae916c828c0fb47a3e41dd8aa644f05eb">nOfCubeLocations</a> * <span class="keyword">sizeof</span> (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div>
<div class="line">                          <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a45e7b5d4466daf67137459177c4c6fe7">cubeLocations</a>,</div>
<div class="line">                          GL_STATIC_DRAW) );</div>
</div><!-- fragment --><p> Which is then used as a source for program uniform block data. In one of the next steps we will describe what the <em>sceneRenderingProgramLocationsPtr-&gt;uniformBlockCubeProperties</em> stands for, so don't worry about it now (it will be described in <a class="el" href="bloom.html#bloomInstancedDrawingShaderObjects">Shader Objects used for Instanced Drawing</a>). </p>
<div class="fragment"><div class="line">        <span class="comment">/* Cube locations are constant during rendering process. Set them now. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformBlockBinding(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a411a0822b291b71c7f46addf3b0907ec">sceneRenderingProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2c951a451ea9bfb73fe3f756ad261322">sceneRenderingProgramLocations</a>.<a class="code" href="struct_scene_rendering_program_locations.html#a3889f07fa6deef4637ee09d0b2efddb4">uniformBlockCubeProperties</a>,</div>
<div class="line">                                       0 ) );</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBufferBase     (GL_UNIFORM_BUFFER,</div>
<div class="line">                                       0,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#a591a999425ea75b2de187dddbf5e0026">bufferObjectIdElementLocations</a>) );</div>
</div><!-- fragment --> <h2><a class="anchor" id="bloomInstancedDrawingShaderObjects"></a>
Shader Objects used for Instanced Drawing</h2>
<p>Let's focus on a program object now. It is assumed that you understand the mechanism of preparing and using program objects. If not, please refer to previous tutorials.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader source: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define NUMBER_OF_CUBES (25)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> is_diagonal_cube[<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>] = <span class="keywordtype">int</span>[<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>](1, 0, 0, 0, 1,</div>
<div class="line">                                                                   0, 1, 0, 1, 0,</div>
<div class="line">                                                                   0, 0, 1, 0, 0,</div>
<div class="line">                                                                   0, 1, 0, 1, 0,</div>
<div class="line">                                                                   1, 0, 0, 0, 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* UNIFORMS */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> mv_matrix;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> <a class="code" href="jni_2_astc_textures_8cpp.html#a54e924144690012ede2106830a396b7b">mvp_matrix</a>;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a>      cube_properties</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec2.html">vec2</a> locations[<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>];</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* ATTRIBUTES */</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> cube_vertex_coordinates;</div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> cube_vertex_normals;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line">    out <a class="code" href="structvec3.html">vec3</a> normal;</div>
<div class="line">    out <a class="code" href="structvec4.html">vec4</a> vertex;</div>
<div class="line">flat out <span class="keywordtype">int</span>  is_cube_placed_on_diagonal;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Prepare translation matrix. */</span></div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> cube_location_matrix = <a class="code" href="structmat4.html">mat4</a>(1.0,                        0.0,                        0.0, 0.0,</div>
<div class="line">                                     0.0,                        1.0,                        0.0, 0.0,</div>
<div class="line">                                     0.0,                        0.0,                        1.0, 0.0,</div>
<div class="line">                                     locations[gl_InstanceID].<a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>, locations[gl_InstanceID].<a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>, 0.0, 1.0);</div>
<div class="line">    <span class="comment">/* Calculate matrices. */</span></div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> <a class="code" href="jni_2_astc_textures_8cpp.html#aa88c5b29b11317adcfa307c8870c41ce">model_view_matrix</a>            = mv_matrix  * cube_location_matrix;</div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> model_view_projection_matrix = mvp_matrix * cube_location_matrix;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Set output values. */</span></div>
<div class="line">    is_cube_placed_on_diagonal = is_diagonal_cube[gl_InstanceID];</div>
<div class="line">    normal                     = <a class="code" href="structvec3.html">vec3</a>(model_view_matrix * <a class="code" href="structvec4.html">vec4</a>(cube_vertex_normals, 0.0)).xyz;</div>
<div class="line">    vertex                     = model_view_matrix * <a class="code" href="structvec4.html">vec4</a>(cube_vertex_coordinates, 1.0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Set vertex position in NDC space. */</span></div>
<div class="line">    gl_Position = model_view_projection_matrix * <a class="code" href="structvec4.html">vec4</a>(cube_vertex_coordinates, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, in the vertex shader we are using <b>cube_vertex_coordinates</b> attribute. And it's location should be used as the first argument in <em>glVertexAttribPointer()</em> described in one of the previous steps.</p>
<p>To get the attribute location it is enough to call: </p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;attribCubeVertexCoordinates                 = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetAttribLocation   (programObjectId,</div>
<div class="line">                                                                                                       <span class="stringliteral">&quot;cube_vertex_coordinates&quot;</span>) );</div>
</div><!-- fragment --><p> There is also a uniform block used (<b>cube_properties</b>). It's location should be used as a second argument in <b>glUniformBlockBinding()</b> described in one of the previous steps.</p>
<p>To get the uniform block location, it is enough to call: </p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;uniformBlockCubeProperties                  = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformBlockIndex(programObjectId,</div>
<div class="line">                                                                                                       <span class="stringliteral">&quot;cube_properties&quot;</span>) );</div>
</div><!-- fragment --><p> In the shader we have information about each cube location. According to the <em>OpenGL ES Shading Language specification</em>, the variable <em>gl_InstanceID</em> is <b>a vertex shader input variable that holds the instance number of the current primitive in an instanced draw call</b>. We are using this variable to refer to required element of our <b>locations</b> array stored in uniform block. This information is then used to prepare translation matrix which is then used for setting vertices in NDC space.</p>
<p>Fragment shader source: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision lowp <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define EPSILON (0.00001)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">struct </span>_light_properties</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  ambient;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  color;</div>
<div class="line">    <span class="keywordtype">float</span> constant_attenuation;</div>
<div class="line">    <span class="keywordtype">float</span> linear_attenuation;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  position;</div>
<div class="line">    <span class="keywordtype">float</span> quadratic_attenauation;</div>
<div class="line">    <span class="keywordtype">float</span> shininess;</div>
<div class="line">    <span class="keywordtype">float</span> strength;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* UNIFORMS */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec3.html">vec3</a>              camera_position;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> _light_properties light_properties;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* INPUTS */</span></div>
<div class="line">    in <a class="code" href="structvec3.html">vec3</a> normal;</div>
<div class="line">    in <a class="code" href="structvec4.html">vec4</a> vertex;</div>
<div class="line">flat in <span class="keywordtype">int</span>  is_cube_placed_on_diagonal;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line"><span class="comment">/* Stores color data of cubes that should not be bloomed.*/</span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(<a class="code" href="gl2ext_8h.html#a6f0165ed903f22b8bb600c3e0b628e73">location</a> = 0) out <a class="code" href="structvec4.html">vec4</a> normal_scene_color;</div>
<div class="line"><span class="comment">/* Stores color data of cubes we want bloomed. */</span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(<a class="code" href="gl2ext_8h.html#a6f0165ed903f22b8bb600c3e0b628e73">location</a> = 1) out <a class="code" href="structvec4.html">vec4</a> bloom_element_color;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> vertex_color        = <a class="code" href="structvec4.html">vec4</a>(0.2, 0.4, 0.8, 1.0); <span class="comment">/* Each cube will have the same colour. */</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  normalized_normals = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(normal);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  light_direction    = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="structvec3.html">vec3</a>(light_properties.position - vertex.xyz));</div>
<div class="line">    <span class="keywordtype">float</span> attenuation        = 1.0 / (light_properties.constant_attenuation + (light_properties.linear_attenuation + light_properties.quadratic_attenauation));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  camera_direction   = camera_position - <a class="code" href="structvec3.html">vec3</a>(vertex);</div>
<div class="line">    <span class="keywordtype">float</span> diffuse            = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(0.0, dot(normalized_normals, light_direction));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  half_vector        = <a class="code" href="_compute_particles_2jni_2common_2matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(light_direction + camera_direction);</div>
<div class="line">    <span class="keywordtype">float</span> specular           = 0.0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (abs(diffuse - 0.0) &gt; EPSILON)</div>
<div class="line">    {</div>
<div class="line">        specular = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(0.0, dot(half_vector, normal));</div>
<div class="line">        specular = pow(specular, light_properties.shininess) * light_properties.strength;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> scattered_light  = light_properties.ambient * attenuation + diffuse * attenuation * light_properties.color;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> reflected_light  = light_properties.color   * specular              * attenuation;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> calculated_color = <a class="code" href="noise_8cpp.html#ad601cfd7a14298c6bba5e0cad4c640c7">min</a>(vertex_color.<a class="code" href="structvec4.html#a7393f7525715d33e4dc5b79ebeb275fb">xyz</a>     * scattered_light       + reflected_light, <a class="code" href="structvec3.html">vec3</a>(1.0) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Set output variables. */</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> color_to_be_returned = <a class="code" href="structvec4.html">vec4</a>(calculated_color, 1.0);</div>
<div class="line"></div>
<div class="line">    normal_scene_color  = <a class="code" href="structvec4.html">vec4</a>(0.0);</div>
<div class="line">    bloom_element_color = <a class="code" href="structvec4.html">vec4</a>(0.0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* If we are dealing with a cube placed on a diagonal, use white colour.</span></div>
<div class="line"><span class="comment">    * Otherwise, we want to output a regular cube (which means the previously</span></div>
<div class="line"><span class="comment">    * calculated cube colour with lighting applied). */</span></div>
<div class="line">    <span class="keywordflow">if</span> (is_cube_placed_on_diagonal == 1)</div>
<div class="line">    {</div>
<div class="line">        bloom_element_color = <a class="code" href="structvec4.html">vec4</a>(1.0, 1.0, 1.0, 1.0);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        normal_scene_color = color_to_be_returned;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the fragment shader there are some colours calculations implemented which stand for applying lighting effect. For more details, please read <a class="el" href="lighting.html">Lighting</a>.</p>
<p>More details connected with the shader implementations will be described later (in <a class="el" href="bloom.html#bloomRenderingSceneToTexture">Rendering Scene to Texture</a>).</p>
<h1><a class="anchor" id="bloomRenderingSceneToTexture"></a>
Rendering Scene to Texture</h1>
<p>In the application we are using rendering into texture mechanism many times, but let's explain this using a single case only.</p>
<p>If we want our scene to be render into a texture, we should do as follows:</p>
<p>Generate a framebuffer and a texture objects. Do not forget about setting proper parameters for those objects. We want to have only one output from the shader object (a colour scene with blue and white cubes). We need a depth texture as well, because the scene is lit by a directional light and depth values will be used for light calculations.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate objects. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenFramebuffers(1,</div>
<div class="line">                               framebufferObjectIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures    (1,</div>
<div class="line">                               originalTextureObjectIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures    (1,</div>
<div class="line">                               depthToIdPtr) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Bind generated framebuffer and texture objects to specific binding points. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_FRAMEBUFFER,</div>
<div class="line">                              *framebufferObjectIdPtr) );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                            *originalTextureObjectIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexImage2D   (GL_TEXTURE_2D,</div>
<div class="line">                             0,</div>
<div class="line">                             GL_RGBA8,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>,</div>
<div class="line">                             0,</div>
<div class="line">                             GL_RGBA,</div>
<div class="line">                             GL_UNSIGNED_BYTE,</div>
<div class="line">                             NULL) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_S,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_T,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MAG_FILTER,</div>
<div class="line">                             GL_LINEAR) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MIN_FILTER,</div>
<div class="line">                             GL_LINEAR) );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                            *depthToIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexImage2D   (GL_TEXTURE_2D,</div>
<div class="line">                             0,</div>
<div class="line">                             GL_DEPTH_COMPONENT32F,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>,</div>
<div class="line">                             0,</div>
<div class="line">                             GL_DEPTH_COMPONENT,</div>
<div class="line">                             GL_FLOAT,</div>
<div class="line">                             NULL) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MIN_FILTER,</div>
<div class="line">                             GL_NEAREST) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MAG_FILTER,</div>
<div class="line">                             GL_NEAREST) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_S,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_T,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
</div><!-- fragment --><p> The next step is to attach generated texture objects to the framebuffer object at specific binding points.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Bind colour and depth textures to framebuffer object. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_FRAMEBUFFER,</div>
<div class="line">                                    GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                    GL_TEXTURE_2D,</div>
<div class="line">                                   *originalTextureObjectIdPtr,</div>
<div class="line">                                    0) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_FRAMEBUFFER,</div>
<div class="line">                                    GL_DEPTH_ATTACHMENT,</div>
<div class="line">                                    GL_TEXTURE_2D,</div>
<div class="line">                                   *depthToIdPtr,</div>
<div class="line">                                    0) );</div>
</div><!-- fragment --><p> There is only one thing remaining: the actual rendering.</p>
<p>Rendering into texture objects is achieved by binding the framebuffer object to to the GL_DRAW_FRAMEBUFFER framebuffer binding point (using <b>glBindFramebuffer()</b> function). Rendering into back buffer (the output will be visible on a screen) can be done only if default framebuffer object (ID = 0) is bound.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Render scene.</span></div>
<div class="line"><span class="comment">    *  The scene is rendered to two render targets:</span></div>
<div class="line"><span class="comment">    *  - 1. First texture will store color data;</span></div>
<div class="line"><span class="comment">    *  - 2. Second texture will store color data, but only for the cubes that should be</span></div>
<div class="line"><span class="comment">    *       affected by the bloom operation (remaining objects will not be rendered).</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a411a0822b291b71c7f46addf3b0907ec">sceneRenderingProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>) );</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Bind a framebuffer object to the GL_DRAW_FRAMEBUFFER framebuffer binding point,</span></div>
<div class="line"><span class="comment">        * so that everything we render will end up in the FBO&#39;s attachments. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7794ff2cbede59beba1f39254cbef5da">sceneRenderingObjects</a>.<a class="code" href="struct_scene_rendering_objects.html#a070f7902b2c9ad93af5afe9de7ff6d4d">framebufferObjectId</a>) );</div>
<div class="line">        <span class="comment">/* Set the viewport for the whole screen size. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0,</div>
<div class="line">                            0,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>) );</div>
<div class="line">        <span class="comment">/* Clear the framebuffer&#39;s content. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) );</div>
<div class="line">        <span class="comment">/* [Instanced drawing] */</span></div>
<div class="line">        <span class="comment">/* Draw scene. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES,</div>
<div class="line">                                       0,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2a5b4255b941236cc08b49e36794f3b2">nOfCubeCoordinates</a>,</div>
<div class="line">                                       <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>) );</div>
<div class="line">        <span class="comment">/* [Instanced drawing] */</span></div>
<div class="line">    }</div>
</div><!-- fragment --> <h1><a class="anchor" id="bloomRenderingTextureOnScreen"></a>
Rendering Texture on Screen</h1>
<p>This section describes how to render a texture into the screen. In this sample we are using more advanced texture rendering, but let us describe the problem from the beginning.</p>
<p>The first thing you need to do is to create a program object with shaders attached, which is then linked and used (at this point we are sure you know how to do that, if not, please read previous tutorials).</p>
<p>What you will need as well is a texture object filled with data (you can get this one, for instance, by steps described in <a class="el" href="bloom.html#bloomRenderingSceneToTexture">Rendering Scene to Texture</a>). Let's assume that <b>textureID</b> refers to that texture object and <b>textureUnit</b> refers to the texture unit which you want to use as a binding point. This texture has to be bound to GL_TEXTURE_2D target at specific binding point.</p>
<div class="fragment"><div class="line">glActiveTexture(GL_TEXTURE0 + textureUnit); <span class="comment">/* textureUnit has to be a value from a range [0, GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1] */</span></div>
<div class="line">glBindTexture(GL_TEXTURE_2D, <a class="code" href="_e_t_c_atlas_alpha_8cpp.html#a160ac41148eb5e30fbb1494de178a550">textureID</a>);</div>
</div><!-- fragment --><p>You can skip the selecting active texture unit part, if you want to use the default one.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader source:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"><span class="comment">/* GL_TRIANGLE_FAN-type quad vertex data. */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structvec4.html">vec4</a> vertex_positions[4] = <a class="code" href="structvec4.html">vec4</a>[4](<a class="code" href="structvec4.html">vec4</a>( 1.0, -1.0, 0.0, 1.0),</div>
<div class="line">                                         <a class="code" href="structvec4.html">vec4</a>(-1.0, -1.0, 0.0, 1.0),</div>
<div class="line">                                         <a class="code" href="structvec4.html">vec4</a>(-1.0,  1.0, 0.0, 1.0),</div>
<div class="line">                                         <a class="code" href="structvec4.html">vec4</a>( 1.0,  1.0, 0.0, 1.0) );</div>
<div class="line"><span class="comment">/* Texture UVs. */</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="structvec2.html">vec2</a> texture_uv[4]       = <a class="code" href="structvec2.html">vec2</a>[4](<a class="code" href="structvec2.html">vec2</a>(1.0, 0.0),</div>
<div class="line">                                         <a class="code" href="structvec2.html">vec2</a>(0.0, 0.0),</div>
<div class="line">                                         <a class="code" href="structvec2.html">vec2</a>(0.0, 1.0),</div>
<div class="line">                                         <a class="code" href="structvec2.html">vec2</a>(1.0, 1.0) );</div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line">out <a class="code" href="structvec2.html">vec2</a> texture_coordinates;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Return vertex coordinates. */</span></div>
<div class="line">    gl_Position         = vertex_positions[gl_VertexID];</div>
<div class="line">    <span class="comment">/* Pass texture coordinated to fragment shader. */</span></div>
<div class="line">    texture_coordinates = texture_uv[gl_VertexID];</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see, we are using <em>GL_TRIANGLE_FAN-type quad</em> vertex data. This is important, as based on that we have to use corresponding mode for OpenGL ES draw function.</p>
<p>Fragment shader source:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"><span class="comment">/* UNIFORMS */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D sample_texture;</div>
<div class="line"><span class="comment">/* INPUTS */</span></div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> texture_coordinates;</div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> color;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Return colour. */</span></div>
<div class="line">    color = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(sample_texture, texture_coordinates);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's assume that <b>programID</b> is the program object ID you have created and linked (with shader objects attached which are described above).</p>
<div class="fragment"><div class="line"><span class="comment">/* Set active program. */</span></div>
<div class="line">glUseProgram(<a class="code" href="_anti_alias_8cpp.html#a391fd187e1c163e1bc7dc26a34c402f2">programID</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Get texture sample uniform location. */</span></div>
<div class="line">GLint sampleTextureUniformLocation = glGetUniformLocation(<a class="code" href="_anti_alias_8cpp.html#a391fd187e1c163e1bc7dc26a34c402f2">programID</a>, <span class="stringliteral">&quot;sample_texture&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Set uniform value. */</span></div>
<div class="line">glUniform1i(sampleTextureUniformLocation, textureUnit);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Bind default framebuffer object. */</span></div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Draw texture on a screen. */</span></div>
<div class="line">glDrawArrays(GL_TRIANGLE_FAN, 0, 4);</div>
</div><!-- fragment --><p>This is important that default framebuffer object is used (thanks to which the rendering result will be displayed on a screen). This is why we are calling <b>glBindFramebuffer()</b> function, but this is not obligatory as present by default. You can skip this line if you are not using any framebuffer objects.</p>
<p>You can skip the line with setting uniform value as well in case a GL_TEXTURE0 is used, as this is present by default. If you want to use any other binding point, then this line is essential, as it points which texture object should be rendered.</p>
<h1><a class="anchor" id="bloomPrepareSceneThatWillBeBloomed"></a>
Prepare Scene That Will Be Bloomed</h1>
<p>We have already described, how to render a scene into texture. Right now, we should have a texture containing colour scene data, which in our case is 5x5 array consist of blue and white cubes.</p>
<p>What we want to achieve at this point is to select all the fragments from this image which we want to be bloomed. We want to bloom only the brighter cubes. We are using program object to help us with selecting those elements.</p>
<p>If we use our colour scene texture as an input for this shader object, we can sample it and check the luminance of each fragment. If it is higher than a specific value, the original fragment colour will be stored, otherwise we will store the black colour value. The texture object where those results are stored can be then used as an input for blooming algorithms.</p>
<p>The fragment shader source</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a90ba40e4beb425a741b5ac5430f1d723">getLuminanceImageFragmentShaderSource</a>[] = <span class="stringliteral">&quot;#version 300 es\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;precision highp float;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;/* UNIFORMS */\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;uniform sampler2D texture_sampler;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;/* INPUTS */\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;in vec2 texture_coordinates;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;/* OUTPUTS */\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;out vec4 scene_color;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;#define MIN_LUMINANCE (0.9)\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;void main()\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    vec4  sample_color = texture(texture_sampler, texture_coordinates);\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    float luminance    = 0.2125 * sample_color.x +\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;                         0.7154 * sample_color.y +\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;                         0.0721 * sample_color.z;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    if (luminance &gt; MIN_LUMINANCE)\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    {\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;        scene_color = sample_color;\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    }\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    else\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    {\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;        scene_color =  vec4(0.0);\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;    }\n&quot;</span></div>
<div class="line">                                                            <span class="stringliteral">&quot;}&quot;</span>;</div>
</div><!-- fragment --><p> The vertex shader source is the same as already described in <a class="el" href="bloom.html#bloomRenderingTextureOnScreen">Rendering Texture on Screen</a></p>
<p>We would like the texture that will be then bloomed to be a little bit smaller (so that the bloom algorithm will be more efficient). And this is why we need to prepare the dowscaled texture storage and update viewport.</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ae04fd6c5582c6d345009a014ec6ac29d">generateDownscaledObjects</a>(<a class="code" href="gl2ext_8h.html#adda687347282e5405e89b4fc19a1f8e2">GLuint</a>* fboIdPtr,</div>
<div class="line">                                      <a class="code" href="gl2ext_8h.html#adda687347282e5405e89b4fc19a1f8e2">GLuint</a>* toIdPtr)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(fboIdPtr != NULL);</div>
<div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(toIdPtr  != NULL);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Generate objects. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenFramebuffers(1,</div>
<div class="line">                               fboIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures    (1,</div>
<div class="line">                               toIdPtr) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Set texture parameters. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                            *toIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage2D (GL_TEXTURE_2D,</div>
<div class="line">                             1,</div>
<div class="line">                             GL_RGBA8,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>   / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>,</div>
<div class="line">                             <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a> / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_S,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_T,</div>
<div class="line">                             GL_CLAMP_TO_EDGE) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MAG_FILTER,</div>
<div class="line">                             GL_LINEAR) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MIN_FILTER,</div>
<div class="line">                             GL_LINEAR) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Make framebuffer object active and bind texture object to it. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer     (GL_FRAMEBUFFER,</div>
<div class="line">                                   *fboIdPtr) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                    GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                    GL_TEXTURE_2D,</div>
<div class="line">                                   *toIdPtr,</div>
<div class="line">                                    0) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Restore default bindings. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_FRAMEBUFFER,</div>
<div class="line">                               0) );</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture    (GL_TEXTURE_2D,</div>
<div class="line">                               0) );</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Get the luminance image, store it in the downscaled texture. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#af60cc369d26776d32ab2013c6a1fe3f9">getLuminanceImageProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>));</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ab4b4481b303d14b09c998bc0a3a8dfb3">getLuminanceImageBloomObjects</a>.<a class="code" href="struct_get_luminance_image_bloom_objects.html#a77f88e0e5312e2553388f21820b0cc8e">framebufferObjectId</a>));</div>
<div class="line">        <span class="comment">/* Set the viewport for the whole screen size. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0,</div>
<div class="line">                            0,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>  / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a> / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>) );</div>
<div class="line">        <span class="comment">/* Clear the framebuffer&#39;s content. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) );</div>
<div class="line">        <span class="comment">/* Draw texture. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLE_FAN, 0, 4) );</div>
<div class="line">    }</div>
</div><!-- fragment --> <div class="image">
<img src="Bloom_normal_scene.png" alt="Bloom_normal_scene.png"/>
<div class="caption">
Colour scene shader output</div></div>
<div class="image">
<img src="Bloom_cubes_to_be_bloomed.png" alt="Bloom_cubes_to_be_bloomed.png"/>
<div class="caption">
Elements that should be bloomed</div></div>
<p> The downscaled texture with white cubes will be used as an input for the next operations.</p>
<h1><a class="anchor" id="bloomBlurring"></a>
Blurring</h1>
<p>The blur effect is applied in two main steps:</p>
<ol type="1">
<li>Horizontal Blur</li>
<li>Vertical Blur</li>
</ol>
<p>The fragment shader source for blur shader (horizontal blur):</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a9e346b8e94125335a4e8992a603bc248">blurHorizontalFragmentShaderSource</a>[] = <span class="stringliteral">&quot;#version 300 es\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;precision mediump float;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/** Defines gaussian weights. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;const float gaussian_weights[] = float[] (0.2270270270,\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                                          0.3162162162,\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                                          0.0702702703);\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/* UNIFORMS */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/** Radius of a blur effect to be applied. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;uniform float     blur_radius;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/** Texture sampler on which the effect will be applied. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;uniform sampler2D texture_sampler;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/* INPUTS */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/** Texture coordinates. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;in vec2 texture_coordinates;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/* OUTPUTS */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;/** Fragment colour that will be returned. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;out vec4 output_color;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;void main()\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    vec4  total_color      = vec4(0.0);\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    float image_resolution = float((textureSize(texture_sampler, 0)).x);\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    float blur_step        = blur_radius / image_resolution;\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    /* Calculate blurred colour. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    /* Blur a texel on the right. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    total_color = texture(texture_sampler, vec2(texture_coordinates.x + 1.0 * blur_step, texture_coordinates.y)) * gaussian_weights[0] +\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                  texture(texture_sampler, vec2(texture_coordinates.x + 2.0 * blur_step, texture_coordinates.y)) * gaussian_weights[1] +\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                  texture(texture_sampler, vec2(texture_coordinates.x + 3.0 * blur_step, texture_coordinates.y)) * gaussian_weights[2];\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    /* Blur a texel on the left. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    total_color += texture(texture_sampler, vec2(texture_coordinates.x - 1.0 * blur_step, texture_coordinates.y)) * gaussian_weights[0] +\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                   texture(texture_sampler, vec2(texture_coordinates.x - 2.0 * blur_step, texture_coordinates.y)) * gaussian_weights[1] +\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;                   texture(texture_sampler, vec2(texture_coordinates.x - 3.0 * blur_step, texture_coordinates.y)) * gaussian_weights[2];\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    /* Set the output colour. */\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;    output_color = vec4(total_color.xyz, 1.0);\n&quot;</span></div>
<div class="line">                                                         <span class="stringliteral">&quot;}&quot;</span>;</div>
</div><!-- fragment --><p> The fragment shader source for blur shader (vertical blur):</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a73ede4b00562f7fa069f331b27caba03">blurVerticalFragmentShaderSource</a>[] =  <span class="stringliteral">&quot;#version 300 es\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;precision mediump float;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/** Defines gaussian weights. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;const float gaussian_weights[] = float[] (0.2270270270,\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                                          0.3162162162,\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                                          0.0702702703);\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/* UNIFORMS */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/** Radius of a blur effect to be applied. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;uniform float     blur_radius;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/** Texture sampler on which the effect will be applied. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;uniform sampler2D texture_sampler;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/* INPUTS */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/** Texture coordinates. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;in vec2 texture_coordinates;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/* OUTPUTS */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;/** Fragment colour that will be returned. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;out vec4 output_color;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;void main()\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;{\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    vec4  total_color      = vec4(0.0);\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    float image_resolution = float((textureSize(texture_sampler, 0)).y);\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    float blur_step        = blur_radius / image_resolution;\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    /* Calculate blurred colour. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    /* Blur a texel to the top. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    total_color = texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y + 1.0 * blur_step)) * gaussian_weights[0] +\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                  texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y + 2.0 * blur_step)) * gaussian_weights[1] +\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                  texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y + 3.0 * blur_step)) * gaussian_weights[2];\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    /* Blur a texel to the bottom. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    total_color += texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y - 1.0 * blur_step)) * gaussian_weights[0] +\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                   texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y - 2.0 * blur_step)) * gaussian_weights[1] +\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;                   texture(texture_sampler, vec2(texture_coordinates.x, texture_coordinates.y - 3.0 * blur_step)) * gaussian_weights[2];\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    /* Set the output colour. */\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;    output_color = vec4(total_color.xyz, 1.0);\n&quot;</span></div>
<div class="line">                                                        <span class="stringliteral">&quot;}&quot;</span>;</div>
</div><!-- fragment --><p> The main idea behind applying the blur effect is that for each texel its colour is spread on each side (left/bottom and right/up) with a specific weight (according to Gaussian weights stands for the normal distribution in statistics). This is done with a respect that the further from the kernel (the texel which is currently blurred) the lower impact on a fragment colour it has.</p>
<p>In the first pass, we are applying a horizontal blur. Once this is ready, we use the result to apply vertical blur as well. The process is shown on the schema.</p>
<div class="image">
<img src="Bloom_blur_schema.png" alt="Bloom_blur_schema.png"/>
<div class="caption">
Blur schema</div></div>
<p> The blur effect is ready, however the result is rather weak, comparable to the first screen shown in <a class="el" href="bloom.html#bloomOverview">Overview</a>. To make it stronger we are applying the blur effect multiple times (the number of blurring operations is changing during rendering process). In the code presented below you can see, that the total blur effect is stored in two texture objects (the results of last and last but one iterations are stored in two different textures). The reason of this approach will be explained in <a class="el" href="bloom.html#bloomBlending">Blending</a>.</p>
<p>The important thing here is that the source texture of horizontal blur is changing. In the first operation we are using the downscaled texture which elements should be bloomed (the result described in <a class="el" href="bloom.html#bloomPrepareSceneThatWillBeBloomed">Prepare Scene That Will Be Bloomed</a>). The source texture for (n-th) operation is the blur result of (n-th - 1) operation. Thanks to that, the texture which has already been blurred, is blurred again, so the total effect is much stronger.</p>
<div class="fragment"><div class="line">        <span class="comment">/* Apply the blur effect.</span></div>
<div class="line"><span class="comment">        * The blur effect is applied in two basic steps (note that lower resolution textures are used).</span></div>
<div class="line"><span class="comment">        *   a. First, we blur the downscaled bloom texture horizontally.</span></div>
<div class="line"><span class="comment">        *   b. The result of horizontal blurring is then used for vertical blurring.</span></div>
<div class="line"><span class="comment">        *      The result texture contains image blrured in both directions.</span></div>
<div class="line"><span class="comment">        *   c. To amplify the blur effect, steps (a) and (b) are applied multiple times</span></div>
<div class="line"><span class="comment">        *      (with an exception that we now use the resulting blurred texture from the previous pass</span></div>
<div class="line"><span class="comment">        *       as an input to the horizontal blurring pass).</span></div>
<div class="line"><span class="comment">        *   d. The result of last iteration of applying the total blur effect (which is the result after the vertical blur is applied)</span></div>
<div class="line"><span class="comment">        *      is stored in a separate texture. Thanks to that, we have the last and previous blur result textures,</span></div>
<div class="line"><span class="comment">        *      both of which will be then used for continuous sampling (for the blending pass).</span></div>
<div class="line"><span class="comment">        *</span></div>
<div class="line"><span class="comment">        */</span></div>
<div class="line">        <span class="comment">/* Bind a framebuffer object to the GL_DRAW_FRAMEBUFFER framebuffer binding point,</span></div>
<div class="line"><span class="comment">        * so that everything we render will end up in the FBO&#39;s attachments. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#aa834665bb6d6f6ba6c9c536d3877d05b">blurringObjects</a>.<a class="code" href="struct_blurring_objects.html#a13e1965adaadce76a07021b95e9b536a">framebufferObjectId</a>) );</div>
<div class="line">        <span class="comment">/* Set the lower viewport resolution. It corresponds to size of the texture we will be rendering to. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0,</div>
<div class="line">                            0,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>  / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>,</div>
<div class="line">                            <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a> / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0b1bbabcbafb9ac6360181b2e38077a7">WINDOW_RESOLUTION_DIVISOR</a>) );</div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnable  (GL_SCISSOR_TEST) );</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Apply the blur effect multiple times. */</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> blurIterationIndex = 0;</div>
<div class="line">                 blurIterationIndex &lt; currentNumberOfIterations;</div>
<div class="line">                 blurIterationIndex++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">/* FIRST PASS - HORIZONTAL BLUR</span></div>
<div class="line"><span class="comment">             * Take the texture showing cubes which should be bloomed and apply a horizontal blur operation.</span></div>
<div class="line"><span class="comment">             */</span></div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ac48b26649eb6795960d14d3910d87274">blurringHorizontalProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>) );</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">/* Attach the texture we want the color data to be rendered to the current draw framebuffer.*/</span></div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                                GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                                GL_TEXTURE_2D,</div>
<div class="line">                                                <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#aa834665bb6d6f6ba6c9c536d3877d05b">blurringObjects</a>.<a class="code" href="struct_blurring_objects.html#a7eaab62b9299f271afdb2772822391bc">textureObjectIdHorizontal</a>,</div>
<div class="line">                                                0) );</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* In first iteration we have to take the texture which shows the cubes we want blurred.</span></div>
<div class="line"><span class="comment">                * Later, we have to take the same texture that has already been blurred vertically. */</span></div>
<div class="line">                <span class="keywordflow">if</span> (blurIterationIndex == 0)</div>
<div class="line">                {</div>
<div class="line">                    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a89fa26ec41cc1ab6d9a5cf3a265bc131">blurringHorizontalProgramLocations</a>.<a class="code" href="struct_blurring_program_locations.html#a927a36db6d46279bef56e447d1543f43">uniformTextureSampler</a>,</div>
<div class="line">                                        <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ac0af37c26160838b3bec20df2ddaa8fa">TEXTURE_UNIT_BLOOM_SOURCE_TEXTURE</a>) );</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a89fa26ec41cc1ab6d9a5cf3a265bc131">blurringHorizontalProgramLocations</a>.<a class="code" href="struct_blurring_program_locations.html#a927a36db6d46279bef56e447d1543f43">uniformTextureSampler</a>,</div>
<div class="line">                                        <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#aad55b0ad7cae8b337a5277d46b3e99e9">TEXTURE_UNIT_BLURRED_TEXTURE</a>) );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* Draw texture. */</span></div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLE_FAN, 0, 4) );</div>
<div class="line">            } <span class="comment">/* FIRST PASS - HORIZONTAL BLUR */</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">/* SECOND PASS - VERTICAL BLUR</span></div>
<div class="line"><span class="comment">            * Take the result of the previous pass (horizontal blur) and apply a vertical blur to this texture.</span></div>
<div class="line"><span class="comment">            */</span></div>
<div class="line">            <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#aa5830025c568678a70a59d2e77995dff">blurringVerticalProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>) );</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (blurIterationIndex == currentNumberOfIterations - 1)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">/* In case of the last iteration, use a different framebuffer object.</span></div>
<div class="line"><span class="comment">                     * The rendering results will be written to the only color attachment of the fbo. */</span></div>
<div class="line">                    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                               <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a555bcfb3e641d000bfd57f13a62292f9">strongerBlurObjects</a>.<a class="code" href="struct_stronger_blur_objects.html#af3f151e3eb95f0af8ae2295b1fbae346">framebufferObjectId</a>) );</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">/* Bind a texture object we want the result data to be stored in.*/</span></div>
<div class="line">                    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER,</div>
<div class="line">                                                    GL_COLOR_ATTACHMENT0,</div>
<div class="line">                                                    GL_TEXTURE_2D,</div>
<div class="line">                                                    <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#aa834665bb6d6f6ba6c9c536d3877d05b">blurringObjects</a>.<a class="code" href="struct_blurring_objects.html#acb5d531e1522b832d94685cc6cbd54e0">textureObjectIdVertical</a>,</div>
<div class="line">                                                    0) );</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">/* Set uniform values. */</span></div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ab475df069fd64e8fbf8e5a7013886525">blurringVerticalProgramLocations</a>.<a class="code" href="struct_blurring_program_locations.html#a927a36db6d46279bef56e447d1543f43">uniformTextureSampler</a>,</div>
<div class="line">                                     <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a2bcef44146b276fa6be9e0292f4f9594">TEXTURE_UNIT_HORIZONTAL_BLUR_TEXTURE</a>) ); <span class="comment">/* Indicates which texture object content should be blurred. */</span></div>
<div class="line"></div>
<div class="line">                <span class="comment">/* Draw texture. */</span></div>
<div class="line">                <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLE_FAN, 0, 4) );</div>
<div class="line">            } <span class="comment">/* SECOND PASS - VERTICAL BLUR */</span></div>
<div class="line">        } <span class="comment">/* for (int blur_iteration_index = 0; i &lt; numberOfIterations; blur_iteration_index++) */</span></div>
<div class="line"></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDisable(GL_SCISSOR_TEST));</div>
</div><!-- fragment --><p> Please look at the schema below to see the effect we get after this operation.</p>
<div class="image">
<img src="Bloom_blur_effect_schema.png" alt="Bloom_blur_effect_schema.png"/>
<div class="caption">
The effect of blur operation. The stronger blur effect corresponds to higher number of blur iterations.</div></div>
 <h1><a class="anchor" id="bloomBlending"></a>
Blending</h1>
<p>As the result of previous steps we have:</p>
<ol type="1">
<li>A texture object holding colour scene - the colour scene (<a class="el" href="bloom.html#bloomRenderingSceneToTexture">Rendering Scene to Texture</a>)</li>
<li>A texture object holding bloom objects with weaker blur effect applied (the result of n-th - 1 iteration described in <a class="el" href="bloom.html#bloomBlurring">Blurring</a>)</li>
<li>A texture object holding bloom objects with stronger blur effect applied (the result of n-th iteration described in <a class="el" href="bloom.html#bloomBlurring">Blurring</a>)</li>
</ol>
<p>What we want to achieve at this step is to blend all those textures and display the result.</p>
<p>Our approach was the smooth changes of the blur effect strength. This is why we needed two results (n-th and n-th - 1) from blur loop. We will use the <em>OpenGL ES Shading Language</em> <b>mix()</b> function to get this effect. This approach is not obligatory. You can use the result of the last blur loop only (then the <b>mix()</b> operation in shader will not be needed), however it would lead to jagged result of the blur effect strength change, which does not look as nice as the smooth changes.</p>
<p>First of all, please look at the code presented below.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Apply blend effect.</span></div>
<div class="line"><span class="comment">     * Take the original scene texture and blend it with texture that contains the total blurring effect.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a5eeca1d575a4d6957fef0120a7b2c5c1">blendingProgramShaderObjects</a>.<a class="code" href="struct_program_and_shaders_ids.html#ae77e9d7ca2e7d4d0aead1184cec49a61">programObjectId</a>) );</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Bind the default framebuffer object. That indicates that the result is to be drawn to the back buffer. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0) );</div>
<div class="line">        <span class="comment">/* Set viewport values so that the rendering will take whole screen space. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0, 0, <a class="code" href="_cube_8cpp.html#aa61000540636bfdc4c9f27045ab84ce9">windowWidth</a>, <a class="code" href="_cube_8cpp.html#af140802328ffe8a45749114b1c5a2056">windowHeight</a>) );</div>
<div class="line">        <span class="comment">/* Set uniform value. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1f(<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#af4db04df8fc7d3241dff6f3b4f4bccc3">blendingProgramLocations</a>.<a class="code" href="struct_blending_program_locations.html#aa3bc97b7b8bf6acfbdb6c2db901a5009">uniformMixFactor</a>, mixFactor) ); <span class="comment">/* Current mixFactor will be used for mixing two textures color values</span></div>
<div class="line"><span class="comment">                                                                                       * (texture with higher and lower blur effect value). */</span></div>
<div class="line">        <span class="comment">/* Clear framebuffer content. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) );</div>
<div class="line">        <span class="comment">/* Draw texture. */</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLE_FAN, 0, 4) );</div>
<div class="line">    }</div>
</div><!-- fragment --><p> As you can see, we use default framebuffer object, thanks to which the effect will be displayed on screen rather than stored in rendering targets. The only thing which is changing is the mix factor. This will be used as a parameter for <b>mix()</b> function in a shader. Depends on the blur effect direction (if it increases or decreases) the <b>mixFactor</b> value is changing accordingly (form 0 to 1).</p>
<div class="fragment"><div class="line">    <span class="comment">/* Mix factor value is calculated for a specific frame (for a specific time).</span></div>
<div class="line"><span class="comment">     * - The number of blur passes varies from MIN_NUMBER_OF_BLUR_PASSES to MAX_NUMBER_OF_BLUR_PASSES</span></div>
<div class="line"><span class="comment">     *   and to MIN_NUMBER_OF_BLUR_PASSES again which indicates the constant animation of increasing</span></div>
<div class="line"><span class="comment">     *   and decreasing blur effect strength.</span></div>
<div class="line"><span class="comment">     * - For each frame (time) there is a check done to verify the current number of blur passes.</span></div>
<div class="line"><span class="comment">     * - Once we get the current number of blur passes, we have to calculate the mix factor:</span></div>
<div class="line"><span class="comment">     *   It is changing from 0 to 1 (if the blur effect is increasing) or from 1 to 0 (if the blur effect is decreasing).</span></div>
<div class="line"><span class="comment">     *   This value is set based on a time which passed from the beginning of current number of blur passes rendering in</span></div>
<div class="line"><span class="comment">     *   compare to the total time requested for changing this number.</span></div>
<div class="line"><span class="comment">     *</span></div>
<div class="line"><span class="comment">     *   The &#39;rendering frame for a specific time&#39; approach is used to avoid a situation of a different effect for slower and faster devices.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="comment">/* Increase or decrease mixFactor value (depends on blurEffectDirection). */</span></div>
<div class="line">    timeIntervalIndex = (<a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>)(<a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a> / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a847b99b287f7c6555ab0f1cb4ed52119">TIME_INTERVAL</a>);</div>
<div class="line">    nOfIterations     = (<a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>) timeIntervalIndex % numberOfBlurPasses;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (nOfIterations &gt;= (numberOfBlurPasses / 2))</div>
<div class="line">    {</div>
<div class="line">        nOfIterations       = numberOfBlurPasses - (nOfIterations % numberOfBlurPasses) - 1;</div>
<div class="line">        blurEffectDirection = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7dc532c02b98a9b4d2363787743121b8">BLUR_EFFECT_DECREASE</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    mixFactor                 = (<a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a> - ((<a class="code" href="hiz__cull_8cs.html#ad4c740ec72b16a35038e3b75d175014f">int</a>)(<a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a> / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a847b99b287f7c6555ab0f1cb4ed52119">TIME_INTERVAL</a>) * <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a847b99b287f7c6555ab0f1cb4ed52119">TIME_INTERVAL</a>)) / <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a847b99b287f7c6555ab0f1cb4ed52119">TIME_INTERVAL</a>;</div>
<div class="line">    currentNumberOfIterations = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a0af1b4379f579c7515b34cf6c35a73ff">MIN_NUMBER_OF_BLUR_PASSES</a> + nOfIterations;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (blurEffectDirection == <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a7dc532c02b98a9b4d2363787743121b8">BLUR_EFFECT_DECREASE</a>)</div>
<div class="line">    {</div>
<div class="line">        mixFactor = 1.0f - mixFactor;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (currentNumberOfIterations != <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a8b8f1302774e39a228318d92a89b20c4">lastNumberOfIterations</a>)</div>
<div class="line">    {</div>
<div class="line">        shouldSceneBeUpdated = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Store current number of iterations for future use. */</span></div>
<div class="line">    <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a8b8f1302774e39a228318d92a89b20c4">lastNumberOfIterations</a> = currentNumberOfIterations;</div>
</div><!-- fragment --><p> In the fragment shader object (code presented below) there are three texture source inputs (accordingly to those listed above). The weaker and stronger blur textures are mixed (<b>mix()</b> function is applied which returns the linear blend). The total colour which will be returned is just a sum of the linear blending of blurred textures and the original scene texture.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"><span class="comment">/* UNIFORMS */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <span class="keywordtype">float</span>     mix_factor;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D original_texture;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D stronger_blur_texture;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D weaker_blur_texture;</div>
<div class="line"><span class="comment">/* INPUTS */</span></div>
<div class="line">in <a class="code" href="structvec2.html">vec2</a> texture_coordinates;</div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> color;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> stronger_blur_texture_color = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(stronger_blur_texture, texture_coordinates);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> weaker_blur_texture_color   = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(weaker_blur_texture,   texture_coordinates);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> mixed_blur_color            = mix(weaker_blur_texture_color, stronger_blur_texture_color, mix_factor);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> original_color              = <a class="code" href="gl2ext_8h.html#ab21590c4736d1459a5a0674a42b5a655">texture</a>(original_texture, texture_coordinates);</div>
<div class="line">    <span class="comment">/* Return blended colour. */</span></div>
<div class="line">    color = original_color + mixed_blur_color;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="bloomCodeDetails"></a>
Code Details</h1>
<p>The bloom algorithm has already been described. Let's focus on the implementation details now.</p>
<ol type="1">
<li><a class="el" href="tutorials_2_bloom_2jni_2_native_8cpp.html" title="The application shows a bloom effect implementation. It draws cubes arranged in a two-dimensional 5x5...">tutorials/Bloom/jni/Native.cpp</a> In this file you can find the bloom algorithm implementation (you can find there most of things described above).</li>
<li><a class="el" href="tutorials_2_bloom_2jni_2_cube_model_8cpp.html">tutorials/Bloom/jni/CubeModel.cpp</a> In this file you can find all the functions connected with generating the cube model (generation of vertex coordinates or normals).</li>
<li><a class="el" href="tutorials_2_bloom_2jni_2_matrix_8cpp.html">tutorials/Bloom/jni/Matrix.cpp</a> In this file you can find all functions connected with matrix calculations.</li>
<li><a class="el" href="tutorials_2_bloom_2jni_2_shader_8cpp.html">tutorials/Bloom/jni/Shader.cpp</a> In this file you can find implementation of functions responsible for shader operations, like shader object creation, compilation, reading and loading shader source, etc. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
