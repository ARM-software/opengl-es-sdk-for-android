<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Occlusion Culling with Hierarchical-Z</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occlusion_culling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Occlusion Culling with Hierarchical-Z </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample will show you how to efficiently implement occlusion culling using compute shaders in OpenGL ES 3.1. The sample tests visibility for a large number of instances in parallel and only draws the instances which are assumed to be visible. Using this technique can in certain scenes give a tremendous performance increase.</p>
<div class="image">
<img src="hiznoculling.png" alt="hiznoculling.png"/>
</div>
<h1><a class="anchor" id="occlusionIntroduction"></a>
Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>This sample uses OpenGL ES 3.1.</dd>
<dd>
This sample assumes basic knowledge of OpenGL ES compute shaders and OpenGL ES 3.0. Some important features for this sample:<ul>
<li><a class="el" href="class_shader.html">Shader</a> storage buffer objects (SSBOs)</li>
<li>Atomic operations</li>
<li>Indirect drawing</li>
<li>textureGather() (GLSL)</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="occlusionProblem"></a>
Problem</h1>
<p>Sometimes an application will want to manage a large number of instances of an object. These instances might be fully dynamic and controlled by the GPU using OpenGL ES 3.1 compute shaders. Eventually, we want to draw these instances, but depending on our scene, only a small number of instances might actually be visible at one time due to various occluders in our scene.</p>
<p>Depending on the number of objects in our scene, drawing every instance regardless of visibility could be very taxing on performance, and determining visibility on CPU might not be practical.</p>
<h2><a class="anchor" id="occlusionConsiderQuery"></a>
Considering OpenGL ES 3.0 Occlusion Query</h2>
<p>OpenGL ES 3.0 has the occlusion query functionality which lets you determine visibility of a draw call. It does however, have some shortcomings in this case.</p>
<ul>
<li>Instancing not supported. Would need one query object per instance.</li>
<li>Readback to CPU is required.</li>
</ul>
<p>The usage scenarios for occlusion query tend to be simpler, with fewer meshes.</p>
<h1><a class="anchor" id="occlusionTestScene"></a>
Test scene</h1>
<p>In this test scene, we have chosen a simple scene to demonstrate the problem, and how the occlusion culling technique provided here can help solve it.</p>
<p>For simplicity the sample meshes are spheres and occluders are modeled as tall prisms. We will draw the scene twice. One time to draw the spheres, and once to draw the spheres with a GL_GREATER depth test to visualize the spheres which are redundantly drawn causing lots of extra vertex shading work. Spheres which are redundantly drawn are drawn with a darker color.</p>
<p>Without any form of culling, we see the scene is completely dominated by invisible objects.</p>
<div class="image">
<img src="hiznoculling.png" alt="hiznoculling.png"/>
</div>
<p>However, using the techniques described below, we can reduce this to a far more manageable amount.</p>
<div class="image">
<img src="hizcullingnolod.png" alt="hizcullingnolod.png"/>
</div>
<h1><a class="anchor" id="occlusionHiZ"></a>
Hierarchical-Z</h1>
<p>The main idea of Hierarchical-Z is to represent the depth of a scene with multiple resolutions. Using multiple depth map resolutions, we can quickly and efficiently determine visibility of an instance.</p>
<p>Rendering the depth of the current scene is a fixed cost, but cost of testing visibility for a single instance is made very low.</p>
<h1><a class="anchor" id="occlusionHiZRender"></a>
Rendering Hierarchical-Z depth map</h1>
<p>First, we need to separate our scene into occluders and occludees. Occluders will be big objects which naturally occlude other objects.</p>
<p>Occluders can if desired be represented with low-poly occlusion geometry. The requirement for occlusion geometry however, is that it must not contain any volume not already contained by the original mesh. This is to avoid falsely discarding visible instances.</p>
<dl class="section note"><dt>Note</dt><dd>Occluder geometry is opposite of bounding boxes. Bounding boxes <b>must</b> contain all volume the original mesh does, but occluder geometry <b>cannot</b> contain any volume outside the mesh.</dd></dl>
<p>Occludees can also be used as occluders if occludees tend to occlude themselves. The same rules for occlusion geometry applies.</p>
<p>We render these to a low-resolution depth texture (256x256 for example). To represent the scene depth at various resolutions, we can mipmap our depth texture down to a 1x1 texture. Since depth textures are not filterable, we manually mipmap the depth texture. To conservatively represent the scene depth at a larger resolution, we have to use a <a class="el" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max()</a> filter on our depth. In OpenGL ES 3.1, we can use the new textureGather() function to obtain all four depth values in a quad in one texture lookup.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> depths = textureGather(uDepth, vTex, 0); <span class="comment">// Get depth values from all surrounding texels.</span></div>
<div class="line">    gl_FragDepth = <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(<a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(depths.<a class="code" href="structvec4.html#a36c650782a67137380c83b01545c94d6">x</a>, depths.<a class="code" href="structvec4.html#a7328fe0e502fce92fa32016193052e92">y</a>), <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(depths.<a class="code" href="structvec4.html#a12b318751110db034dddc450cdec455d">z</a>, depths.<a class="code" href="structvec4.html#a0c92fe67e490d9768217a00c2e8abd49">w</a>)); <span class="comment">// Write conservative depth.</span></div>
<div class="line">    gl_FragColor = <a class="code" href="structvec4.html">vec4</a>(1.0); <span class="comment">// Ignored</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For reference, there are some sample depth maps below which are mipmapped using this approach.</p>
<div class="image">
<img src="occlusion_depth_mips.png" alt="occlusion_depth_mips.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>By rendering scene depth to a lower resolution than the actual scene we do risk falsely culling instances. However, this edge case can only possibly occur when a few pixels from an object are visible. Bounding volumes tend to be a bit larger than the actual object itself, which makes this case even more unlikely. In a real application, such a case would normally not be significant enough to warrant rendering the scene depth in full resolution, but if it does become an issue, the resolution can always be increased as needed. Alternatively, using conservative rasterization can be considered, but the implementation complexity would drastically increase.</dd></dl>
<h1><a class="anchor" id="occlusionFiltering"></a>
Filtering data sets with compute shaders</h1>
<p>Occlusion culling is essentially a filtering operation. From a set of data, we include elements in the filtered set based on a condition. Before going into the particular occlusion culling technique, it's useful to look at filtering data with compute shaders in general.</p>
<p>Compute shaders (and GPUs) run in parallel, which means the obvious serial approach does not work, e.g.:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;data : dataset)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (predicate(data))</div>
<div class="line">    {</div>
<div class="line">        filtered_dataset.push_back(data);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Instead, we could use atomic counters to allow the loop bodies to run fully in parallel, here expressed with C++11-style atomics:</p>
<div class="fragment"><div class="line">std::atomic_uint <a class="code" href="gl2ext_8h.html#afa228d201857b67afdee8292f4cb08a8">counter</a>{0};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;data : dataset)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Assume loop body runs in parallel.</span></div>
<div class="line">    <span class="keywordflow">if</span> (predicate(data))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Due to the nature of atomic adds,</span></div>
<div class="line">        <span class="comment">// every value obtained must be unique, and it&#39;s hence</span></div>
<div class="line">        <span class="comment">// safe to do this loop fully in parallel.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// NOTE: On a CPU implementation, we would probably implement this very differently,</span></div>
<div class="line">        <span class="comment">// this is just to illustrate the point.</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> unique = <a class="code" href="gl2ext_8h.html#afa228d201857b67afdee8292f4cb08a8">counter</a>.fetch_add(1, std::memory_order_relaxed);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// filtered_dataset must be preallocated to hold at least</span></div>
<div class="line">        <span class="comment">// dataset.size() elements.</span></div>
<div class="line">        filtered_dataset[unique] = <a class="code" href="gl2ext_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Synchronize all threads.</span></div>
</div><!-- fragment --><p>Data will be added to the filtered dataset unordered due to parallelism, but this is not a problem for occlusion culling.</p>
<p>We can translate the C++11-style example to compute shaders, where it would look something like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 310 es</span></div>
<div class="line"><span class="preprocessor"></span><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(local_size_x = 1) in;</div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(std430) buffer;</div>
<div class="line"></div>
<div class="line">struct InstanceData { ... };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> predicate(InstanceData data)</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 0) buffer InputData</div>
<div class="line">{</div>
<div class="line">    readonly InstanceData data[];</div>
<div class="line">} dataset;</div>
<div class="line"></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 1) buffer OutputData</div>
<div class="line">{</div>
<div class="line">    writeonly InstanceData data[];</div>
<div class="line">} filtered_dataset;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Can also do atomic operations on an SSBO.</span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 0, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 0) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint instanceCount;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    uint ident = gl_GlobalInvocationID.x;</div>
<div class="line">    InstanceData data = dataset.<a class="code" href="structvec4.html#ae40016fa97400690251b4438d7f89a67">data</a>[ident];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (predicate(data))</div>
<div class="line">    {</div>
<div class="line">        uint unique = atomicCounterIncrement(instanceCount);</div>
<div class="line">        filtered_dataset.data[unique] = <a class="code" href="gl2ext_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If we now consider the occlusion culling case again, we can consider something like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>InstanceData { ... };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> is_instance_visible(InstanceData data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Hierarchical-Z test here.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 0) buffer InputData</div>
<div class="line">{</div>
<div class="line">    readonly InstanceData data[];</div>
<div class="line">} instance_data;</div>
<div class="line"></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 1) buffer OutputData</div>
<div class="line">{</div>
<div class="line">    writeonly InstanceData data[];</div>
<div class="line">} filtered_instance_data;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Can also do atomic operations on an SSBO.</span></div>
<div class="line"><span class="comment">// instanceCount in indirect draw buffer is found at offset = 4.</span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 0, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 4) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint instanceCount;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    uint ident = gl_GlobalInvocationID.x;</div>
<div class="line">    InstanceData data = instance_data.data[ident];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (is_instance_visible(data))</div>
<div class="line">    {</div>
<div class="line">        uint unique = atomicCounterIncrement(instanceCount);</div>
<div class="line">        filtered_instance_data.data[unique] = <a class="code" href="gl2ext_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="occlusionHiZTest"></a>
Hierarchical-Z Visibility Test</h1>
<p>The Hierarchical-Z visibility test is implemented here as a single compute shader. It will read a buffer of bounding volumes represented as bounding spheres or bounding boxes and output a tightly packed instance buffer as well as a counter for the number of elements in the buffer.</p>
<h2><a class="anchor" id="occlusionFrustumCull"></a>
Frustum Culling Pre-pass</h2>
<p>Before attempting any kind of Hi-Z culling, we first attempt to frustum cull the instance. <a class="el" href="class_frustum.html">Frustum</a> culling is implemented very efficiently (especially for bounding spheres), and by frustum culling, we also avoid some edge cases with the Hi-Z algorithm later.</p>
<p>See the <a class="el" href="terrain.html">Terrain</a> OpenGL ES 3.0 sample for more detail on how frustum culling can be implemented.</p>
<h2><a class="anchor" id="occlusionScreenSpaceBB"></a>
Computing Screen Space Bounding Box</h2>
<p>Since we need to base our visibility decision on a 2D depth map, we must project our instance down to a screen space bounding box first. It is important that the bounding box is as small as possible to avoid overconservative culling.</p>
<p>For axis-aligned bounding boxes, projecting a bounding box is fairly straight forward. We can take the 8 corners and project them to screen, then take min/max of screen space X/Y and use the minimum Z as our reference depth value against depth map. The only edge case we have to handle here is when the bounding box intersects with the near plane. We then risk dividing by w &lt;= 0.0, which will give us unexpected results. To avoid this case, we can treat all instances which intersect the near plane as visible. An object so close to the screen that it clips will likely be visible anyways.</p>
<p>For bounding spheres, the screen space bounding box computation is more complicated as there are no corners that can be transformed and projected. We have to take into account perspective warping that happens when the spheres move away from the center of the screen as well. In this sample, we focus on bounding spheres as occlusion testing is significantly cheaper than testing bounding boxes. We implemented the simplest case of the algorithm in <a href="#ref1">[1]</a>. To find minimum Z value, we perform a view transform of the bounding sphere center, add radius to Z, and perform a perspective transform of the Z coordinate.</p>
<h2><a class="anchor" id="occlusionVisibilityTest"></a>
Visibility Testing</h2>
<p>When we know the screen space bounding box for an instance and minimum Z, we can test against our depth texture.</p>
<p>We first find a mip-level where four depth texture texels covers the entire screen space bounding box. We can then do a single PCF depth compare lookup to test these four texels. If PCF result is &gt; 0.0, at least one texel compared to 1.0 and we must assume the instance is visible.</p>
<p>See implementation for more details.</p>
<h1><a class="anchor" id="occlusionIndirectDraw"></a>
Indirect Drawing</h1>
<p>After culling our scene we have a count of number of visible objects due to atomic increments, and a tightly packed array of visible instance data.</p>
<p>The instance count is currently not known to the CPU yet as the atomic count is backed by a GL buffer. We can perform an indirect draw which lets us perform a draw call with unknown parameters. E.g.:</p>
<div class="fragment"><div class="line">glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 0, indirect_buffer);</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, instance_buffer);</div>
<div class="line">glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, filtered_instance_buffer);</div>
<div class="line">do_occlusion_culling(...);</div>
<div class="line">glMemoryBarrier(...);</div>
<div class="line"></div>
<div class="line">glBindVertexArray(instance_vertex_array);</div>
<div class="line">glBindBuffer(GL_DRAW_INDIRECT_BUFFER, indirect_buffer);</div>
<div class="line">glDrawElementsIndirect(...); <span class="comment">// We don&#39;t know instanceCount on the CPU, but GPU knows.</span></div>
</div><!-- fragment --><p>OpenGL expects a fixed layout of the buffer object to read data like element count, instance count, base vertex, etc. See OpenGL ES 3.1 reference or the code for details.</p>
<h1><a class="anchor" id="occlusionVariousGeometry"></a>
Considerations for occlusion culling meshes belonging to different draw calls</h1>
<p>In real-world scenes, not every mesh can be instanced, which makes this technique more difficult to implement efficiently, because we would need several indirect draw calls.</p>
<p>One possibility is instead of filtering per-instance data, one can compute a visibility buffer where each mesh gets a 0/1 value. A readback to CPU could be done where the application will draw meshes depending on GPU computed results. This is inoptimal due to GPU-to-CPU readback which can break pipelining. A workaround for pipelining issue would be to readback older results, but culling results could be incorrect if camera or objects have moved significantly. A more advanced workaround for the pipelining issue would attempt some kind or reprojection, but this is outside the scope of this sample.</p>
<p>Overall, this technique is most efficient for cases where you cull instances belonging to the same instanced draw call.</p>
<h1><a class="anchor" id="occlusionLOD"></a>
Sorting instances in level-of-details</h1>
<p>A common technique for reducing shading load is to recognize that objects far away from the camera require less detail. It is possible for artists to create meshes with different detail levels which can be drawn according to quality needs. We can employ this idea for occlusion culling as well.</p>
<p>In the compute dispatch doing culling, we already know the minimum depth value for the bounding volume. We can simply partition the depth space into a fixed number of regions. Our shader code would look something like this for four level-of-details.</p>
<div class="fragment"><div class="line"><span class="comment">// Number of atomic_uints we can use is limited.</span></div>
<div class="line"><span class="comment">// Could use atomics on a single SSBO if we need many LODs.</span></div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 0, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 4) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint lod0Counter;</div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 1, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 4) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint lod1Counter;</div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 2, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 4) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint lod2Counter;</div>
<div class="line"><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(binding = 3, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a> = 4) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> atomic_uint lod3Counter;</div>
<div class="line"></div>
<div class="line"><span class="comment">// depth is the non-linear device space depth.</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="hiz__cull_8cs.html#a9296066c514fff461b9bd49cf99c6d48">append_instance</a>(InstanceData data, <span class="keywordtype">float</span> <a class="code" href="gl2ext_8h.html#aa8bd8cf1eef34712fdb6ad58b540a2ee">depth</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (depth &gt; 0.9)</div>
<div class="line">    {</div>
<div class="line">        uint count = atomicCounterIncrement(lod3Counter);</div>
<div class="line">        instance_data_lod3.data[<a class="code" href="gl2ext_8h.html#a619bc20e8198de3bd3f3d7fc34de66b2">count</a>] = <a class="code" href="gl2ext_8h.html#a740d7f00b044f54a556c7208e01f9f02">data</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (depth &gt; 0.8)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// And so on ...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In GL, we end up with four indirect buffers and four instance buffers. We split this up into four different indirect draw calls where we instance over meshes of different quality levels. We can even use different shaders for the draw calls. A mesh that is far away might not require normal mapping for example.</p>
<p>Another added benefit of sorting like this is that objects close to the screen can be drawn first (LOD0), which makes sure objects are drawn approximately front-to-back, enabling early-Z optimizations.</p>
<p>In this sample, we implement both the single LOD, and multiple LOD approaches. LODs farther away from the camera are drawn with a blue-ish tint.</p>
<p>Single LOD. </p>
<div class="image">
<img src="hizcullingnolod.png" alt="hizcullingnolod.png"/>
</div>
<p>Multiple LODs. </p>
<div class="image">
<img src="hizculling.png" alt="hizculling.png"/>
</div>
<h1><a class="anchor" id="occlusionReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://jcgt.org/published/0002/02/05/paper.pdf">http://jcgt.org/published/0002/02/05/paper.pdf</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
