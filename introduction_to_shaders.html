<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Introduction to shaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('introduction_to_shaders.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction to shaders </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A quick introduction to the programmable graphics pipeline introduced in OpenGL ES 2.0.</p>
<h1><a class="anchor" id="introductionToShadersIntroduction"></a>
Introduction</h1>
<p>This series of tutorials is going to focus on programmable graphics APIs. What does this mean? OpenGL ES 2.0 was the first OpenGL ES version to support a programmable graphics pipeline. Prior to this, we had OpenGL ES 1.x. OpenGL ES 1.x is a fixed function mobile graphics API. A fixed function graphics API allows you to specify various bits of data (positions, colours, etc.) for the GPU to work on, and a strict set of commands for using that data.</p>
<p>For example, you can tell the GPU that you have a polygon in your scene, specify the reflectance of the material for that polygon, and add a light to the scene. The GPU will then go a away and calculate what colour the polygon will appear in your scene.</p>
<p>This is great for simple scenes and allows you to very quickly achieve some very nice looking graphical effects.</p>
<p>However, what happens when you want to use a different lighting equation that the one built in to the API? What if you come up with a great new graphics technique but the API doesn't support it? (e.g. frame buffer objects, cube maps, etc.). You're very dependent on the contents of the API; there are a fixed set of functions and those functions have a limited number of options. This is never going to cover all the things you might want to do as a developer. And although the API can be extended to support more options and more techniques, you're then dependent on GPU vendors implementing those extensions.</p>
<p>That's where fixed function graphics pipelines fall short. Instead of creating hundreds of extensions and functions to support all requested use cases, programmable pipelines were created. A programmable pipeline allows the developer to provide custom code that is run on the GPU at various stages of the pipeline. Each piece of code is called a shader, and since they can contain arbitrary code it means the developer is free to do (almost) whatever they like.</p>
<p>Of course, all this freedom comes with a price. Since there are no default shaders in OpenGL ES 2.0 you must always write your own. This means that features like lighting, texturing, and others that are "free" (in terms of developer effort) in OpenGL ES 1.1 must now be programmed explicitly by the developer.</p>
<p>It's worth mentioning that OpenGL ES 1.x and OpenGL 2.0 onwards cannot be mixed and OpenGL ES 2.0 is not backwards compatible. In other words, it's all or nothing when choosing fixed function vs. programmable.</p>
<h1><a class="anchor" id="introductionToShadersPortability"></a>
Portability</h1>
<p>Since shaders are C-like programs which run on a GPU, you may be thinking, "how do I compile these shaders?". Because each GPU vendor (and sometimes each GPU) has a different instruction set we need a way to compile the shaders for every different device.</p>
<p>Thankfully this is possible in OpenGL ES using "online" compilation. You provide the source code for you shaders to the OpenGL ES API at runtime and the OpenGL ES driver uses a compiler on the device itself to compile your code for instruction set of the device.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a shader object (we&#39;ll see the types of shader you can create later).</span></div>
<div class="line">glCreateShader(...);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add the source code to the shader object.</span></div>
<div class="line">glShaderSource(...);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compile the shader source code.</span></div>
<div class="line">glCompileShader(...);</div>
</div><!-- fragment --><p>Shaders work together in programs. This is similar to what happens when compiling normal C code: you compile your source to object files (.o) and then link them together into an executable. Here, you compile you shaders, add them to a program and then link them together. </p>
<div class="fragment"><div class="line"><span class="comment">// Create a program object.</span></div>
<div class="line">glCreateProgram();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Attach shader objects to that program.</span></div>
<div class="line">glAttachShader(...);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Link the shaders objects inside a program.</span></div>
<div class="line">glLinkProgram(...);</div>
</div><!-- fragment --><p>This leaves you with a program object which you can use in your application.</p>
<div class="fragment"><div class="line"><span class="comment">// Tell OpenGL ES which program you want to use.</span></div>
<div class="line">glUseProgram( <a class="code" href="gl2ext_8h.html#adda687347282e5405e89b4fc19a1f8e2">GLuint</a> <a class="code" href="gl2ext_8h.html#adffcc51f3ade9f7911b0db30601322f6">program</a>);</div>
</div><!-- fragment --><p>The downside here is of course that anybody who wants to will be able to see you shader code which will contain your top secret super-fancy graphics techniques. In the interest of keeping your shader source code propriety, most GPU vendors also provide an "offline" compiler which can generate binaries for their particular platform. These binaries can then be shipped with you application and loaded using the OpenGL ES API at runtime. You will have to create and ship binaries for each platform you wish to run on and pick the correct one.</p>
<p>You can load binaries by swapping <code>glShaderSource</code> above for <code>glShaderBinary</code>.</p>
<h1><a class="anchor" id="introductionToShadersPipeline"></a>
The OpenGL ES Programmable Pipeline</h1>
<p>A diagram of the OpenGL ES 2.0 pipeline can be found below.</p>
<div class="image">
<img src="pipeline.png" alt="pipeline.png"/>
<div class="caption">
The OpenGL ES Programmable Pipeline</div></div>
<p> The vertex and fragment stages are the programmable stages in the OpenGL ES 2.0.</p>
<h1><a class="anchor" id="introductionToShadersVertex"></a>
Vertex Shaders</h1>
<p>The code you write in the vertex shader will be run once per vertex. So if you tell OpenGL ES to draw ten unconnected triangles, your vertex shader will run 30 times.</p>
<p>The only required job of the vertex shader is to emit the final position of the vertex.</p>
<p>In a very trivial (and useless) example, your vertex shader could simply set the position of each vertex to (0, 0, 0). This doesn't require any data to be passed in to the shader. The <code>#version 100</code> here tells OpenGL ES that we are using version 1 of the OpenGL ES <a class="el" href="class_shader.html">Shader</a> Language.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Trivial vertex shader.</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_Position = <a class="code" href="structvec4.html">vec4</a>(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>More normally, you would pass in the coordinates of the shapes you want to draw and use these as your positions. For this you need to pass in some data for each vertex you want to draw. This type of per vertex data is handled in OpenGL ES using vertex attributes.</p>
<p>If you want to draw a single triangle, you need three vertices. Let's say (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), and (-1.0, 0.0, 0.0).</p>
<p>To get this data in, we can pass the array [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0] to OpenGL ES and associate it with a 3-component attribute (e.g. a <a class="el" href="structvec3.html">vec3</a>). When you tell OpenGL ES you want to draw a single triangle, it will split up the array and pass each 3-component position to a different vertex shader.</p>
<p>We can then use this data to set the position of the vertex in the vertex shader.</p>
<div class="fragment"><div class="line"><span class="comment">// Host code to set data up to be used in the shader.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create you C array of vertex positions.</span></div>
<div class="line"><a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> [] positions = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0};</div>
<div class="line"></div>
<div class="line"><span class="comment">// To associate this data with a particular input to the shader, we must get that inputs &quot;location&quot; in the shader. Note, this can only be done after the glProgram has been linked.</span></div>
<div class="line">GLint <a class="code" href="jni_2_astc_textures_8cpp.html#a65ef4a6e3a2b002afc65bb6f98a1a6b1">position_location</a> = glGetAttribLocation(<span class="stringliteral">&quot;position&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Finally, tell OpenGL ES to use the &#39;positions&#39; array as the input data.</span></div>
<div class="line">glVertexAttribPointer(<a class="code" href="jni_2_astc_textures_8cpp.html#a65ef4a6e3a2b002afc65bb6f98a1a6b1">position_location</a>, ..., positions);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Vertex shader which takes position as a per-vertex input.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Inputs</span></div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> position;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_Position = position;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Great, we can now pass data in to a vertex shader and set a sensible position. The nice thing is, that we can use these same techniques to pass in any data we want to be different per vertex. So if we want to have a colour associated with each vertex we can do that too.</p>
<div class="fragment"><div class="line"><span class="comment">// Same code as before to set data up to be used in the shader.</span></div>
<div class="line"><a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> [] colours = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0};</div>
<div class="line">GLint colour_location = glGetAttribLocation(<span class="stringliteral">&quot;colour&quot;</span>);</div>
<div class="line">glVertexAttribPointer(colour_location, ..., colours);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Vertex shader that takes in per-vertex position and colour inputs.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Inputs</span></div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> position;</div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_Position = position;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now you're thinking what good is a colour in the vertex shader if the only thing I can output is a vertex position. Well, it turns out you can also create arbitrary outputs from a vertex shader which will be interpolated across the shape you are drawing. These are called varyings. The varyings you output must exactly match the varyings you specify as inputs to the fragment shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Vertex shader that takes in per-vertex colour data and outputs it as interpolated per-fragment data.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Inputs</span></div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> position;</div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Outputs</span></div>
<div class="line">varying <a class="code" href="structvec4.html">vec4</a> interpolated_colour;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    interpolated_colour = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line">    gl_Position = position;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="introductionToShadersRasterizer"></a>
The Rasterizer</h1>
<p>There are two stages in our pipeline diagram in between the vertex and fragment stages: primitive assembly and rasterization. Since all modern display technologies are <a href=" http://en.wikipedia.org/wiki/Raster_graphics">raster</a> based (they can display only coloured points), we need some way to turn our concept of points and triangles into points on the screen. The rasterization step does this part for us, working out which primitives cover which points and then generating fragment jobs for those points. As it generates the fragment job it calculates the interpolated values for our varyings using something called barycentric coordinates. We won't go into the details here but in the example below, on the left side we have a triangle with red, green, and blue specified as the colour attributes for the three vertices. On the right the colours have been interpolated across the triangle.</p>
<div class="image">
<img src="interpolation.png" alt="interpolation.png"/>
<div class="caption">
Interpolating per-vertex colours across a triangle.</div></div>
<p> That's an easy to visualise example using colours, but this technique works for all kinds of things.</p>
<h1><a class="anchor" id="introductionToShadersFragment"></a>
Fragment Shaders</h1>
<p>This leads us nicely onto the fragment shader. The fragment shader is run (you guessed it!) once per fragment issued by the rasterizer.</p>
<p>The only output a fragment shader needs to emit is the colour of the fragment. So to give another trivial example we could just set the colour of every fragment to black: (0.0, 0.0, 0.0, 1.0).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Trivial fragment shader.</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_FragColor = <a class="code" href="structvec4.html">vec4</a>(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>But that's no fun.</p>
<p>So since we've passed some interpolated colours from the vertex shader, we can use those here.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Fragment shader which takes interpolated colours and uses them to set the final fragment colour.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Floating point values in fragment shaders must have a precision set.</span></div>
<div class="line"><span class="comment">// This can be done globally (as done here) or per variable.</span></div>
<div class="line">precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Inputs</span></div>
<div class="line">varying <a class="code" href="structvec4.html">vec4</a> interpolated_colour;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_FragColor = interpolated_colour;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="introductionToShadersUniforms"></a>
Uniforms</h1>
<p>So to recap so far we've covered:</p>
<ul>
<li>How to get per-vertex data into the fragment shader</li>
<li>How to get interpolated per fragment data into the fragment shader</li>
</ul>
<p>What about constant data? What if we have some data which is common to all vertices, or to all fragments or to everything?</p>
<p>This could be anything from a time value to something describing the level of light in the scene.</p>
<p>A very common use for this would be having a transformation matrix which positions you vertices in a scene. You need the same matrix for each vertex so that they all get transformed together.</p>
<p>For this constant type of data we have shader uniforms. For the most part declaring, setting and using uniforms is the same as attributes except that you only set one set of values.</p>
<p>For example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Vertex shader which takes a constant input value (a uniform) and uses it to alter all vertex x positions.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Per-vertex inputs</span></div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> position;</div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constant inputs</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <span class="keywordtype">int</span> x_offset;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Outputs</span></div>
<div class="line">varying <a class="code" href="structvec4.html">vec4</a> interpolated_colour;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    interpolated_colour = <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>;</div>
<div class="line">    gl_Position = position + <a class="code" href="structvec4.html">vec4</a>(x_offset, 0.0, 0.0, 0.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>More differences between attributes and uniforms are listed in <a class="el" href="introduction_to_shaders.html#introductionToShadersAppendixA">Appendix: Attributes vs. Uniforms</a>.</p>
<h1><a class="anchor" id="introductionToShadersTextures"></a>
Textures</h1>
<p>There's one last type of data that we could need, per-fragment data that is not interpolated from per-vertex data. For example, what if we want to display an image on a triangle. We can't use uniforms since we don't typically have enough to store all the pixels in an image(not to mention that setting and accessing the data would be awful). We also can't use attributes and varyings since those are per-vertex and then interpolated which doesn't make sense for an image. Luckily for us OpenGL ES has this covered too. For this purpose we use textures.</p>
<p>Textures allow us to specify arbitrary arrays of data which can be accessed in the fragment shader.</p>
<p>How does each fragment shader instance know where to look in the texture? Good question, but we already have all the knowledge we need to solve this problem. If we specify where in the image each vertex maps to (using an attribute), the rasterizer will interpolate the coordinates nicely for us to give us a per-fragment varying. This coordinate can then be used to look up the correct point in the image. This is done using a texture sampler.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Vertex shader which takes a per-vertex texture coordinate and interpolates it for the fragment shader.</span></div>
<div class="line"></div>
<div class="line">attribute <a class="code" href="structvec4.html">vec4</a> position;</div>
<div class="line">attribute <a class="code" href="structvec2.html">vec2</a> texture_coordinates;</div>
<div class="line"></div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> interpolated_texture_coordinates;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    interpolated_texture_coordinates = texture_coordinates;</div>
<div class="line">    gl_Position = position;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Host side code to set up texture input.</span></div>
<div class="line"></div>
<div class="line">Glint sampler_location = glGetUniformLocation(<a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#acc375d345c9a0f0d601530103fe293af">glProgram</a>, <span class="stringliteral">&quot;texture_sampler&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// Create a Texture (this can be quite involved so we won&#39;t go into detail here but it&#39;s basically uploading an array of data similar to vertex attributes.)</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Set the sampler to point to the texture you&#39;ve just created.</span></div>
<div class="line">glUniform1i(sampler_location, texture_unit);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Fragment shader which looks inside a texture using interpolated texture coordinates.</span></div>
<div class="line"></div>
<div class="line">precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line">varying <a class="code" href="structvec2.html">vec2</a> interpolated_texture_coordinates;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> sampler2D texture_sampler;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_FragColor = texture2D(texture_sampler, interpolated_texture_coordinates);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="introductionToShadersFun"></a>
And now the Fun Begins!</h1>
<p>We've focused on very trivial examples here just to expose the data flows in OpenGL ES. It might not have sold you on why you would want this, or why should you care. Well, this is really only the ground layer. OpenGL ES shaders also allow you do general purpose maths (including lots of hardware accelerated built-in functions). This fact, combined with the data flows we've already covered gives you the ability to harness the power of a massively parallel computing unit: the GPU.</p>
<p>Because of the flexibility afforded to you by the OpenGL ES 2.0 API you're free to implement whatever graphical effects you can imagine. Almost all high-end 3D graphics applications (e.g. games) will be using the basic methods described above; using shaders to achieve their effects.</p>
<h1><a class="anchor" id="introductionToShadersSummary"></a>
Summary</h1>
<p>So in summary we have seen the OpenGL ES programmable pipeline and introduced the two shader types available in OpenGL ES 2.0: vertex and fragment shaders.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shaders have the following interface:</p>
<ul>
<li><a class="el" href="struct_vertex.html">Vertex</a> attributes (per-vertex data) and uniforms (constant data) comes in.</li>
<li><a class="el" href="struct_vertex.html">Vertex</a> positions and varyings go out.</li>
</ul>
<p>Fragment shaders have the following interface:</p>
<ul>
<li>Varyings(interpolated per-fragment data), uniforms (constant data), and textures comes in.</li>
<li>Fragment colours go out.</li>
</ul>
<p>This was a very quick introduction to shaders and the programmable pipeline in OpenGL ES. Don't worry if you didn't quite catch all the details (we haven't really begun to scratch the surface here). The following tutorials go into far more detail and use practical examples (with working source code) to further explain these concepts.</p>
<h1><a class="anchor" id="introductionToShadersNextSteps"></a>
Next Steps</h1>
<p>Now move on to <a class="el" href="graphics_setup.html">Graphics Setup</a>.</p>
<h1><a class="anchor" id="introductionToShadersAppendixA"></a>
Appendix: Attributes vs. Uniforms</h1>
<p>Some further differences between uniforms and attributes for reference:</p>
<p>Accessibility:</p>
<ul>
<li>Attributes are values which are only available in the vertex shader (although you can pass them on the the fragment shader as we we see later).</li>
<li>Uniforms can be accessed in either the fragment or vertex shader.</li>
</ul>
<p>Type of data:</p>
<ul>
<li>Attributes are values which vary per vertex.</li>
<li>Uniforms are constant values that are the same for all instances of the fragment and vertex shaders.</li>
</ul>
<p>Object model:</p>
<ul>
<li>Attributes are attached to locations.</li>
<li>Uniforms are attached to program objects.</li>
</ul>
<p>Availability:</p>
<ul>
<li>There are (generally) less attributes available than uniforms (although both are implementation defined). You can find out the exact number supported on your platform by doing <code>glGet(...)</code> with the appropriate parameter (found in brackets below).</li>
<li>An implementation must support at least 8 vertex attributes (GL_MAX_VERTEX_ATTRIBS).</li>
<li>An implementation must support at least 128 vertex uniforms (GL_MAX_VERTEX_UNIFORM_VECTORS).</li>
<li>An implementation must support at least 16 fragment uniforms (GL_MAX_FRAGMENT_UNIFORM_VECTORS).</li>
<li>OpenGL ES has various other implementation defined properties which can be queried using <code>glGet(...)</code>. Some relavent ones for this introduction are:<ul>
<li>An implementation must support at least 8 varyings (GL_MAX_VARYING_VECTORS).</li>
<li>An implementation must support textures of at least size 64 varyings (GL_MAX_TEXTURE_SIZE). </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
