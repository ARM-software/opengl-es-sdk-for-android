<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Terrain Rendering with Geometry Clipmaps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('terrain.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Terrain Rendering with Geometry Clipmaps </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample will show you how to efficiently implement geometry clipmaps using OpenGL ES 3.0. The sample makes use of 2D texture arrays as well as instancing to efficiently render an infinitely large terrain. The terrain is asynchronously uploaded to the GPU using pixel buffer objects.</p>
<div class="image">
<img src="terrain.png" alt="terrain.png"/>
</div>
<h1><a class="anchor" id="terrainIntroduction"></a>
Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>This sample uses OpenGL ES 3.0.</dd></dl>
<p>The source for this sample can be found in the folder of the SDK.</p>
<dl class="section note"><dt>Note</dt><dd>This sample involves several advanced OpenGL techniques to achieve its goals:<ul>
<li>Sampling textures in vertex shader</li>
<li>Instanced drawing</li>
<li>Uniform buffer objects</li>
<li>Pixel buffer objects</li>
<li>2D texture arrays</li>
<li>A frustum culling technique is applied as well, although that is a purely mathematical technique.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="terrainRepresentation"></a>
Representing the Terrain</h1>
<p>The terrain representation is based on the paper of Losasso and Hoppe <a href="#ref1">[1]</a>.</p>
<div class="image">
<img src="clipmap.png" alt="clipmap.png"/>
</div>
<p>The basic building block of the terrain is a tesselated square with N-by-N (in this implementation, 64-by-64) vertices. A tesselated square can be represented efficiently with a single triangle strip.</p>
<p>Generate vertex data for a block: </p>
<div class="fragment"><div class="line">    GLubyte *pv = <a class="code" href="_cube_8h.html#aebc90711c5df16dd4e6faa8b261cd828">vertices</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Block</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = 0; z &lt; <a class="code" href="gl2ext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>; z++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = 0; x &lt; <a class="code" href="gl2ext_8h.html#a9f139c614d49f2a707b6037305b0fec0">size</a>; x++)</div>
<div class="line">        {</div>
<div class="line">            pv[0] = <a class="code" href="gl2ext_8h.html#abe1577120f1766eff913e9a74879f373">x</a>;</div>
<div class="line">            pv[1] = z;</div>
<div class="line">            pv += 2;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Generate index buffer for a block: </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLushort *<a class="code" href="_f_f_t_ocean_water_2jni_2mesh_8cpp.html#a9e0d6a93ea7bcdba454b26f28b34e258">generate_block_indices</a>(GLushort *pi, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vertex_buffer_offset,</div>
<div class="line">                                               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stamp out triangle strips back and forth.</span></div>
<div class="line">    <span class="keywordtype">int</span> pos = vertex_buffer_offset;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> strips = height - 1;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// After even indices in a strip, always step to next strip.</span></div>
<div class="line">    <span class="comment">// After odd indices in a strip, step back again and one to the right or left.</span></div>
<div class="line">    <span class="comment">// Which direction we take depends on which strip we&#39;re generating.</span></div>
<div class="line">    <span class="comment">// This creates a zig-zag pattern.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = 0; z &lt; strips; z++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> step_even = <a class="code" href="gl2ext_8h.html#a9a82cf3caff84cabc4598e2619faac17">width</a>;</div>
<div class="line">        <span class="keywordtype">int</span> step_odd = ((z &amp; 1) ? -1 : 1) - step_even;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We don&#39;t need the last odd index.</span></div>
<div class="line">        <span class="comment">// The first index of the next strip will complete this strip.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = 0; x &lt; 2 * width - 1; x++)</div>
<div class="line">        {</div>
<div class="line">            *pi++ = pos;</div>
<div class="line">            pos += (x &amp; 1) ? step_odd : step_even;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// There is no new strip, so complete the block here.</span></div>
<div class="line">    *pi++ = pos;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Return updated index buffer pointer.</span></div>
<div class="line">    <span class="comment">// More explicit than taking reference to pointer.</span></div>
<div class="line">    <span class="keywordflow">return</span> pi;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This block lies on the horizontal plane (XZ-plane) and is stitched together in a grid to draw an arbitrarely vast terrain as seen above.</p>
<p>To avoid aliasing and excessive detail in drawing, terrain which is drawn farther away requires lower resolution. This is achieved by scaling up the basic N-by-N block in powers of two.</p>
<dl class="section note"><dt>Note</dt><dd>Like mipmap levels, clipmap level 0 denotes the level with highest detail. In this sample, 10 clipmap levels in total are used.</dd></dl>
<p>When stitching together the clipmap, there are small holes which must be filled. This is done by drawing smaller "fixup" and/or "trim" regions as seen above. Strips of degenerate triangles must also be drawn on the edges where the clipmap level changes.</p>
<p>The degenerate triangles which connect level N and N + 1 are drawn using vertices from level N. Trim regions which connect level N and N + 1 are drawn using vertices from level N + 1.</p>
<p>The exact layout of blocks must be carefully planned to ensure a seamless terrain. An important thing to note is that the distance between two adjacent N-by-N blocks is N - 1. Most offsets seen in the sample code use this distance with the occasional 2 texel offset to account for the width of the horizontal and vertical fixup regions.</p>
<p>The vertex buffer along with the index buffer is uploaded once to the GPU at startup.</p>
<h1><a class="anchor" id="terrainGridSnap"></a>
Snapping the Terrain to a Grid</h1>
<p>Positions of blocks are moved along with the camera in discrete steps. Moving in discrete steps is important to avoid a vertex "swimming" effect. As the camera moves, lower clipmap levels can change position while higher levels don't and therefore the trim region used to connect two clipmap levels might have to change to be able to fill the entire terrain.</p>
<p>On every frame, clipmap level offsets are computed as such: </p>
<div class="fragment"><div class="line"><span class="comment">// The clipmap levels only move in steps of texture coordinates.</span></div>
<div class="line"><span class="comment">// Computes top-left world position for the levels.</span></div>
<div class="line"><a class="code" href="structvec2.html">vec2</a> <a class="code" href="class_ground_mesh.html#a76a3e8b28e9b1f08afe3d26019f01bb7">GroundMesh::get_offset_level</a>(<span class="keyword">const</span> <a class="code" href="structvec2.html">vec2</a>&amp; camera_pos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (level == 0) <span class="comment">// Must follow level 1 as trim region is fixed.</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="class_ground_mesh.html#a76a3e8b28e9b1f08afe3d26019f01bb7">get_offset_level</a>(camera_pos, 1) + <a class="code" href="structvec2.html">vec2</a>(size &lt;&lt; 1);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="structvec2.html">vec2</a> scaled_pos = camera_pos / <a class="code" href="structvec2.html">vec2</a>(<a class="code" href="class_ground_mesh.html#a8102fcc1cd0e78b004b54712acd914eb">clipmap_scale</a>); <span class="comment">// Snap to grid in the appropriate space.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Snap to grid of next level. I.e. we move the clipmap level in steps of two.</span></div>
<div class="line">        <a class="code" href="structvec2.html">vec2</a> snapped_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a99ca5515ed160850c71b3ab93823fa77">vec_floor</a>(scaled_pos / <a class="code" href="structvec2.html">vec2</a>(1 &lt;&lt; (level + 1))) * <a class="code" href="structvec2.html">vec2</a>(1 &lt;&lt; (level + 1));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Apply offset so all levels align up neatly.</span></div>
<div class="line">        <span class="comment">// If snapped_pos is equal for all levels,</span></div>
<div class="line">        <span class="comment">// this causes top-left vertex of level N to always align up perfectly with top-left interior corner of level N + 1.</span></div>
<div class="line">        <span class="comment">// This gives us a bottom-right trim region.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Due to the flooring, snapped_pos might not always be equal for all levels.</span></div>
<div class="line">        <span class="comment">// The flooring has the property that snapped_pos for level N + 1 is less-or-equal snapped_pos for level N.</span></div>
<div class="line">        <span class="comment">// If less, the final position of level N + 1 will be offset by -2 ^ N, which can be compensated for with changing trim-region to top-left.</span></div>
<div class="line">        <a class="code" href="structvec2.html">vec2</a> pos = snapped_pos - <a class="code" href="structvec2.html">vec2</a>((2 * (size - 1)) &lt;&lt; level);</div>
<div class="line">        <span class="keywordflow">return</span> pos;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Offsets of blocks within a clipmap level are relative to the clipmap level offset.</p>
<h1><a class="anchor" id="terrainVertexTextures"></a>
Sampling Textures in Vertex Shader</h1>
<p>OpenGL ES 3.0 added guaranteed support for sampling textures in the vertex shader. This allows the application to dynamically update vertex data in ways which would have been costly with older methods. The vertex buffer is fixed, and never has to be updated. (see <a class="el" href="shaders_8h.html">advanced_samples/Terrain/jni/shaders.h</a>)</p>
<p>While the vertex buffer represents the fixed grid structure in the horizontal plane, the vertical Y component is dynamic and is sampled from a heightmap texture.</p>
<dl class="section note"><dt>Note</dt><dd>Automatic mip-mapping cannot be used in vertex shaders (no derivatives). If sampling from a mip-mapped texture, an explicit level-of-detail must be provided, by using e.g. <b>textureLod</b>. In this sample however, mipmapped textures are not used, so using <b>texture</b> directly is safe.</dd></dl>
<h1><a class="anchor" id="terrainHeightmapRepresentation"></a>
Heightmap Representation</h1>
<p>Each clipmap level is backed by its own 255x255 texture. As the size for each level is the same, it is convenient and efficient to use a 2D texture array, introduced in OpenGL ES 3.0. Using a texture array avoids having to bind different textures for drawing different clipmap levels which reduces the number of draw calls required.</p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures(1, &amp;texture));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, texture));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use half-float as we don&#39;t need full float precision.</span></div>
<div class="line">    <span class="comment">// GL_RG16UI would work as well as we don&#39;t need texture filtering.</span></div>
<div class="line">    <span class="comment">// 8-bit does not give sufficient precision except for low-detail heightmaps.</span></div>
<div class="line">    <span class="comment">// Use two components to allow storing current level&#39;s height as well as the height of the next level.</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 1, GL_RG16F, size, size, <a class="code" href="gl2ext_8h.html#a9dddc5400c097d888e928278d710f8a2">levels</a>));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MAG_FILTER, GL_NEAREST));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_MIN_FILTER, GL_NEAREST));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The repeat is crucial here. This allows us to update small sections of the texture when moving the camera.</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_WRAP_S, GL_REPEAT));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, GL_TEXTURE_WRAP_T, GL_REPEAT));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#ad2b4c60c1e4d3d18801478cf7a7ad2b7">GL_TEXTURE_2D_ARRAY</a>, 0));</div>
</div><!-- fragment --> <h1><a class="anchor" id="terrainHeightmapUpdate"></a>
Heightmap Update</h1>
<p>Using the clipmap method, only parts of the terrain will be visible in a LOD at a time. As the camera moves around, new area has to be updated in the heightmap textures to give the illusion of a seamless, never-ending terrain.</p>
<p>The heightmap can be updated either by uploading new data from pre-computed heightmaps or using frame buffer objects with shaders to update the heightmap procedurally.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_heightmap.html#ad08e6a274961738c0f1d511f17ba4ae6">Heightmap::update_region</a>(<a class="code" href="structvec2.html">vec2</a> *buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; pixel_offset, <span class="keywordtype">int</span> tex_x, <span class="keywordtype">int</span> tex_y,</div>
<div class="line">                              <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,</div>
<div class="line">                              <span class="keywordtype">int</span> start_x, <span class="keywordtype">int</span> start_y,</div>
<div class="line">                              <span class="keywordtype">int</span> level)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (width == 0 || height == 0)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Here we could either stream a &quot;real&quot; heightmap, or generate it procedurally on the GPU by rendering to these regions.</span></div>
<div class="line"></div>
<div class="line">    buffer += pixel_offset;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> = 0; <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> &lt; <a class="code" href="gl2ext_8h.html#aa352f2804b9902ac30769c00dde75d5f">height</a>; <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>++)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; <a class="code" href="gl2ext_8h.html#a9a82cf3caff84cabc4598e2619faac17">width</a>; x++)</div>
<div class="line">            buffer[<a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a> * width + x] = <a class="code" href="class_heightmap.html#af06c14882760ab2180cb6dce4e04e3af">compute_heightmap</a>(start_x + x, start_y + <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>, level);</div>
<div class="line"></div>
<div class="line">    UploadInfo info;</div>
<div class="line">    info.<a class="code" href="structvec2.html#a002d3519d48fe3cd79729b5b0ded74bf">x</a> = tex_x;</div>
<div class="line">    info.y = tex_y;</div>
<div class="line">    info.width = <a class="code" href="gl2ext_8h.html#a9a82cf3caff84cabc4598e2619faac17">width</a>;</div>
<div class="line">    info.height = <a class="code" href="gl2ext_8h.html#aa352f2804b9902ac30769c00dde75d5f">height</a>;</div>
<div class="line">    info.level = <a class="code" href="gl2ext_8h.html#a2b536fca24f51d6a849aed325793e661">level</a>;</div>
<div class="line">    info.offset = pixel_offset * <span class="keyword">sizeof</span>(<a class="code" href="structvec2.html">vec2</a>);</div>
<div class="line">    <a class="code" href="class_heightmap.html#adcfeb591c5b3bfbfc16deccc6a4f3688">upload_info</a>.push_back(info);</div>
<div class="line"></div>
<div class="line">    pixel_offset += width * <a class="code" href="gl2ext_8h.html#aa352f2804b9902ac30769c00dde75d5f">height</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This sample implements heightmap update by copying samples from a pre-computed 1024x1024 buffer which is generated by band-pass filtering white noise. The copy is done asynchronously using pixel buffer objects.</p>
<p>The clipmap rendering code uses the GL_REPEAT texture wrapping feature to ensure that only a small part of the texture has to be updated every time the camera moves.</p>
<p>The pre-computed heightmap is repeated to make the terrain infinite.</p>
<dl class="section note"><dt>Note</dt><dd>Along with heightmap, a corresponding normal map is usually used. For clarity, this is omitted. Normal maps can be computed on-the-fly in the vertex shader by sampling the heightmap, or updated along with the heightmap. The fragment shader in this sample assigns color based on the height of the vertex.</dd></dl>
<h1><a class="anchor" id="terrainHeightmapBlending"></a>
Heightmap Blending</h1>
<p>The resolution of the clipmap abruptly changes resolution between levels. This discontinuity in detail results in artifacts. To avoid this, two heightmap levels (current and next) are sampled and blended together in the vertex shader.</p>
<p>To avoid filtering the heightmap value from the next clipmap level, the filtered version of the heightmap is precomputed and included along with the height of the current level.</p>
<div class="fragment"><div class="line"><span class="comment">// Compute the height at texel (x, y) for cliplevel.</span></div>
<div class="line"><span class="comment">// Also compute the sample for the lower resolution (with simple bilinear).</span></div>
<div class="line"><span class="comment">// This avoids an extra texture lookup in vertex shader, avoids complex offsetting and having to use GL_LINEAR.</span></div>
<div class="line"><a class="code" href="structvec2.html">vec2</a> <a class="code" href="class_heightmap.html#af06c14882760ab2180cb6dce4e04e3af">Heightmap::compute_heightmap</a>(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> <a class="code" href="gl2ext_8h.html#a1675d9d7bb68e1657ff028643b4037e3">y</a>, <span class="keywordtype">int</span> level)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> height = <a class="code" href="class_heightmap.html#a2dfcc9660f148f1b7eef0d7128ea396f">sample_heightmap</a>(x &lt;&lt; level, y &lt;&lt; level);</div>
<div class="line">    <span class="keywordtype">float</span> heights[2][2];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; j++)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++)</div>
<div class="line">            heights[j][i] = <a class="code" href="class_heightmap.html#a2dfcc9660f148f1b7eef0d7128ea396f">sample_heightmap</a>(((x + i) &amp; ~1) &lt;&lt; level, ((y + j) &amp; ~1) &lt;&lt; level);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structvec2.html">vec2</a>(</div>
<div class="line">        height,</div>
<div class="line">        (heights[0][0] + heights[0][1] + heights[1][0] + heights[1][1]) * 0.25<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>);</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="terrainFrustumCulling"></a>
Frustum Culling</h1>
<p>When drawing the terrain, most of the terrain will not be visible. To improve performance it is important to avoid drawing blocks which will never be shown.</p>
<p>This terrain sample implements simple frustum culling based on axis-aligned bounding boxes.</p>
<p>The idea of this frustum culling implementation is to represent all planes of the camera frustum as plane equations. When an axis-aligned box is tested for visibility, we check every corner of the bounding box against the frustum planes, one plane at a time.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="class_frustum.html#af7b2a3e4f1764c9154dc1dd588479308">Frustum::intersects_aabb</a>(<span class="keyword">const</span> <a class="code" href="struct_a_a_b_b.html">AABB</a>&amp; aabb)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">    <span class="comment">// If all corners of an axis-aligned bounding box are on the &quot;wrong side&quot; (negative distance)</span></div>
<div class="line">    <span class="comment">// of at least one of the frustum planes, we can safely cull the mesh.</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> corners[8];</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; 8; c++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Require 4-dimensional coordinates for plane equations.</span></div>
<div class="line">        corners[c] = <a class="code" href="structvec4.html">vec4</a>(aabb.<a class="code" href="struct_a_a_b_b.html#a74708692bf7f8b50681c9d9ff3c90a2b">corner</a>(c), 1.0f);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 6; p++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">bool</span> inside_plane = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; 8; c++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// If dot product &gt; 0, we&#39;re &quot;inside&quot; the frustum plane,</span></div>
<div class="line">            <span class="comment">// otherwise, outside.</span></div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(corners[c], <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[p]) &gt; 0.0f)</div>
<div class="line">            {</div>
<div class="line">                inside_plane = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!inside_plane)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> If every corner of the bounding box is on the "wrong" side of a plane (negative distance), we can prove that the mesh contained inside the box will never be drawn. Thus, the mesh can be culled if we can prove invisibility for at least <em>one</em> of the frustum planes.</p>
<p>To obtain the plane equations for the frustum in world space, an inverse transform from clip space is done.</p>
<div class="fragment"><div class="line"><a class="code" href="class_frustum.html#a172ae3492592e3ac891642299d628494">Frustum::Frustum</a>(<span class="keyword">const</span> <a class="code" href="structmat4.html">mat4</a>&amp; view_projection)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Frustum planes are in world space.</span></div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> inv = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a44f87f6b3937c060e77ff582e09f1e7f">mat_inverse</a>(view_projection);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get world-space coordinates for clip-space bounds.</span></div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> lbn = inv * <a class="code" href="structvec4.html">vec4</a>(-1, -1, -1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> ltn = inv * <a class="code" href="structvec4.html">vec4</a>(-1,  1, -1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> lbf = inv * <a class="code" href="structvec4.html">vec4</a>(-1, -1,  1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> rbn = inv * <a class="code" href="structvec4.html">vec4</a>( 1, -1, -1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> rtn = inv * <a class="code" href="structvec4.html">vec4</a>( 1,  1, -1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> rbf = inv * <a class="code" href="structvec4.html">vec4</a>( 1, -1,  1, 1);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> rtf = inv * <a class="code" href="structvec4.html">vec4</a>( 1,  1,  1, 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Divide by w.</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> lbn_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(lbn);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> ltn_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(ltn);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> lbf_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(lbf);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> rbn_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(rbn);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> rtn_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(rtn);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> rbf_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(rbf);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> rtf_pos = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ace05c55c0ab6018da5bcd47fdcccfb02">vec_project</a>(rtf);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get plane normals for all sides of frustum.</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> left_normal   = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(lbf_pos - lbn_pos, ltn_pos - lbn_pos));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> right_normal  = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(rtn_pos - rbn_pos, rbf_pos - rbn_pos));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> top_normal    = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(ltn_pos - rtn_pos, rtf_pos - rtn_pos));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> bottom_normal = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(rbf_pos - rbn_pos, lbn_pos - rbn_pos));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> near_normal   = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(ltn_pos - lbn_pos, rbn_pos - lbn_pos));</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> far_normal    = <a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a6234b03f7031b1fd97b2f1ab954aed76">vec_normalize</a>(<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#a7f37d143f77bbd19e4165ab6baea7f43">vec_cross</a>(rtf_pos - rbf_pos, lbf_pos - rbf_pos));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Plane equations compactly represent a plane in 3D space.</span></div>
<div class="line">    <span class="comment">// We want a way to compute the distance to the plane while preserving the sign to know which side we&#39;re on.</span></div>
<div class="line">    <span class="comment">// Let:</span></div>
<div class="line">    <span class="comment">//    O: an arbitrary point on the plane</span></div>
<div class="line">    <span class="comment">//    N: the normal vector for the plane, pointing in the direction</span></div>
<div class="line">    <span class="comment">//       we want to be &quot;positive&quot;.</span></div>
<div class="line">    <span class="comment">//    X: Position we want to check.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Distance D to the plane can now be expressed as a simple operation:</span></div>
<div class="line">    <span class="comment">// D = dot((X - O), N) = dot(X, N) - dot(O, N)</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// We can reduce this to one dot product by assuming that X is four-dimensional (4th component = 1.0).</span></div>
<div class="line">    <span class="comment">// The normal can be extended to four dimensions as well:</span></div>
<div class="line">    <span class="comment">// X&#39; = vec4(X, 1.0)</span></div>
<div class="line">    <span class="comment">// N&#39; = vec4(N, -dot(O, N))</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// The expression now reduces to: D = dot(X&#39;, N&#39;)</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[0] = <a class="code" href="structvec4.html">vec4</a>(near_normal,   -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(near_normal, lbn_pos));   <span class="comment">// Near</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[1] = <a class="code" href="structvec4.html">vec4</a>(far_normal,    -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(far_normal, lbf_pos));    <span class="comment">// Far</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[2] = <a class="code" href="structvec4.html">vec4</a>(left_normal,   -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(left_normal, lbn_pos));   <span class="comment">// Left</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[3] = <a class="code" href="structvec4.html">vec4</a>(right_normal,  -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(right_normal, rbn_pos));  <span class="comment">// Right</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[4] = <a class="code" href="structvec4.html">vec4</a>(top_normal,    -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(top_normal, ltn_pos));    <span class="comment">// Top</span></div>
<div class="line">    <a class="code" href="class_frustum.html#a53a5d72989bf98f6936e9b7afba6d1fa">planes</a>[5] = <a class="code" href="structvec4.html">vec4</a>(bottom_normal, -<a class="code" href="_f_f_t_ocean_water_2jni_2vector__math_8h.html#ae253b39d3fec71b2d721d527cbb445e8">vec_dot</a>(bottom_normal, lbn_pos)); <span class="comment">// Bottom</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="terrainUniformBuffers"></a>
Using Uniform Buffers</h1>
<p>OpenGL ES 3.0 introduced a new way of passing uniform data to shaders. Instead of making many calls to <b>glUniform*</b> when uniforms change, it is possible to let the uniform data be backed by a regular OpenGL buffer object.</p>
<p>A very simple example of this (GLSL) is: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span><a class="code" href="scan_8cs.html#abc5bc4dfe74a37a3a6850b9a15630dc7">layout</a>(std140) <a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a>; <span class="comment">// Use std140 packing rules for uniform blocks.</span></div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> aVertex;</div>
<div class="line">uniform VertexData</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> viewProjection; <span class="comment">// Let the view-projection matrix be backed a buffer object.</span></div>
<div class="line">} vertex;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    gl_Position = vertex.viewProjection * aVertex;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is important to note that while the uniform buffer data was accessed via the name <b>vertex</b>, for interfacing with other shaders and/or OpenGL, the <em>block name</em>, <b>VertexData</b> is used.</dd></dl>
<p>It is possible to use multiple uniform blocks inside a shader, which makes it necessary to access uniform blocks by index.</p>
<p>After linking the shader program, we can query it with:</p>
<div class="fragment"><div class="line">GLuint block = glGetUniformBlockIndex(program, <span class="stringliteral">&quot;VertexData&quot;</span>); <span class="comment">// Note the use of VertexData and not vertex.</span></div>
</div><!-- fragment --><p>Now, we want to specify where the uniform buffer will pull data from: </p>
<div class="fragment"><div class="line">glUniformBlockBinding(program, block, 0);</div>
</div><!-- fragment --><p>The uniform buffer now sources data from binding 0. To bind a buffer for the shader to use, we need to use the new indiced versions of <b>glBindBuffer</b>.</p>
<div class="fragment"><div class="line">glBindBufferBase(GL_UNIFORM_BUFFER, 0, buffer_object); <span class="comment">// Binds the entire object.</span></div>
<div class="line">glBindBufferRange(GL_UNIFORM_BUFFER, 0, buffer_object, <a class="code" href="gl2ext_8h.html#a56ae4f2c17db21521c5849fe34735fb2">offset</a>, size); <span class="comment">// Binds a range of the object.</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>These new calls only sets state for shaders. If the buffer is to be used with regular OpenGL calls such as uploading data, the normal <b>glBindBuffer</b> is still used.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Initialize an UBO.</span></div>
<div class="line">glBindBuffer(GL_UNIFORM_BUFFER, buffer_object);</div>
<div class="line">glBufferData(GL_UNIFORM_BUFFER, size, NULL, GL_DYNAMIC_DRAW);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><b>glBindBufferRange</b> requires a certain alignment on the offset and size. To query exactly which alignment is required, <b>glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, ...)</b> can be called.</dd></dl>
<h1><a class="anchor" id="terrainInstancing"></a>
Drawing the Terrain with Instanced Drawing</h1>
<p>The clipmap consists of simple building blocks which are drawn many times. To drastically reduce the number of draw calls required, the blocks can be drawn using instancing, which was introduced in OpenGL ES 3.0.</p>
<p>Uniform buffer objects are used to access per-instance data in the vertex shader. When drawing instanced, a built-in variable <b>gl_InstanceID</b> is available, which can be used to access an array of per-instance data in a buffer object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_ground_mesh.html#a5f71083a7cc2a277418d5246aa8344d8">GroundMesh::render_draw_list</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;DrawInfo&gt;::const_iterator itr = <a class="code" href="class_ground_mesh.html#a90d4f800ebc0942c9317ca6305df33ec">draw_list</a>.begin(); itr != <a class="code" href="class_ground_mesh.html#a90d4f800ebc0942c9317ca6305df33ec">draw_list</a>.end(); ++itr)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!itr-&gt;instances)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Bind uniform buffer at correct offset.</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBufferRange(GL_UNIFORM_BUFFER, 0, <a class="code" href="class_ground_mesh.html#ad74a12e855666a036fe0389f038e0ea3">uniform_buffer</a>,</div>
<div class="line">                    itr-&gt;uniform_buffer_offset, <a class="code" href="_ground_mesh_8cpp.html#aa1ff5556f60e74212a1889a7fcc2a903">realign_offset</a>(itr-&gt;instances * <span class="keyword">sizeof</span>(InstanceData), <a class="code" href="class_ground_mesh.html#a62c5596b954e1dd57eaf1f0d6eac6ad5">uniform_buffer_align</a>)));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Draw all instances.</span></div>
<div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawElementsInstanced(GL_TRIANGLE_STRIP, itr-&gt;indices, GL_UNSIGNED_SHORT,</div>
<div class="line">            reinterpret_cast&lt;const GLvoid*&gt;(itr-&gt;index_buffer_offset * <span class="keyword">sizeof</span>(GLushort)), itr-&gt;instances));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_ground_mesh.html#a762b21b23d44192cb7cb1dc211b75f8d">GroundMesh::render</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a draw-list.</span></div>
<div class="line">    <a class="code" href="class_ground_mesh.html#a08097c7c9de3c5b93421735eba48760b">update_draw_list</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Explicitly bind and unbind GL state to ensure clarity.</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray(<a class="code" href="class_ground_mesh.html#ac314f0d6c9a0b5b9aa91fe5315bd2d7e">vertex_array</a>));</div>
<div class="line">    <a class="code" href="class_ground_mesh.html#a5f71083a7cc2a277418d5246aa8344d8">render_draw_list</a>();</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray(0));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_UNIFORM_BUFFER, 0));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBufferBase(GL_UNIFORM_BUFFER, 0, 0));</div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="terrainReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://research.microsoft.com/en-us/um/people/hoppe/geomclipmap.pdf">http://research.microsoft.com/en-us/um/people/hoppe/geomclipmap.pdf</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
