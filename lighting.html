<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Lighting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lighting.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lighting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Basic lighting using OpenGL ES 2.0.</p>
<h1><a class="anchor" id="lightingIntroduction"></a>
Introduction</h1>
<p>The source for this sample can be found in the folder of the SDK.</p>
<p>This tutorial will take the application we created in <a class="el" href="simpleCube.html">Simple Cube</a> and teach you how to add lighting to it. No changes are needed to the Java side of the application, all the changes that happen are on the native side.</p>
<h1><a class="anchor" id="lightingNewProject"></a>
Creating a New Project</h1>
<p>For the tutorial, the <a class="el" href="simpleCube.html">Simple Cube</a> project will be used as a starting point. So either copy the project or create a completely new project and include the source files from the previous project. The project should be called <b>Lighting</b> and the package name should be called <em><a class="el" href="namespacecom_1_1arm_1_1malideveloper_1_1openglessdk_1_1lighting.html">com.arm.malideveloper.openglessdk.lighting</a></em>. Finally, the activity class (previously <em><a class="el" href="_simple_cube_8java.html">SimpleCube.java</a></em>) should be renamed <b><a class="el" href="_lighting_8java.html">Lighting.java</a></b> using Eclipse (this ensures references to the activity get updated elsewhere in the project).</p>
<h1><a class="anchor" id="lightingIntroduction2"></a>
Introduction</h1>
<p>So far we have just rendered our objects with simple colours. From a lighting point of view, everything in the scene is fully lit, it has exactly the colour we specified. To make the scene more realistic we have to introduce the concept of lights to the scene. In this tutorial we will introduce the concepts of vertex normals and diffuse, specular, and ambient light.</p>
<p>OpenGL ES 2.0 onwards does not have a concept of lights. It is up to the developer to devise and implement a method for simulating light within a scene. Like everything in computer graphics, lighting is faked. This means that instead of attempting to accurately model the flow of photons throughout the scene (see: ray-tracing), we are instead going to use an approximation which gives "good-enough" results.</p>
<p>What we are going to implement here is a directional light and we're going to do the calculations per vertex. There are certain limitations to this approach that we take a look at along the way. We will be making certain assumptions about the scene, the lights, and the materials being used to make this tutorial as simple as possible. These will be pointed out as we go.</p>
<p>We are going to using the Phong reflection model as the basis for this tutorial, see <a href="http://en.wikipedia.org/wiki/Phong_reflection_model">Wikipedia</a> for more information.</p>
<h1><a class="anchor" id="lightingPreparation"></a>
Preparation</h1>
<p>Before we get stuck into the interesting parts of this tutorial we must first add a few bits to make it easier later on. Because, traditionally, lighting a cube correctly is quite tricky (it doesn't necessarily show off the effects very nicely), we're going to turn the cube into a <b>very</b> simple approximation of a sphere.</p>
<p>All the changes we're going to make in this tutorial are inside <b>Native.cpp</b>.</p>
<p>To this end, we are going to add some extra geometry. We're going to add an extra vertex per face, right in the middle of each face but sticking out a bit more. The <em>vertices</em> array should now look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#ab52e9e7338b8be963a3fe01d20c4ee7b">verticies</a>[] = { 1.0f,  1.0f, -1.0f, <span class="comment">/* Back. */</span></div><div class="line">                       -1.0f,  1.0f, -1.0f,</div><div class="line">                        1.0f, -1.0f, -1.0f,</div><div class="line">                       -1.0f, -1.0f, -1.0f,</div><div class="line">                        0.0f,  0.0f, -2.0f,</div><div class="line">                       -1.0f,  1.0f,  1.0f, <span class="comment">/* Front. */</span></div><div class="line">                        1.0f,  1.0f,  1.0f,</div><div class="line">                       -1.0f, -1.0f,  1.0f,</div><div class="line">                        1.0f, -1.0f,  1.0f,</div><div class="line">                        0.0f,  0.0f,  2.0f,</div><div class="line">                       -1.0f,  1.0f, -1.0f, <span class="comment">/* Left. */</span></div><div class="line">                       -1.0f,  1.0f,  1.0f,</div><div class="line">                       -1.0f, -1.0f, -1.0f,</div><div class="line">                       -1.0f, -1.0f,  1.0f,</div><div class="line">                       -2.0f,  0.0f,  0.0f,</div><div class="line">                        1.0f,  1.0f,  1.0f, <span class="comment">/* Right. */</span></div><div class="line">                        1.0f,  1.0f, -1.0f,</div><div class="line">                        1.0f, -1.0f,  1.0f,</div><div class="line">                        1.0f, -1.0f, -1.0f,</div><div class="line">                        2.0f,  0.0f,  0.0f,</div><div class="line">                       -1.0f, -1.0f,  1.0f, <span class="comment">/* Bottom. */</span></div><div class="line">                        1.0f, -1.0f,  1.0f,</div><div class="line">                       -1.0f, -1.0f, -1.0f,</div><div class="line">                        1.0f, -1.0f, -1.0f,</div><div class="line">                        0.0f, -2.0f,  0.0f,</div><div class="line">                       -1.0f,  1.0f, -1.0f, <span class="comment">/* Top. */</span></div><div class="line">                        1.0f,  1.0f, -1.0f,</div><div class="line">                       -1.0f,  1.0f,  1.0f,</div><div class="line">                        1.0f,  1.0f,  1.0f,</div><div class="line">                        0.0f,  2.0f,  0.0f</div><div class="line">                      };</div></div><!-- fragment --><p> To make sure the vertices are coloured correctly we need to add an extra colour per face in our <em>colour</em> array:</p>
<div class="fragment"><div class="line"><a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#a315513b25fb7caa676de83aa6794d4a2">colour</a>[] = {1.0f, 0.0f, 0.0f, <span class="comment">/* Back. */</span></div><div class="line">                    1.0f, 0.0f, 0.0f,</div><div class="line">                    1.0f, 0.0f, 0.0f,</div><div class="line">                    1.0f, 0.0f, 0.0f,</div><div class="line">                    1.0f, 0.0f, 0.0f,</div><div class="line">                    0.0f, 1.0f, 0.0f, <span class="comment">/* Front. */</span></div><div class="line">                    0.0f, 1.0f, 0.0f,</div><div class="line">                    0.0f, 1.0f, 0.0f,</div><div class="line">                    0.0f, 1.0f, 0.0f,</div><div class="line">                    0.0f, 1.0f, 0.0f,</div><div class="line">                    0.0f, 0.0f, 1.0f, <span class="comment">/* Left. */</span></div><div class="line">                    0.0f, 0.0f, 1.0f,</div><div class="line">                    0.0f, 0.0f, 1.0f,</div><div class="line">                    0.0f, 0.0f, 1.0f,</div><div class="line">                    0.0f, 0.0f, 1.0f,</div><div class="line">                    1.0f, 1.0f, 0.0f, <span class="comment">/* Right. */</span></div><div class="line">                    1.0f, 1.0f, 0.0f,</div><div class="line">                    1.0f, 1.0f, 0.0f,</div><div class="line">                    1.0f, 1.0f, 0.0f,</div><div class="line">                    1.0f, 1.0f, 0.0f,</div><div class="line">                    0.0f, 1.0f, 1.0f, <span class="comment">/* Bottom. */</span></div><div class="line">                    0.0f, 1.0f, 1.0f,</div><div class="line">                    0.0f, 1.0f, 1.0f,</div><div class="line">                    0.0f, 1.0f, 1.0f,</div><div class="line">                    0.0f, 1.0f, 1.0f,</div><div class="line">                    1.0f, 0.0f, 1.0f, <span class="comment">/* Top. */</span></div><div class="line">                    1.0f, 0.0f, 1.0f,</div><div class="line">                    1.0f, 0.0f, 1.0f,</div><div class="line">                    1.0f, 0.0f, 1.0f,</div><div class="line">                    1.0f, 0.0f, 1.0f</div><div class="line">                   };</div></div><!-- fragment --><p> To make use of these new vertices, we need to adjust the indices into our vertex array to draw the correct triangles. We are now going to draw four triangles per face, all of which will use the vertex we added in the middle of the face. Take care to remember that the winding of the vertices is important (front facing polygons must have anti-clockwise winding).</p>
<p>The <em>indicies</em> array should now look like this:</p>
<div class="fragment"><div class="line">GLushort <a class="code" href="gl2ext_8h.html#a94ae715eebfc1eb65456c0ab9b97f1e9">indices</a>[] = {0,  2,  4,  0,  4,  1,  1,  4,  3,  2,  3,  4,  <span class="comment">/* Back. */</span></div><div class="line">                      5,  7,  9,  5,  9,  6,  6,  9,  8,  7,  8,  9,  <span class="comment">/* Front. */</span></div><div class="line">                      10, 12, 14, 10, 14, 11, 11, 14, 13, 12, 13, 14, <span class="comment">/* Left. */</span></div><div class="line">                      15, 17, 19, 15, 19, 16, 16, 19, 18, 17, 18, 19, <span class="comment">/* Right. */</span></div><div class="line">                      20, 22, 24, 20, 24, 21, 21, 24, 23, 22, 23, 24, <span class="comment">/* Bottom. */</span></div><div class="line">                      25, 27, 29, 25, 29, 26, 26, 29, 28, 27, 28, 29  <span class="comment">/* Top. */</span></div><div class="line">                     };</div></div><!-- fragment --><p> Lastly in <em>renderFrame</em>, we need to increase the number of vertices drawn in our draw call (from 36 to 72) because we are drawing twice as many triangles. So it looks like this:</p>
<div class="fragment"><div class="line">    glDrawElements(GL_TRIANGLES, 72, GL_UNSIGNED_SHORT, indices);</div></div><!-- fragment --> <h1><a class="anchor" id="lightingNormals"></a>
Normals</h1>
<p>For most lighting models, it's important to know which way all of the polygons in your scene are facing. For example, if we know a light is pointing from a certain direction, in order to know whether a polygon should be lit by that light we must know if it's facing towards the light or not. So, you may be thinking, the system should know which way the polygon is facing because we specified it. We specified the vertices with the correct winding to show which way we wanted them to face and we provide a transformation to move the polygons to the correct place.</p>
<p>There are two reasons we don't use this information:</p><ol type="1">
<li>There is no mechanism in an OpenGL ES shader to get at this information.</li>
<li>Specifying this information separately allows us to do powerful and exciting things by not being strictly accurate.</li>
</ol>
<p>We use what are known as "surface normals" or just "normals" to encode the required information. For every vertex in the scene we provide a vector which points perpendicularly from the surface it represents.</p>
<p>To send this data to the GPU we use the exact same mechanism as for sending colour data and position data to the GPU. We define an array with per vertex normals in it, we get the location of the normals variable in the vertex shader and then upload the data to the GPU using glVertexAttribPointer and glEnableVertexAttribArray.</p>
<ol type="1">
<li><p class="startli">We add an attribute in the <b>vertex shader</b> for the vertex normals:</p>
<div class="fragment"><div class="line">        <span class="stringliteral">&quot;attribute vec3 vertexNormal;\n&quot;</span></div></div><!-- fragment --></li>
<li><p class="startli">Create a global variable to hold vertex normal attribute location:</p>
<div class="fragment"><div class="line"><a class="code" href="gl2ext_8h.html#adda687347282e5405e89b4fc19a1f8e2">GLuint</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#accc2e61648e59c8edd75f96a09128793">vertexNormalLocation</a>;</div></div><!-- fragment --></li>
<li><p class="startli">Get the location of this attribute from the host side in <b>setupGraphics</b>:</p>
<div class="fragment"><div class="line">    vertexNormalLocation = glGetAttribLocation(<a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#afbb194c6ac35a64ae6589ffecd92f6c3">lightingProgram</a>, <span class="stringliteral">&quot;vertexNormal&quot;</span>);</div></div><!-- fragment --></li>
<li><p class="startli">Create an array with all the vertex normals in it (like for vertex positions and colours):</p>
<div class="fragment"><div class="line"><a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> <a class="code" href="tutorials_2_lighting_2jni_2_native_8cpp.html#ad42b87bfb03ed9e4b1c35311462cac74">normals</a>[] = { 1.0f,  1.0f, -1.0f, <span class="comment">/* Back. */</span></div><div class="line">                     -1.0f,  1.0f, -1.0f,</div><div class="line">                      1.0f, -1.0f, -1.0f,</div><div class="line">                     -1.0f, -1.0f, -1.0f,</div><div class="line">                      0.0f,  0.0f, -1.0f,</div><div class="line">                     -1.0f,  1.0f,  1.0f, <span class="comment">/* Front. */</span></div><div class="line">                      1.0f,  1.0f,  1.0f,</div><div class="line">                     -1.0f, -1.0f,  1.0f,</div><div class="line">                      1.0f, -1.0f,  1.0f,</div><div class="line">                      0.0f,  0.0f,  1.0f,</div><div class="line">                     -1.0f,  1.0f, -1.0f, <span class="comment">/* Left. */</span></div><div class="line">                     -1.0f,  1.0f,  1.0f,</div><div class="line">                     -1.0f, -1.0f, -1.0f,</div><div class="line">                     -1.0f, -1.0f,  1.0f,</div><div class="line">                     -1.0f,  0.0f,  0.0f,</div><div class="line">                      1.0f,  1.0f,  1.0f, <span class="comment">/* Right. */</span></div><div class="line">                      1.0f,  1.0f, -1.0f,</div><div class="line">                      1.0f, -1.0f,  1.0f,</div><div class="line">                      1.0f, -1.0f, -1.0f,</div><div class="line">                      1.0f,  0.0f,  0.0f,</div><div class="line">                     -1.0f, -1.0f,  1.0f, <span class="comment">/* Bottom. */</span></div><div class="line">                      1.0f, -1.0f,  1.0f,</div><div class="line">                     -1.0f, -1.0f, -1.0f,</div><div class="line">                      1.0f, -1.0f, -1.0f,</div><div class="line">                      0.0f, -1.0f,  0.0f,</div><div class="line">                     -1.0f,  1.0f, -1.0f, <span class="comment">/* Top. */</span></div><div class="line">                      1.0f,  1.0f, -1.0f,</div><div class="line">                     -1.0f,  1.0f,  1.0f,</div><div class="line">                      1.0f,  1.0f,  1.0f,</div><div class="line">                      0.0f,  1.0f,  0.0f</div><div class="line">                     };</div></div><!-- fragment --></li>
<li><p class="startli">Upload the data to the GPU every frame in <b>renderFrame</b>:</p>
<div class="fragment"><div class="line">    glVertexAttribPointer(vertexNormalLocation, 3, GL_FLOAT, GL_FALSE, 0, normals);</div><div class="line">    glEnableVertexAttribArray(vertexNormalLocation);</div></div><!-- fragment --><p> The vertex normal array would usually be generated by a modelling tool alongside your vertex positions. We've created them by hand here to match the vertex positions we've specified. You may notice that in our <em>normals</em> array the normals are not strictly perpendicular to the polygons they are connected to. This is so we can show off all of the light techniques we present here, in particular <a class="el" href="lighting.html#lightingSpecularLight">Specular Light</a>. For more information, see <a class="el" href="lighting.html#lightingInaccurateNormals">Messing with Normals</a>.</p>
</li>
</ol>
<h1><a class="anchor" id="lightingDiffuseLight"></a>
Diffuse Light</h1>
<p>If we think about a directional light at its most simple, we want to work out whether the light would touch the face of our polygon. If we store the direction of the light as a vector there is a simple calculation which will give us that data. The dot product of two normalised vectors will give you the cosine of the angle between those vectors (see <a href="http://en.wikipedia.org/wiki/Dot_product">http://en.wikipedia.org/wiki/Dot_product</a>). </p><dl class="section note"><dt>Note</dt><dd>Because the dot product gives you the angle between the <em>sources</em> of the vectors, we have reversed the direction of the light direction in the shader.</dd></dl>
<p>Therefore, the dot product of the light direction and the surface normal will give us the cosine of the angle between those vectors. If this angle is between -90&deg; (270&deg;) and 90&deg; the light is on the correct side of the polygon. Since the return value of dot is actually the cosine of the angle we actually want to check to see if it's between cos(90&deg;) and cos(-90&deg;) or in fact just greater than zero (cos(90&deg;) = cos(-90&deg;) = 0).</p>
<p>Figure 2 shows that the dot product of any vector on the front face of the surface will be positive. N** is the normal to the surface, and the other three vectors represent lights (with their directions reversed so that the dot product gives the correct angle). For the red and orange lights, the dot product returns cos(45&deg;) and cos(295&deg;) respectively, which are both positive values. The dot product of the normal and the green light vector is cos(155&deg;); a negative number.</p>
<div class="image">
<img src="LightingDiffuse.png" alt="LightingDiffuse.png"/>
<div class="caption">
Figure 2. Diffuse Lighting.</div></div>
<p>This would give us a binary on or off for our light, but we can to better than that. If we use the angle to directly control the intensity of the light, the surface will be brighter when the surface is more directly facing the light (e.g. cos(0&deg;) = 1) reducing as the angle increases (e.g. cos(80&deg;) = 0.17).</p>
<p>Again, looking at figure 2, the dot product of the red light and the normal (cos(45&deg;) = 0.71) is greater than the dot product of the orange sun and the normal (cos(295&deg;) = 0.42).</p>
<p>To do this in our shaders we need to make the following changes to the <b>vertex shader</b>, add these lines at the top of the <b>main</b> function:</p>
<div class="fragment"><div class="line">        <span class="stringliteral">&quot;    vec3 transformedVertexNormal = normalize((modelView * vec4(vertexNormal, 0.0)).xyz);&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 inverseLightDirection = normalize(vec3(0.0, 1.0, 1.0));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour = vec3(0.0);\n&quot;</span></div></div><!-- fragment --><p> In the same way that we transform the vertex positions by the <em>modelViewMatrix</em> we must also transform the normals so that they match up. Because normals are vectors (rather than positions) we set the <em>w</em> component of the normals to 0. This means that any translations in the model view matrix are ignored.</p>
<p>We then set up the light direction. As mentioned, the maths requires that the light direction is reversed so this is actually the direction opposite where we want the light to point. In a real world application you might pass the light direction in as a attribute and transform it by a matrix, but here we are keeping things simple.</p>
<p>Lastly, we set the fragment colour to zero, we will be incrementing this with different types of lighting as we go.</p>
<p>To actually do the diffuse calculation we need the following code:</p>
<div class="fragment"><div class="line">        <span class="stringliteral">&quot;    vec3 diffuseLightIntensity = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexDiffuseReflectionConstant = vertexColour;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float normalDotLight = max(0.0, dot(transformedVertexNormal, inverseLightDirection));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += normalDotLight * vertexDiffuseReflectionConstant * diffuseLightIntensity;\n&quot;</span></div></div><!-- fragment --><p> First we have the RGB intensity of the diffuse component of the light (we will see there are more components later). This lets you set the colour of the light (in our case it's a white light).</p>
<p>Then we set an RGB constant to describe what ratio of the diffuse light this surface should reflect. (between 0 and 1) This allows us to set the colour of the surface. For example, setting the ratio to (1.0, 0.0, 0.0) means that 100% of the red light will be reflected with 0% of the green and blue light, setting the colour of the objects to red. In this example, we can just use the vertex colours we already have for the ratio, as it will give us the desired result. In a real application however, each material type in a scene would usually define separate ratios for each of the different light components.</p>
<p>Next we do the dot product of the normal and light direction to get the cosine of the angle between the two. The call to <em>max</em> ensures that negative values (when the light is behind the surface) are ignored.</p>
<p>And lastly, we combine them all to together and add the result to the fragment colour.</p>
<p>One assumption we are making here is that the light is "parallel". For a normal spotlight, the light points at a particular spot and the further away from that spot you go the less light there is; the light is spread out like a cone. In our model, that's not the case, the light simply has a direction. This turns out to be surprisingly useful approximation though, since if a light source is sufficiently far away (e.g. the sun) then the light rays can be treated as if they are parallel rather than in a cone.</p>
<h1><a class="anchor" id="lightingAmbientLight"></a>
Ambient Light</h1>
<p>So that's great for light falling on the object directly from our light source, but what about light that's reflected from our objects in the scene? In the real world, even when things are in shadow, they are very rarely ever completely black, light reflects off almost all objects so that areas not in direct view of a light source still get touched by reflections. Modelling these interactions is what's known as "global illumination". To do this in a physics-correct way would be very complex and computationally expensive. One very easy and cheap way to simulate this is to use <em>Ambient Light</em>. Basically, we define that everything in the scene is hit by a very small uniform amount of light.</p>
<p>To do this, we add this to the <b>vertex shader</b>:</p>
<div class="fragment"><div class="line">        <span class="stringliteral">&quot;    vec3 ambientLightIntensity = vec3(0.1, 0.1, 0.1);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexAmbientReflectionConstant = vertexColour;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += vertexAmbientReflectionConstant * ambientLightIntensity;\n&quot;</span></div></div><!-- fragment --><p> This sets the RGB ambient light intensity (how much reflected light there is in the scene in our simple global illumination approximation).</p>
<p>It then sets an RGB constant to describe what ratio of the ambient light this surface should reflect (like the diffuse constant above). Again we are using the vertex colour for simplicity, but this would normal be specified separately.</p>
<p>Lastly it simply multiples the two and adds it to the accumulating fragment colour. This means that regardless of the surface normal, light direction, and eye direction, every polygon rendered will have some light on it.</p>
<h1><a class="anchor" id="lightingSpecularLight"></a>
Specular Light</h1>
<p>Finally, we want to to deal with the reflective or shiny nature of surfaces. For example, a shiny metallic surface and a matte wooden surface of the same colour will look <b>different</b> even if the light direction, light intensity, eye position and surface orientation are the same. Just using diffuse and ambient light as we have so far would mean that the surfaces look the same. What we have to take into account is the amount of light reflected from the surface directly towards the eye.</p>
<p>We can do this by first finding out which way the light is reflecting off the surface and then doing the dot product of that vector and the inverse eye direction.</p>
<p>Figure 3 shows that if we find a reflection vector <b>R</b> where &Omega; = &Theta;, we can use this with the inverse eye direction to find find &Phi;. We can use &Phi; to control the intensity of specular light reflecting from the surface to simulate how much light is being reflected directly towards the eye.</p>
<div class="image">
<img src="LightingSpecular.png" alt="LightingSpecular.png"/>
<div class="caption">
Figure 3. Specular Lighting.</div></div>
<p>Helpfully, OpenGL ES SL includes a <em>reflect</em> function which takes an incident vector (we will use the light direction), and a surface normal (<b>N</b>) and gives you the reflected direction (<b>R</b>).</p>
<p>In the <b>vertex shader</b>, we add:</p>
<div class="fragment"><div class="line">        <span class="stringliteral">&quot;    vec3 inverseEyeDirection = normalize(vec3(0.0, 0.0, 1.0));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 specularLightIntensity = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexSpecularReflectionConstant = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float shininess = 2.0;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 lightReflectionDirection = reflect(vec3(0) - inverseLightDirection, transformedVertexNormal);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float normalDotReflection = max(0.0, dot(inverseEyeDirection, lightReflectionDirection));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += pow(normalDotReflection, shininess) * vertexSpecularReflectionConstant * specularLightIntensity;\n&quot;</span></div></div><!-- fragment --><p> As we have said, the eye direction is crucial to calculating specular lighting. Like with the light direction the maths requires the eye direction to be reversed so we specific the inverse eye direction instead. Also like the light direction, you would probably want to pass the eye direction in as a attribute and transform it by a camera matrix, but again, here we are keeping things simple.</p>
<p>Like for ambient and diffuse light we have an RGB light intensity and an RGB specular reflection constant. Unlike ambient and diffuse (where we used the vertex colour as the constant) here we set the value to (1.0, 1.0, 1.0) this means that when <b>R</b> is equal to the eye vector, the specular colour will be exactly (1.0, 1.0, 1.0). This gives us a nice white highlight at this point.</p>
<p>The shininess parameter controls how "tight" the highlight is. We use this as the exponent for the dot product of the two vectors later. Since the dot product is always between 0 and 1 (thanks to the max function), the higher the exponent, the small the result of that <em>pow</em> calculation will be. This means that the specular value will decrease more rapidly as <b>R</b> moves away from the eye vector.</p>
<p>We use the reflect function to find the value of <b>R</b> (using <em><a class="el" href="structvec3.html">vec3(0)</a> - inverseLightDirection</em> as in this case we want the actual light direction).</p>
<p>Then we do the dot product of <b>R</b> and the eye vector and lastly multiply everything together to calulate the specular contribution.</p>
<h1><a class="anchor" id="lightingTheShader"></a>
The Shader</h1>
<p>So, to put it all together in the vertex shader looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>  <a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#a6997075b95e254f5d6b3f99a7a73d8af">glVertexShader</a>[] =</div><div class="line">        <span class="stringliteral">&quot;attribute vec4 vertexPosition;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;attribute vec3 vertexColour;\n&quot;</span></div><div class="line">        <span class="comment">/* [Add a vertex normal attribute.] */</span></div><div class="line">        <span class="stringliteral">&quot;attribute vec3 vertexNormal;\n&quot;</span></div><div class="line">        <span class="comment">/* [Add a vertex normal attribute.] */</span></div><div class="line">        <span class="stringliteral">&quot;varying vec3 fragColour;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;uniform mat4 projection;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;uniform mat4 modelView;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;void main()\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;{\n&quot;</span></div><div class="line">             <span class="comment">/* [Setup scene vectors.] */</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 transformedVertexNormal = normalize((modelView * vec4(vertexNormal, 0.0)).xyz);&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 inverseLightDirection = normalize(vec3(0.0, 1.0, 1.0));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour = vec3(0.0);\n&quot;</span></div><div class="line">             <span class="comment">/* [Setup scene vectors.] */</span></div><div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the diffuse component.] */</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 diffuseLightIntensity = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexDiffuseReflectionConstant = vertexColour;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float normalDotLight = max(0.0, dot(transformedVertexNormal, inverseLightDirection));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += normalDotLight * vertexDiffuseReflectionConstant * diffuseLightIntensity;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the diffuse component.] */</span></div><div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the ambient component.] */</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 ambientLightIntensity = vec3(0.1, 0.1, 0.1);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexAmbientReflectionConstant = vertexColour;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += vertexAmbientReflectionConstant * ambientLightIntensity;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the ambient component.] */</span></div><div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the specular component.] */</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 inverseEyeDirection = normalize(vec3(0.0, 0.0, 1.0));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 specularLightIntensity = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 vertexSpecularReflectionConstant = vec3(1.0, 1.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float shininess = 2.0;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    vec3 lightReflectionDirection = reflect(vec3(0) - inverseLightDirection, transformedVertexNormal);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    float normalDotReflection = max(0.0, dot(inverseEyeDirection, lightReflectionDirection));\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    fragColour += pow(normalDotReflection, shininess) * vertexSpecularReflectionConstant * specularLightIntensity;\n&quot;</span></div><div class="line">             <span class="comment">/* [Calculate the specular component.] */</span></div><div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    /* Make sure the fragment colour is between 0 and 1. */&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    clamp(fragColour, 0.0, 1.0);\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;    gl_Position = projection * modelView * vertexPosition;\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;}\n&quot;</span>;</div></div><!-- fragment --><p> Note that at the end we are clamping the fragment colour between 0 and 1 since that is the maximum colour values. We are also calculating the vertex positions as before in <a class="el" href="simpleCube.html">Simple Cube</a>.</p>
<p>This is not the most optimal way of doing this, it's a simplified version designed to be easy to understand. If you were to take this forward you would probably want to define the following outside of the shader and pass them in:</p><ul>
<li>light directions</li>
<li>eye direction</li>
<li>light intensities</li>
<li>material reflection components.</li>
</ul>
<p>For multiple lights you will need multiple light directions and light intensities for each one. To have different types of materials in your scene with different reflective properties, you will need to have the specular, diffuse, and ambient reflection constants for each separate material.</p>
<h1><a class="anchor" id="lightingInaccurateNormals"></a>
Messing with Normals</h1>
<p>Now that you've seen how normals influence lighting in a scene, you might realise that since we have complete control over the entire system we can achieve more effects using normals. If our normals are strictly perpendicular to the polygon in the scene, the polygons will be lit accordingly, and all the polygons will be individually visible. Maybe this is what we want, but more commonly we are trying to represent a smooth surface and the polygons are just an approximation of that surface. Therefore if we make the normals perpendicular to the original surface rather that our approximation, the lighting will behave as if we had a more complex representation and the surface will look more like what we originally intended.</p>
<p>We can see this in Figure 3, the dashed line is the surface you want to represent, the solid line is how your might approximate it with polygons. The solid vectors are the true normals for the approximated surface, i.e. they are perpendicular to the geometry. The dashed vectors are the normals to the true surface at the same points. So, if we use the approximate surface with the true surface normals. We get a cheaper (to render) geometry with accurate lighting.</p>
<div class="image">
<img src="LightingNormals.png" alt="LightingNormals.png"/>
<div class="caption">
Figure 3. Surface Normals.</div></div>
<p>That's actually what we have done in this tutorial, because we are approximating a sphere with our shape, we have specified the normals as if it was a curved surface. When the object is spinning, the part in the centre of the screen should be lit as if its a smooth curved surface. What ruins this illusion is of course the flat triangle edges of the object. This can be improved by adding additional geometry.</p>
<p>If we had used accurate normals in this sample, the specular lighting would not have had the same effect. Because each vertex of the polygon would have had the same normal, the specular lighting component would end up being the same for each fragment in the polygon. This would lead to the polygons "flashing" as the eye direction approaches the reflection vector. If you have lots of geometry in the object this would not as noticeable, but on our simple shape it ruins the effect we are trying to achieve.</p>
<p>There are even more things we can do with normals to achieve different effects such as bump mapping, normal mapping and parallax mapping (these effects require moving some of the lighting calculations to the fragment shader).. We'll cover these advanced lighting techniques in future tutorials.</p>
<h1><a class="anchor" id="lightingFurtherWork"></a>
Further Work</h1>
<p>Some points to consider once you have finished this tutorial:</p><ul>
<li>What happens when you change the surface normals of the object?</li>
<li>What different effects can you achieve by altering the material properties of the object (<em>vertexDiffuseReflectionConstant</em>, <em>vertexSpecularReflectionConstant</em>, <em>vertexAmbientReflectionConstant</em>, and <em>shininess</em>)?</li>
<li>What does altering the light intensities do to the scene (<em>diffuseLightIntensity</em>, <em>specularLightIntensity</em>, and <em>ambientLightIntensity</em>)?</li>
</ul>
<h1><a class="anchor" id="lightingBuildRun"></a>
Building and Running the Application</h1>
<p>Follow the <a class="el" href="gettingStartedGuide.html">Getting Started Guide</a> from <a class="el" href="gettingStartedGuide.html#gettingStartedGuideBuildingTheSamples">Building Android samples</a> onwards to build and run the application. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
