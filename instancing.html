<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Instancing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('instancing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Instancing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample presents the instanced drawing technique using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="instancingOverview"></a>
Overview</h1>
<div class="image">
<img src="Instancing_android.png" alt="Instancing_android.png"/>
<div class="caption">
Each cube is an instance of the same object.</div></div>
<p> There is only one copy of the cube vertex data in memory, and each of the cubes drawn is an instance of that data. This reduces the amount of memory that needs to be transferred to the GPU. By using gl_instanceID in the shader, each cube can have a different position, rotation speed and colour. This technique can be used wherever repeated geometry is used in a scene.</p>
<h1><a class="anchor" id="instancingGeneratingGeometry"></a>
Generating a Geometry</h1>
<p>To render a cube (which is the most basic 3D shape) we need to generate coordinates for its vertices. This is the first step we would like to focus on. Please look at the image below.</p>
<div class="image">
<img src="InstancingGeometry.png" alt="InstancingGeometry.png"/>
<div class="caption">
Coordinates of cube vertices.</div></div>
<p> As shown in the image, the cube vertex coordinates are arranged around point &lt;0, 0, 0&gt; which places them in [&lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;] range. This is not necessary. You are able to translate the coordinates in any direction or to scale the cube, but you have to be sure that your cube will be still visible on the screen. If you are not sure how to do that, just follow our suggestions. There is another reason for us to use the coordinates arranged around the center of the screen (point &lt;0, 0, 0&gt;) - we will then generate copies of the cube and each instance will be translated to a new position (so that the cubes move on a circular trajectory). But more about this later.</p>
<p>To have cube vertices is not enough to draw the cubic shape. The basic OpenGL ES rendering technique is based on drawing triangles that make up a requested shape. This will be our next step. This is important to mention here that whilst describing cube triangle vertices, you should follow the clockwise or counter-clockwise order, otherwise OpenGL ES will have some trouble with detecting front and back faces. In this example we are using clockwise (CW) order to describe cube coordinates as this is the default for OpenGL ES.</p>
<div class="image">
<img src="InstancingGeometryTriangles.png" alt="InstancingGeometryTriangles.png"/>
<div class="caption">
Triangles which make up a cubic shape.</div></div>
<p> Please look at the code presented below for more details.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Please see header for the specification. */</span></div>
<div class="line">    <span class="keywordtype">void</span> CubeModel::getTriangleRepresentation(<span class="keywordtype">float</span>** coordinatesPtrPtr,</div>
<div class="line">                                              <span class="keywordtype">int</span>*    numberOfCoordinatesPtr,</div>
<div class="line">                                              <span class="keywordtype">int</span>*    numberOfPointsPtr,</div>
<div class="line">                                              <span class="keywordtype">float</span>   <a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#ae8ab07ed1fc9730bfe1095aac6b5712c">scalingFactor</a>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(coordinatesPtrPtr != NULL,</div>
<div class="line">               <span class="stringliteral">&quot;Cannot use null pointer while calculating coordinates&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Index of an array we will put new point coordinates at. */</span></div>
<div class="line">        <span class="keywordtype">int</span>       currentIndex                    = 0;</div>
<div class="line">        <span class="comment">/* 6 faces of cube, 2 triangles for each face, 3 points of triangle, 3 coordinates for each point. */</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#aba5f2f1eee27a90fde74ba5eb338a64f">numberOfCubeTriangleCoordinates</a> = <a class="code" href="_instancing_2jni_2_common_8h.html#a8166db47725382c86479a9f7f451b60d">NUMBER_OF_CUBE_FACES</a>        *</div>
<div class="line">                                                    <a class="code" href="_instancing_2jni_2_common_8h.html#aa713e0d2b0c1147a753c5624e66b2bd8">NUMBER_OF_TRIANGLES_IN_QUAD</a> *</div>
<div class="line">                                                    <a class="code" href="_instancing_2jni_2_common_8h.html#a63d618a63aa9d510eacf282db06ef204">NUMBER_OF_TRIANGLE_VERTICES</a> *</div>
<div class="line">                                                    <a class="code" href="_etc_texture_2jni_2_common_8h.html#a6065b2906f66d7d9fc2d23aca7da604d">NUMBER_OF_POINT_COORDINATES</a>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Allocate memory for result array. */</span></div>
<div class="line">        *coordinatesPtrPtr = (<span class="keywordtype">float</span>*) malloc(numberOfCubeTriangleCoordinates * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Is allocation successful?. */</span></div>
<div class="line">        <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(*coordinatesPtrPtr != NULL,</div>
<div class="line">               <span class="stringliteral">&quot;Could not allocate memory for result array.&quot;</span>)</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Example:</span></div>
<div class="line"><span class="comment">         * Coordinates for cube points:</span></div>
<div class="line"><span class="comment">         * A -1.0f,  1.0f,  1.0f</span></div>
<div class="line"><span class="comment">         * B -1.0f,  1.0f, -1.0f</span></div>
<div class="line"><span class="comment">         * C  1.0f,  1.0f, -1.0f</span></div>
<div class="line"><span class="comment">         * D  1.0f,  1.0f,  1.0f</span></div>
<div class="line"><span class="comment">         * E -1.0f, -1.0f,  1.0f</span></div>
<div class="line"><span class="comment">         * F -1.0f, -1.0f, -1.0f</span></div>
<div class="line"><span class="comment">         * G  1.0f, -1.0f, -1.0f</span></div>
<div class="line"><span class="comment">         * H  1.0f, -1.0f,  1.0f</span></div>
<div class="line"><span class="comment">         * Create 2 triangles for each face of the cube. Vertices are written in clockwise order.</span></div>
<div class="line"><span class="comment">         *       B ________ C</span></div>
<div class="line"><span class="comment">         *      / |     /  |</span></div>
<div class="line"><span class="comment">         *  A ......... D  |</span></div>
<div class="line"><span class="comment">         *    .   |   .    |</span></div>
<div class="line"><span class="comment">         *    .  F|_ _.___ |G</span></div>
<div class="line"><span class="comment">         *    . /     .  /</span></div>
<div class="line"><span class="comment">         *  E ......... H</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        const Vec3f pointA = {-1.0f,  1.0f,  1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointB = {-1.0f,  1.0f, -1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointC = { 1.0f,  1.0f, -1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointD = { 1.0f,  1.0f,  1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointE = {-1.0f, -1.0f,  1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointF = {-1.0f, -1.0f, -1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointG = { 1.0f, -1.0f, -1.0f};</div>
<div class="line">        <span class="keyword">const</span> Vec3f pointH = { 1.0f, -1.0f,  1.0f};</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Fill the array with coordinates. */</span></div>
<div class="line">        <span class="comment">/* Top face. */</span></div>
<div class="line">        <span class="comment">/* A */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.z;</div>
<div class="line">        <span class="comment">/* B */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.z;</div>
<div class="line">        <span class="comment">/* C */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* A */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.z;</div>
<div class="line">        <span class="comment">/* C */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.z;</div>
<div class="line">        <span class="comment">/* D */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Bottom face. */</span></div>
<div class="line">        <span class="comment">/* F */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.x;;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.y;;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.z;;</div>
<div class="line">        <span class="comment">/* E */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.z;</div>
<div class="line">        <span class="comment">/* H */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* F */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.z;</div>
<div class="line">        <span class="comment">/* H */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.z;</div>
<div class="line">        <span class="comment">/* G */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Back face. */</span></div>
<div class="line">        <span class="comment">/* G */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.z;</div>
<div class="line">        <span class="comment">/* C */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.z;</div>
<div class="line">        <span class="comment">/* B */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* G */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.z;</div>
<div class="line">        <span class="comment">/* B */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.z;</div>
<div class="line">        <span class="comment">/* F */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Front face. */</span></div>
<div class="line">        <span class="comment">/* E */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.z;</div>
<div class="line">        <span class="comment">/* A */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.z;</div>
<div class="line">        <span class="comment">/* D */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* E */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.z;</div>
<div class="line">        <span class="comment">/* D */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.z;</div>
<div class="line">        <span class="comment">/* H */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Right face. */</span></div>
<div class="line">        <span class="comment">/* H */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.z;</div>
<div class="line">        <span class="comment">/* D */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointD.z;</div>
<div class="line">        <span class="comment">/* C */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* H */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointH.z;</div>
<div class="line">        <span class="comment">/* C */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointC.z;</div>
<div class="line">        <span class="comment">/* G */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointG.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Left face. */</span></div>
<div class="line">        <span class="comment">/* F */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.z;</div>
<div class="line">        <span class="comment">/* B */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointB.z;</div>
<div class="line">        <span class="comment">/* A */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* F */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointF.z;</div>
<div class="line">        <span class="comment">/* A */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointA.z;</div>
<div class="line">        <span class="comment">/* E */</span></div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.x;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.y;</div>
<div class="line">        (*coordinatesPtrPtr)[currentIndex++] = pointE.z;</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* Calculate size of a cube. */</span></div>
<div class="line">        <span class="keywordflow">if</span> (scalingFactor != 1.0<a class="code" href="gl2ext_8h.html#a7a611b28eaed9ea8dda79c38887b3f0e">f</a>)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#aba5f2f1eee27a90fde74ba5eb338a64f">numberOfCubeTriangleCoordinates</a>; i++)</div>
<div class="line">            {</div>
<div class="line">                (*coordinatesPtrPtr)[i] *= <a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#ae8ab07ed1fc9730bfe1095aac6b5712c">scalingFactor</a>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (numberOfCoordinatesPtr != NULL)</div>
<div class="line">        {</div>
<div class="line">            *numberOfCoordinatesPtr = <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#aba5f2f1eee27a90fde74ba5eb338a64f">numberOfCubeTriangleCoordinates</a>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (numberOfPointsPtr != NULL)</div>
<div class="line">        {</div>
<div class="line">            *numberOfPointsPtr = numberOfCubeTriangleCoordinates / <a class="code" href="_etc_texture_2jni_2_common_8h.html#a6065b2906f66d7d9fc2d23aca7da604d">NUMBER_OF_POINT_COORDINATES</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p> We would like to tell OpenGL ES to take the data and draw the cube. How to do that will be described below.</p>
<p>First of all, we will need a buffer object that will be used to store the vertex coordinates of the triangles making up the cube.</p>
<p>Generate buffer object (in the code we are generating 3 buffer objects as we will need them in further steps, but at this point you will need only one of them: the <em>cubeCoordinatesBufferObjectId</em> buffer object):</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffers. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab90465831e14c969c92180d991f51905">numberOfBufferObjectIds</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>  = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[0];</div>
<div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a906e6afc99aa43a010cabb4b1b0331f7">cubeColorsBufferObjectId</a>       = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[1];</div>
<div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#acb39074641015729e6515aca3ef191e6">uniformBlockDataBufferObjectId</a> = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[2];</div>
</div><!-- fragment --><p> We need to call the function (already described above) to get the cube's coordinate data.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Get triangular representation of a cube. Save data in cubeTrianglesCoordinates array. */</span></div>
<div class="line">    CubeModel::getTriangleRepresentation(&amp;<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ada3adea7bf18bea8e8cc243dbf4cbfb7">cubeTrianglesCoordinates</a>,</div>
<div class="line">                                         &amp;numberOfCubeTriangleCoordinates,</div>
<div class="line">                                         &amp;<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#abf79cbe865f20186497045d3c65b7695">numberOfCubeVertices</a>,</div>
<div class="line">                                          <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a561077a6979c8f3819a2655cd6bbc46c">cubeSize</a>);</div>
</div><!-- fragment --><p> The next step is to copy the retrieved data into the buffer object.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which create a cube. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          numberOfCubeTriangleCoordinates * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>),</div>
<div class="line">                          <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ada3adea7bf18bea8e8cc243dbf4cbfb7">cubeTrianglesCoordinates</a>,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
</div><!-- fragment --><p> The next thing to do is to set the vertex attrib array for the cube's coordinate. The function works with the currently bound array buffer object. We are re-binding buffer objects many times in our application, which is why we need to do that one more time here. However, this is not necessary if you are sure that the buffer object that stores the vertex coordinates is currently bound to the <em>GL_ARRAY_BUFFER</em> target. Please note that all of the following functions should be called for an active program object (more about that in the following section <a class="el" href="instancing.html#instancingProgramObject">Program Object</a>).</p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div>
<div class="line">                                       <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>,</div>
<div class="line">                                       NUMBER_OF_POINT_COORDINATES,</div>
<div class="line">                                       GL_FLOAT,</div>
<div class="line">                                       GL_FALSE,</div>
<div class="line">                                       0,</div>
<div class="line">                                       0));</div>
</div><!-- fragment --><p> At this point, you should be interested in the <em>positionLocation</em> variable: what does it stand for? This is an attribute location retrieved from the program object that we are using for rendering. More about that will be described in the following section <a class="el" href="instancing.html#instancingProgramObject">Program Object</a>. Once you will be familiar with program objects and properly initialize this value, it is enough to call </p>
<div class="fragment"><div class="line">glDrawArrays(GL_TRIANGLES, 0, <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#abf79cbe865f20186497045d3c65b7695">numberOfCubeVertices</a>);</div>
</div><!-- fragment --><p> to render a single cube on a screen. Please note that <em>GL_TRIANGLES</em> mode is used, which corresponds to the triangular representation of the cube coordinates we have generated.</p>
<h1><a class="anchor" id="instancingProgramObject"></a>
Program Object</h1>
<p>To start working with a program object, we have to generate its ID first.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a> = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCreateProgram());</div>
</div><!-- fragment --><p> The program object needs fragment and vertex shaders to be attached to it. Let's now focus on generating and setting shader objects.</p>
<div class="fragment"><div class="line">    Shader::processShader(&amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#acc1eb33f2e499064566b78ec020099a4">vertexShaderId</a>,   <a class="code" href="_boids_8h.html#a35b22db2f3e030971476b2780b957bae">VERTEX_SHADER_FILE_NAME</a>,   GL_VERTEX_SHADER);</div>
<div class="line">    Shader::processShader(&amp;<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab4fa89f786e9fe64ec88be5363d3e79c">fragmentShaderId</a>, <a class="code" href="_boids_8h.html#a7412b2e3b7caa96b5b2dab6cf9ce909b">FRAGMENT_SHADER_FILE_NAME</a>, GL_FRAGMENT_SHADER);</div>
</div><!-- fragment --><p> The basic mechanism looks like follows:</p>
<ol type="1">
<li>Create shader object: <div class="fragment"><div class="line">        *shaderObjectIdPtr = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCreateShader(shaderType));</div>
</div><!-- fragment --></li>
<li>Set shader source: <div class="fragment"><div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glShaderSource(*shaderObjectIdPtr, 1, <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>, NULL));</div>
</div><!-- fragment -->Please note that the <em>strings</em> variable is storing the shader source read from a file. <div class="fragment"><div class="line">        <a class="code" href="gl2ext_8h.html#a5dfa7628a601bf72d36273e52495a1db">strings</a>[0]         = <a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#aceb8b27cd7d369c524624ede81a1299e">loadShader</a>(filename);</div>
</div><!-- fragment --></li>
<li>Compile shader: <div class="fragment"><div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCompileShader(*shaderObjectIdPtr));</div>
</div><!-- fragment -->It is always a good idea to check whether compilation succeeded by checking <em>GL_COMPILE_STATUS</em> (<em>GL_TRUE</em> is expected). <div class="fragment"><div class="line">        <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetShaderiv(*shaderObjectIdPtr, GL_COMPILE_STATUS, &amp;compileStatus));</div>
</div><!-- fragment --></li>
</ol>
<p>Once you have called those functions for both fragment and vertex shaders, you should now attach both to a program object, </p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#acc1eb33f2e499064566b78ec020099a4">vertexShaderId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glAttachShader(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#ab4fa89f786e9fe64ec88be5363d3e79c">fragmentShaderId</a>));</div>
</div><!-- fragment --><p> link the program object, </p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glLinkProgram(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>));</div>
</div><!-- fragment --><p> and set the program object to be used (active). </p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>));</div>
</div><!-- fragment --><p> The shader objects that we use in our application are more advanced, however, if you are interested in rendering one cube only (as we were describing in previous section <a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a>) it is enough to define shaders with the code presented below.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>in      <a class="code" href="structvec4.html">vec4</a> attributePosition;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec3.html">vec3</a> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a9690d9fe1a3992583597abbe5df25707">cameraVector</a>;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae15f2f915ccf408ec586b52131ea66b4">perspectiveVector</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> fieldOfView = 1.0 / tan(perspectiveVector.x * 0.5);</div>
<div class="line">                      </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> cameraMatrix = <a class="code" href="structmat4.html">mat4</a> (1.0,            0.0,            0.0,           0.0, </div>
<div class="line">                              0.0,            1.0,            0.0,           0.0, </div>
<div class="line">                              0.0,            0.0,            1.0,           0.0, </div>
<div class="line">                              cameraVector.x, cameraVector.y, cameraVector.z, 1.0);</div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> perspectiveMatrix = <a class="code" href="structmat4.html">mat4</a> (fieldOfView/perspectiveVector.y, 0.0,         0.0,                                                                                             0.0, </div>
<div class="line">                                   0.0,                             fieldOfView, 0.0,                                                                                             0.0, </div>
<div class="line">                                   0.0,                             0.0,        -(perspectiveVector.w + perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z),      -1.0, </div>
<div class="line">                                   0.0,                             0.0,        (-2.0 * perspectiveVector.w * perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z), 0.0);</div>
<div class="line">  </div>
<div class="line">    <span class="comment">/* Return gl_Position. */</span></div>
<div class="line">    gl_Position = perspectiveMatrix * cameraMatrix * attributePosition;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Fragment shader:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 300 es</span></div>
<div class="line"><span class="preprocessor"></span>precision mediump <a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>;</div>
<div class="line"></div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragmentColour;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    fragmentColour = <a class="code" href="structvec4.html">vec4</a>(0.3, 0.2, 0.8, 1.0); <span class="comment">//Please use any colour you want</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Now you can see what the <em>positionLocation</em> variable stands for (as described in the previous section <a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a>). It is a location of an attribute named <em>attributePosition</em>. How do we get an attribute location?</p>
<p>Once the program object is linked and active, you can call</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>          = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetAttribLocation   (<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;attributePosition&quot;</span>));</div>
</div><!-- fragment --><p> Please remember that it is always a good idea to check whether the retrieved value is valid. If the attribute name was not found or is inactive (not used) in the shader, then -1 is returned (which is considered as an invalid attribute location).</p>
<div class="fragment"><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af8a637a06ae0f472dc72dcb013eee18a">positionLocation</a>          != -1,               <span class="stringliteral">&quot;Could not retrieve attribute location: attributePosition&quot;</span>);</div>
</div><!-- fragment --><p> If there is a valid value returned, you can use it in the steps previously described in <a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a>.</p>
<h1><a class="anchor" id="instancingInstancedDrawing"></a>
Instanced Drawing</h1>
<p>The main idea of this application is to present the instanced drawing technique. Once you are familiar with the previous sections (<a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a> and <a class="el" href="instancing.html#instancingProgramObject">Program Object</a>), you are ready to do that.</p>
<p>First of all, we have to know how many instances of the cube object we want to render.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Number of cubes that are drawn on a screen. */</span></div>
<div class="line"><span class="preprocessor">    #define NUMBER_OF_CUBES (10)</span></div>
</div><!-- fragment --><p> The next thing to do is to adjust the draw command so that all the cubes will be rendered. Please note that this time we are using <em>glDrawArraysInstanced()</em> rather than <em>glDrawArrays()</em> as described in <a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a>.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Draw cubes on a screen. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES,</div>
<div class="line">                                   0,</div>
<div class="line">                                   <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#abf79cbe865f20186497045d3c65b7695">numberOfCubeVertices</a>,</div>
<div class="line">                                   <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>));</div>
</div><!-- fragment --><p> And this is it. We now have <em>NUMBER_OF_CUBES</em> drawn on the screen. But the problem is that all the cubes are rendered in the same place on the screen, so we cannot see all of them. How should we solve this problem? It is rather simple: set a different position for each cube. The cubes should have a different colour as well, so we will use a uniform block in this situation.</p>
<p>In our vertex shader there are two new things added</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * We use uniform block in order to reduce amount of memory transfers to minimum. </span></div>
<div class="line"><span class="comment"> * The uniform block uses data taken directly from a buffer object. </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> CubesUniformBlock</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>[numberOfCubes];</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>  <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a181eab541e681d335323abf5ff213072">cubeColor</a>[numberOfCubes];</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <em>numberOfCubes</em> is defined as</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>   numberOfCubes = 10;</div>
</div><!-- fragment --><p> Then, if we would like to take a single element from one of those arrays, we will need to use <em>gl_InstanceID</em> as an index, which indicates the index of the element that is currently being rendered (in our case the value is from a range [0, <em>NUMBER_OF_CUBES</em> - 1]).</p>
<p>In the API, we need to retrieve the location of the uniform block,</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#af136cdeb2d7678a60c09548aa7907d57">uniformBlockIndex</a>         = <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformBlockIndex(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;CubesUniformBlock&quot;</span>));</div>
</div><!-- fragment --><p> verify whether the returned value is valid,</p>
<div class="fragment"><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#af136cdeb2d7678a60c09548aa7907d57">uniformBlockIndex</a>         != GL_INVALID_INDEX, <span class="stringliteral">&quot;Could not retrieve uniform block index: CubesUniformBlock&quot;</span>);</div>
</div><!-- fragment --><p> and set data.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Set binding point for uniform block. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformBlockBinding(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>,</div>
<div class="line">                                   <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#af136cdeb2d7678a60c09548aa7907d57">uniformBlockIndex</a>,</div>
<div class="line">                                   0));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBufferBase     (GL_UNIFORM_BUFFER,</div>
<div class="line">                                   0,</div>
<div class="line">                                   <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#acb39074641015729e6515aca3ef191e6">uniformBlockDataBufferObjectId</a>));</div>
</div><!-- fragment --><p> Thanks to that, the program object will use the data stored in the buffer object named <em>uniformBlockDataBufferObjectId</em>. The buffer object was generated as already described in the previous section <a class="el" href="instancing.html#instancingGeneratingGeometry">Generating a Geometry</a> and filled with data as shown below.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Buffer holding coordinates of start positions of cubes and RGBA values of colors. */</span></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#acb39074641015729e6515aca3ef191e6">uniformBlockDataBufferObjectId</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>) + <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ac311bd8460c7a7b4268abd5e40522b1e">cubeColors</a>),</div>
<div class="line">                          NULL,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER,</div>
<div class="line">                             0,</div>
<div class="line">                             <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>),</div>
<div class="line">                             <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>));</div>
<div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferSubData(GL_ARRAY_BUFFER,</div>
<div class="line">                             <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>),</div>
<div class="line">                             <span class="keyword">sizeof</span>(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ac311bd8460c7a7b4268abd5e40522b1e">cubeColors</a>),</div>
<div class="line">                             <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ac311bd8460c7a7b4268abd5e40522b1e">cubeColors</a>));</div>
</div><!-- fragment --> <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a719bab123bcfb3b9ad69ba824c540fdc">generateStartPosition</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> spaceBetweenCubes = (2 * <a class="code" href="advanced__samples_2common__native_2inc_2_mathematics_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>) / (<a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Fill array with startPosition data. */</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> allCubes = 0; allCubes &lt; <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#ad4493098628ceadc28731ff820f220e5">NUMBER_OF_CUBES</a>; allCubes++)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>[allCubes] = allCubes * spaceBetweenCubes;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#afc1d2dd6737973baa14ae1f749616de1">fillCubeColorsArray</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> allComponents = 0;</div>
<div class="line">             allComponents &lt; <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a9eb919011f5d371f769e810581a4fe2e">numberOfValuesInCubeColorsArray</a>;</div>
<div class="line">             allComponents++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Get random value from [0.0, 1.0] range. */</span></div>
<div class="line">        <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ac311bd8460c7a7b4268abd5e40522b1e">cubeColors</a>[allComponents] = (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>)rand() / (<a class="code" href="hiz__cull_8cs.html#a2ab77c89eb79b49ccd22bb1b2ad48bf1">float</a>)RAND_MAX;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> We wanted our cubes to move on a circular trajectory, spinning with a different speed, and having different colours. Please look into the vertex and fragment shader code to see how this is implemented.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader code</p>
<div class="fragment"><div class="line"><span class="comment">/* [Define number of cubes] */</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>   numberOfCubes = 10;</div>
<div class="line"><span class="comment">/* [Define number of cubes] */</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> pi            = 3.14159265358979323846;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> radius        = 20.0;</div>
<div class="line"></div>
<div class="line">in      <a class="code" href="structvec4.html">vec4</a> attributeColor;</div>
<div class="line">in      <a class="code" href="structvec4.html">vec4</a> attributePosition;</div>
<div class="line">out     <a class="code" href="structvec4.html">vec4</a> vertexColor;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec3.html">vec3</a> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#a9690d9fe1a3992583597abbe5df25707">cameraVector</a>;</div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structvec4.html">vec4</a> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae15f2f915ccf408ec586b52131ea66b4">perspectiveVector</a>;</div>
<div class="line"></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <span class="keywordtype">float</span> <a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a>; <span class="comment">/* Time value used for determining positions and rotations. */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* [Define uniform block] */</span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * We use uniform block in order to reduce amount of memory transfers to minimum. </span></div>
<div class="line"><span class="comment"> * The uniform block uses data taken directly from a buffer object. </span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> CubesUniformBlock</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>[numberOfCubes];</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>  <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a181eab541e681d335323abf5ff213072">cubeColor</a>[numberOfCubes];</div>
<div class="line">};</div>
<div class="line"><span class="comment">/* [Define uniform block] */</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> fieldOfView = 1.0 / tan(perspectiveVector.x * 0.5);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Vector data used for translation of cubes (each cube is placed on and moving around a circular curve). */</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> locationOfCube = <a class="code" href="structvec3.html">vec3</a>(radius * cos(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>[gl_InstanceID] + (time/3.0)),</div>
<div class="line">                               radius * sin(<a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ab69c07048663b72df4cf7f7d83c79428">startPosition</a>[gl_InstanceID] + (time/3.0)),</div>
<div class="line">                               1.0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* </span></div>
<div class="line"><span class="comment">     * Vector data used for setting rotation of cube. Each cube has different speed of rotation,</span></div>
<div class="line"><span class="comment">     * first cube has the slowest rotation, the last one has the fastest. </span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> rotationOfube = <a class="code" href="structvec3.html">vec3</a> (<span class="keywordtype">float</span>(gl_InstanceID + 1) * 5.0 * time);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* </span></div>
<div class="line"><span class="comment">     * Set different random colours for each cube. </span></div>
<div class="line"><span class="comment">     * There is one colour passed in per cube set for each cube (cubeColor[gl_InstanceID]).</span></div>
<div class="line"><span class="comment">     * There are also different colours per vertex of a cube (attributeColor).</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    vertexColor = attributeColor * <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a181eab541e681d335323abf5ff213072">cubeColor</a>[gl_InstanceID];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Create transformation matrices. */</span></div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> translationMatrix = <a class="code" href="structmat4.html">mat4</a> (1.0,             0.0,             0.0,             0.0, </div>
<div class="line">                                   0.0,             1.0,             0.0,             0.0, </div>
<div class="line">                                   0.0,             0.0,             1.0,             0.0, </div>
<div class="line">                                   locationOfCube.<a class="code" href="structvec3.html#a4ee2cfd5c2698031a47ab7f898d8d47b">x</a>, locationOfCube.<a class="code" href="structvec3.html#a891379795a14c80936cde4170239a138">y</a>, locationOfCube.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a>, 1.0);</div>
<div class="line">                                  </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> cameraMatrix = <a class="code" href="structmat4.html">mat4</a> (1.0,           0.0,           0.0,           0.0, </div>
<div class="line">                              0.0,              1.0,           0.0,           0.0, </div>
<div class="line">                              0.0,           0.0,           1.0,           0.0, </div>
<div class="line">                              cameraVector.x, cameraVector.y, cameraVector.z, 1.0);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> xRotationMatrix = <a class="code" href="structmat4.html">mat4</a> (1.0,  0.0,                               0.0,                                0.0, </div>
<div class="line">                                 0.0,  cos(pi * rotationOfube.<a class="code" href="structvec3.html#a4ee2cfd5c2698031a47ab7f898d8d47b">x</a> / 180.0), sin(pi * rotationOfube.<a class="code" href="structvec3.html#a4ee2cfd5c2698031a47ab7f898d8d47b">x</a> / 180.0),  0.0, </div>
<div class="line">                                 0.0, -sin(pi * rotationOfube.<a class="code" href="structvec3.html#a4ee2cfd5c2698031a47ab7f898d8d47b">x</a> / 180.0), cos(pi * rotationOfube.<a class="code" href="structvec3.html#a4ee2cfd5c2698031a47ab7f898d8d47b">x</a> / 180.0),  0.0, </div>
<div class="line">                                 0.0,  0.0,                               0.0,                                1.0);</div>
<div class="line">                                </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> yRotationMatrix = <a class="code" href="structmat4.html">mat4</a> (cos(pi * rotationOfube.<a class="code" href="structvec3.html#a891379795a14c80936cde4170239a138">y</a> / 180.0), 0.0, -sin(pi * rotationOfube.<a class="code" href="structvec3.html#a891379795a14c80936cde4170239a138">y</a> / 180.0), 0.0, </div>
<div class="line">                                 0.0,                               1.0, 0.0,                                0.0, </div>
<div class="line">                                 sin(pi * rotationOfube.<a class="code" href="structvec3.html#a891379795a14c80936cde4170239a138">y</a> / 180.0), 0.0, cos(pi * rotationOfube.<a class="code" href="structvec3.html#a891379795a14c80936cde4170239a138">y</a> / 180.0),  0.0, </div>
<div class="line">                                 0.0,                               0.0, 0.0,                                1.0);</div>
<div class="line">                                </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> zRotationMatrix = <a class="code" href="structmat4.html">mat4</a> ( cos(pi * rotationOfube.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a> / 180.0), sin(pi * rotationOfube.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a> / 180.0), 0.0, 0.0, </div>
<div class="line">                                 -sin(pi * rotationOfube.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a> / 180.0), cos(pi * rotationOfube.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a> / 180.0), 0.0, 0.0, </div>
<div class="line">                                  0.0,                               0.0,                               1.0, 0.0, </div>
<div class="line">                                  0.0,                               0.0,                               0.0, 1.0);</div>
<div class="line">                                 </div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> perspectiveMatrix = <a class="code" href="structmat4.html">mat4</a> (fieldOfView/perspectiveVector.y, 0.0,        0.0,                                                                                              0.0, </div>
<div class="line">                                   0.0,                            fieldOfView, 0.0,                                                                                              0.0, </div>
<div class="line">                                   0.0,                            0.0,        -(perspectiveVector.w + perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z),        -1.0, </div>
<div class="line">                                   0.0,                            0.0,        (-2.0 * perspectiveVector.w * perspectiveVector.z) / (perspectiveVector.w - perspectiveVector.z), 0.0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Compute rotation. */</span></div>
<div class="line">    <a class="code" href="structmat4.html">mat4</a> tempMatrix = xRotationMatrix;</div>
<div class="line">    </div>
<div class="line">    tempMatrix = yRotationMatrix * tempMatrix;</div>
<div class="line">    tempMatrix = zRotationMatrix * tempMatrix;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Compute translation. */</span></div>
<div class="line">    tempMatrix = translationMatrix * tempMatrix;</div>
<div class="line">    tempMatrix = cameraMatrix      * tempMatrix;</div>
<div class="line">                </div>
<div class="line">    <span class="comment">/* Compute perspective. */</span></div>
<div class="line">    tempMatrix = perspectiveMatrix * tempMatrix;</div>
<div class="line">                </div>
<div class="line">    <span class="comment">/* Return gl_Position. */</span></div>
<div class="line">    gl_Position = tempMatrix * attributePosition;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Fragment shader code</p>
<div class="fragment"><div class="line">in <a class="code" href="structvec4.html">vec4</a> vertexColor;</div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragmentColour;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="scan_8cs.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    fragmentColour = vertexColor;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the API, we query for locations of all the uniforms used in a vertex shader by calling</p>
<div class="fragment"><div class="line">uniformLocation = glGetUniformLocation(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a04468d60da2286d61475f6791fee77db">renderingProgramId</a>, <span class="stringliteral">&quot;uniformName&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="_compute_particles_2jni_2common_2common_8h.html#adc1cb77a482c9dbdce3ec9a2d1aea04c">ASSERT</a>(uniformLocation != -1, <span class="stringliteral">&quot;Could not retrieve uniform location: uniformName&quot;</span>);</div>
</div><!-- fragment --><p>Where of course, <em>uniformName</em> stands for the actual name of a uniform used in the shader.</p>
<p>Then, depending on the uniform type (float, <a class="el" href="structvec3.html">vec3</a>, <a class="el" href="structvec4.html">vec4</a>), we use different OpenGL ES call to set values for the uniforms.</p>
<p>The camera position and perspective vector are constant during rendering, so it's enough to call the functions shown below only once.</p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform4fv(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#aa013d331ba0a6b237a2bda27a4463586">perspectiveMatrixLocation</a>,</div>
<div class="line">                          1,</div>
<div class="line">                          (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>*)&amp;perspectiveVector));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform3fv(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#a23b85ad3c8005978d28ccb9f788ff67f">cameraPositionLocation</a>,</div>
<div class="line">                          1,</div>
<div class="line">                          (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>*)&amp;cameraVector));</div>
</div><!-- fragment --><p> The <em>time</em> value should be updated per frame, so the call</p>
<div class="fragment"><div class="line">    <a class="code" href="jni_2_astc_textures_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1f(<a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#af90abb15e4b2cde9321a5b7a3c726fd7">timeLocation</a>, time));</div>
</div><!-- fragment --><p> is issued for each frame being rendered (placed inside <em><a class="el" href="_anti_alias_8cpp.html#ab43690393b1c3605bbbd8f77bbe4955c">renderFrame()</a></em> function).</p>
<p>After all the steps described above, we get the result:</p>
<div class="image">
<img src="InstancingResult.png" alt="InstancingResult.png"/>
<div class="caption">
The result of instanced drawing technique.</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
