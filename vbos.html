<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Vertex Buffer Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vbos.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="struct_vertex.html">Vertex</a> Buffer Objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>How to use <a class="el" href="struct_vertex.html">Vertex</a> Buffer Objects to reduce the bandwidth in your application.</p>
<h1><a class="anchor" id="vboIntroduction"></a>
Introduction</h1>
<p>The source for this sample can be found in the folder of the SDK.</p>
<p>These tutorials have always had a mobile focused approach. As we have mentioned in many previous tutorials, mobile devices have limited resources compared to desktop. One of the most important considerations you must make is the amount of bandwidth your application will use. One way you can dramatically reduce your bandwidth footprint is to use something called <a class="el" href="struct_vertex.html">Vertex</a> Buffer Objects(VBOs). In all of the previous examples we have defined attributes such as vertex position, vertex colour, and vertex normals in main memory. Then in every frame we upload them to the GPU so that it can render your scene. Wouldn't it be great if we could just upload all this data once and forget about it? This way you would be reducing your bandwidth quite considerably because the data would no longer be sent to the GPU every frame. Well the good news is there is a way to do this and that is to use VBOs.</p>
<h1><a class="anchor" id="vboGeneration"></a>
Generating the buffers</h1>
<p>The first thing we need to do is to create the buffers to hold our data. The method to create vertex buffers is the same as creating our texture objects in the <a class="el" href="textureCube.html">Texture Cube</a> example. First you need to define an array of integers that will hold IDs for our buffer objects. In our example we are going to define 2, one for all our vertex related data and one for our indices.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLuint <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#a09bd31df06653d87b2b7138d65bee202">vboBufferIds</a>[2];</div></div><!-- fragment --><p> Now we need to give our integers valid values as they have not been initialized. To do this we need to add a new function call to our setupGraphics function. This function is called glGenBuffers and works just like glGenTextures. The first parameter is how many buffers you want to create and the second is a pointer to an array of integers that will hold the IDs for our buffer objects.</p>
<div class="fragment"><div class="line">    glGenBuffers(2, vboBufferIds);</div><div class="line">    glBindBuffer(GL_ARRAY_BUFFER, vboBufferIds[0]);</div><div class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboBufferIds[1]);</div></div><!-- fragment --><p> The next stage is that we need to bind the newly created IDs to their appropriate targets. There are two different target types: GL_ARRAY_BUFFER and GL_ELEMENT_ARRAY_BUFFER. These are used for vertices and indices respectively. If you don't call the bind buffer functions above in your code, OpenGL ES assumes that you don't want to use VBOs and will expect you to upload the information each time. Note, If you want to go back to this way of working after you have been using VBOs in your application then you need to recall the glBindBuffer function with 0. An example of this is shown below:</p>
<div class="fragment"><div class="line">glBindBuffer(GL_ARRAY_BUFFER, 0);</div><div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</div></div><!-- fragment --><p>Now we have both of our buffers bound we need to allocate space to fill them with data. We do this with a function called glBufferData. glBufferData takes 4 parameters the target, which needs to be the same one as the above function, the size, the data for the buffer and then how the buffer will be used.</p>
<div class="fragment"><div class="line">    glBufferData(GL_ARRAY_BUFFER, <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#a00ccaac8543cb3898a2fbaae07c5c050">vertexBufferSize</a>, cubeVertices, GL_STATIC_DRAW);</div><div class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#a6449c4b3cb47a42ffb76379059495bc7">elementBufferSize</a>, indices, GL_STATIC_DRAW);</div></div><!-- fragment --><p> This first interesting parameter is the size. Here we set it to vertexBufferSize which is defined earlier in the program. It is displayed below for your convenience:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLushort <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#a00ccaac8543cb3898a2fbaae07c5c050">vertexBufferSize</a> = 48 * 3 * <span class="keyword">sizeof</span> (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>);</div></div><!-- fragment --><p> We set this varible to 48 and then times this number by 3 times the sizeof(GLfloat) to give the size of the buffer we need in bytes. This is due to the fact that each vertex position is defined by 3 GLfloat components X, Y and Z. Now in previous cube examples we only have 24 vertices but yet we have set this number to 48 which is twice the amount of vertex positions we have been using. Our vertex positions are usually defined at 24 because we are using 4 vertex positions to define each face of the cube. However, we are combining the vertex colour data as well which also has 4 values per face. We do this by using something called a stride which is explained in depth in a later section. Note it is possible to include anything that you define per vertex into one single buffer. The reason we haven't is that in this example we only deal with position and colour. Another thing to note is that if you wanted you could still keep all of the arrays separate and create numerous VBOs. This tutorial is just showing you another way to arrange your data. Similarly if you want to go back to the previous examples and just create one array instead of numerous arrays then this is just as valid</p>
<p>Going back to glBufferData, there is only one more odd parameter and that is the last one. This simply gives OpenGL ES a hint on how you intend to use the buffer. There are three options: GL_STATIC_DRAW, GL_DYNAMIC_DRAW, and GL_STREAM_DRAW. The first means that you will only modify the data once and then it will be used many times. This is the option we want as our geometry won't change during the scene. The second means that you will modify the buffer numerous times and then use it to draw numerous times. The final option means that you will again only modify it once but this time you are saying you only need it a few times as well. It is worth noting this is only a hint, you are quite within your rights to use GL_STATIC_DRAW and modify the data should you wish.</p>
<p>We do exactly the same for the indices. The only differences are that we use GL_ELEMENT_ARRAY_BUFFER instead of GL_ARRAY_BUFFER and the elementBufferSize is 36 multiplied by GLushort because we are going to draw 12 trianges each with 3 indicies and the type in which we defined our indicies is GLushort.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLushort <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#a6449c4b3cb47a42ffb76379059495bc7">elementBufferSize</a> = 36 * <span class="keyword">sizeof</span>(GLushort);</div></div><!-- fragment --> <h1><a class="anchor" id="vboSortingData"></a>
Changing the Way we Store Data</h1>
<p>In an earlier section we mentioned that we were going to add all of our per vertex information into one VBO. The way we do that is we interleave the data. That means we first have one vertex position and then the colour that is associated with that position. Then we place the second vertex position. If you are using more per vertex attributes then you need to interleave those as well. So in the Lighting example we would have written a vertex position followed by a colour position followed by a vertex normal. The code below should help you visualise this better.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a> cubeVertices[] = { -1.0f,  1.0f, -1.0f,  <span class="comment">/* Back Face First Vertex Position */</span></div><div class="line">                            1.0f, 0.0f, 0.0f,           <span class="comment">/* Back Face First Vertex Colour */</span></div><div class="line">                            1.0f,  1.0f, -1.0f,         <span class="comment">/* Back Face Second Vertex Position */</span></div><div class="line">                            1.0f, 0.0f, 0.0f,           <span class="comment">/* Back Face Second Vertex Colour */</span></div><div class="line">                            -1.0f, -1.0f, -1.0f,        <span class="comment">/* Back Face Third Vertex Position */</span></div><div class="line">                            1.0f, 0.0f, 0.0f,           <span class="comment">/* Back Face Third Vertex Colour */</span></div><div class="line">                            1.0f, -1.0f, -1.0f,         <span class="comment">/* Back Face Fourth Vertex Position */</span></div><div class="line">                            1.0f, 0.0f, 0.0f,           <span class="comment">/* Back Face Fourth Vertex Colour */</span></div><div class="line">                            -1.0f,  1.0f,  1.0f,        <span class="comment">/* Front. */</span></div><div class="line">                            0.0f, 1.0f, 0.0f,</div><div class="line">                            1.0f,  1.0f,  1.0f,</div><div class="line">                            0.0f, 1.0f, 0.0f,</div><div class="line">                            -1.0f, -1.0f,  1.0f,</div><div class="line">                            0.0f, 1.0f, 0.0f,</div><div class="line">                            1.0f, -1.0f,  1.0f,</div><div class="line">                            0.0f, 1.0f, 0.0f,</div><div class="line">                            -1.0f,  1.0f, -1.0f,        <span class="comment">/* Left. */</span></div><div class="line">                            0.0f, 0.0f, 1.0f,</div><div class="line">                            -1.0f, -1.0f, -1.0f,</div><div class="line">                            0.0f, 0.0f, 1.0f,</div><div class="line">                            -1.0f, -1.0f,  1.0f,</div><div class="line">                            0.0f, 0.0f, 1.0f,</div><div class="line">                            -1.0f,  1.0f,  1.0f,</div><div class="line">                            0.0f, 0.0f, 1.0f,</div><div class="line">                            1.0f,  1.0f, -1.0f,         <span class="comment">/* Right. */</span></div><div class="line">                            1.0f, 1.0f, 0.0f,</div><div class="line">                            1.0f, -1.0f, -1.0f,</div><div class="line">                            1.0f, 1.0f, 0.0f,</div><div class="line">                            1.0f, -1.0f,  1.0f,</div><div class="line">                            1.0f, 1.0f, 0.0f,</div><div class="line">                            1.0f,  1.0f,  1.0f,</div><div class="line">                            1.0f, 1.0f, 0.0f,</div><div class="line">                            -1.0f, -1.0f, -1.0f,         <span class="comment">/* Top. */</span></div><div class="line">                            0.0f, 1.0f, 1.0f,</div><div class="line">                            -1.0f, -1.0f,  1.0f,</div><div class="line">                            0.0f, 1.0f, 1.0f,</div><div class="line">                            1.0f, -1.0f,  1.0f,</div><div class="line">                            0.0f, 1.0f, 1.0f,</div><div class="line">                            1.0f, -1.0f, -1.0f,</div><div class="line">                            0.0f, 1.0f, 1.0f,</div><div class="line">                            -1.0f,  1.0f, -1.0f,         <span class="comment">/* Bottom. */</span></div><div class="line">                            1.0f, 0.0f, 1.0f,</div><div class="line">                            -1.0f,  1.0f,  1.0f,</div><div class="line">                            1.0f, 0.0f, 1.0f,</div><div class="line">                            1.0f,  1.0f,  1.0f,</div><div class="line">                            1.0f, 0.0f, 1.0f,</div><div class="line">                            1.0f,  1.0f, -1.0f,</div><div class="line">                            1.0f, 0.0f, 1.0f,</div><div class="line">};</div></div><!-- fragment --> <h1><a class="anchor" id="vboVertexAttribChanges"></a>
Changes in glVertexAttribPointer</h1>
<p>Now we have two problems that we need to solve with glVertexAttribPointer. The first is that now we are using VBOs instead of sending the data each time. So sending a pointer to our vertices is not needed as we are not using that data anymore. Really what we want to do is change the value to an offset into our VBO where it can find the data. The second problem we have is that we now don't have a vertex position next to another vertex position. We have a colour instead so we need to have way of telling Open GL where the next relevant component is in the array.</p>
<div class="fragment"><div class="line">    glVertexAttribPointer(vertexLocation, 3, GL_FLOAT, GL_FALSE, <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#aa05455fad01de772dac80f5524a68761">strideLength</a>, 0);</div><div class="line">    glEnableVertexAttribArray(vertexLocation);</div><div class="line">    glVertexAttribPointer(<a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#a7d1706924ffb7ffcda7ebb0c5bc7ff8d">vertexColourLocation</a>, 3, GL_FLOAT, GL_FALSE, <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#aa05455fad01de772dac80f5524a68761">strideLength</a>, (<span class="keyword">const</span> <span class="keywordtype">void</span> *) <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#aff16663b8597da2807a2ca0e0cff6dbc">vertexColourOffset</a>);</div><div class="line">    glEnableVertexAttribArray(<a class="code" href="tutorials_2_asset_loading_2jni_2_native_8cpp.html#a7d1706924ffb7ffcda7ebb0c5bc7ff8d">vertexColourLocation</a>);</div></div><!-- fragment --><p> The first line in the above code deals with our vertex positions. Instead of passing an array to values in the final parameter we put 0. This is because the very first element in our VBO is a vertex element so there is no need for an offset. If you look at the glVertexAttribPointer function call related to the colour you will see that we use vertexColourOffset instead. Note, just for compiler type checking we need to cast this as const void *. The value of vertexColourOffset is 3 * sizeof(GLfloat) as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLushort <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#aff16663b8597da2807a2ca0e0cff6dbc">vertexColourOffset</a> = 3  * <span class="keyword">sizeof</span> (<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>);</div></div><!-- fragment --><p> The reason for this is we need to define the offset into the VBO in bytes. Now there is a vertex position before the colour, and each vertex position has 3 GLfloat components (X,Y, and Z). The second problem is dealt with by something called a stride. This basically is the number of bytes between the first element in the first component and the first element in the next component and is defined below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> GLushort <a class="code" href="tutorials_2_vbo_2jni_2_native_8cpp.html#aa05455fad01de772dac80f5524a68761">strideLength</a> = 6 * <span class="keyword">sizeof</span>(<a class="code" href="gl2ext_8h.html#a1ce320a06625b9dfdb4bd890e219d23c">GLfloat</a>);</div></div><!-- fragment --><p> As you can see the value is 6 multiplied by the size of GLfloat. The reason for this is if the value isn't 0 like in the previous example it should be the difference in bytes between the value of the first element in a component to the first element in the next component, because in our example we have X Y Z R G B X Y Z. There is a clear gap of 6 GLfloats between X of the first element and X of the second element. The colour has the same stride length as again it is 6 multiplied by the size of GLfloat between the first R colour component and the the second R colour component.</p>
<h1><a class="anchor" id="vboDrawCallChanges"></a>
Changes in glDrawElements</h1>
<p>The final change we need to do in this tutorial is to glDrawElements. We are going to do much the same thing that we did to glVertexAttrib pointer because we don't need to pass an array in anymore. Instead we just need to provide an offset into the VBO. In this case as we want to draw all the elements (starting from the begining) this offset is 0.</p>
<div class="fragment"><div class="line">    glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_SHORT, 0);</div></div><!-- fragment --> <h1><a class="anchor" id="assetLoadingBuildRun3"></a>
Building and Running the Application</h1>
<p>Follow the <a class="el" href="gettingStartedGuide.html">Getting Started Guide</a> from <a class="el" href="gettingStartedGuide.html#gettingStartedGuideBuildingTheSamples">Building Android samples</a> onwards to build and run the application. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
