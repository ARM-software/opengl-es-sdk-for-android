<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Min Max Blending</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('minMaxBlending.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Min Max Blending </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The application demonstrates behaviour of blending in GL_MIN and GL_MAX mode in OpenGL ES 3.0.</p>
<h1><a class="anchor" id="minMaxBlendingIntroduction"></a>
Introduction</h1>
<p>It's assumed that you have read and understood all of the mechanisms described in <a class="el" href="assetLoading.html">Asset Loading</a>,<a class="el" href="simpleTriangle.html">Simple Triangle</a> and <a class="el" href="textureCube.html">Texture Cube</a>.</p>
<h1><a class="anchor" id="minMaxBlendingOverview"></a>
Overview</h1>
<div class="image">
<img src="MinMaxBlending_android.png" alt="MinMaxBlending_android.png"/>
<div class="caption">
The 3D texture presenting a magnetic resonance of a human head</div></div>
<p> The application demonstrates behaviour of blending in GL_MIN and GL_MAX mode. It renders a 3D texture which consists of a series of greyscaled images obtained from magnetic resonance of a human head. The images are placed one after another in Z axis, so when blending is enabled they imitate a 3D model of the head.</p>
<p>Texture coordinates are then rotated, so viewers can see the model from different perspectives and after each 5 seconds, blending equation is changed. Since U/V/W coordinates are taken from interval &lt;0.0, 1.0&gt; and they are clamped to edge, there might occur some distortions for specific angles of rotation. That is why, the application adds a few blank layers behind and in the front of the original images. Now, if rotated coordinates exceed the interval, only the additional edge layers are repeated creating a noiseless background.</p>
<p>Because images contain a lot of black color, regular min blending would result in having black square on the screen. Hence, there is a threshold applied in fragment shader which prevents rendering fragments that are not bright enough. Additionally, for both types of blending, contrast of output luminance had to be modified to see more details.</p>
<p>To use your own input images, it's check their format and adjust the values of the min blending threshold, luminance of additional edge layers and contrast modifier.</p>
<h1><a class="anchor" id="minMaxBlendingProgramObject"></a>
Program Object</h1>
<p>In the application there is only one program object used. It's responsible for rendering a 3D texture on screen, rotate it and discard fragments that are not bright enough in case of a <em>min</em> blending option is used. The idea of generating and using program objects, attaching shaders to program object and compiling them should be already well known to the reader. If it isn't, please refer to previous tutorials. Please look into shaders we are using.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> <a class="el" href="class_shader.html">Shader</a> Code</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Input vertex position. */ </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec4 inputPosition;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;/* Input U/V/W texture coordinates. */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec3 inputUVWCoordinates;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;/* Constant transformation matrices. */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;uniform mat4 cameraMatrix;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;uniform mat4 projectionMatrix;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;/* Vector storing rotation coefficients for rotation matrices. */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;uniform vec3 rotationVector;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;/* Number of instances that are going to be drawn. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;uniform int instancesCount;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;/* Output texture coordinates passed to fragment shader. */</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;out vec3 uvwCoordinates;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;void main()</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;{</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    mat4 modelViewProjectionMatrix;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    /* Matrix rotating texture coordinates around X axis. */</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    mat3 xRotationMatrix = mat3(1.0,  0.0,                            0.0,</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;                                0.0,  cos(radians(rotationVector.x)), sin(radians(rotationVector.x)), </div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;                                0.0, -sin(radians(rotationVector.x)), cos(radians(rotationVector.x)));</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    /* Matrix rotating texture coordinates around Y axis. */</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    mat3 yRotationMatrix = mat3(cos(radians(rotationVector.y)), 0.0, -sin(radians(rotationVector.y)), </div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;                                0.0,                            1.0,  0.0,</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;                                sin(radians(rotationVector.y)), 0.0,  cos(radians(rotationVector.y)));</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    /* Matrix rotating texture coordinates around Z axis. */</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    mat3 zRotationMatrix = mat3( cos(radians(rotationVector.z)), sin(radians(rotationVector.z)), 0.0, </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                                -sin(radians(rotationVector.z)), cos(radians(rotationVector.z)), 0.0, </div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                                0.0,                             0.0,                            1.0);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    /* U/V/W coordinates pointing at appropriate layer depending on gl_InstanceID. */</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    vec3 translatedUVWCoordinates = inputUVWCoordinates - vec3(0.0, 0.0, float(gl_InstanceID) / float(instancesCount - 1));</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    /* </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    * Translate from &lt;0.0, 1.0&gt; interval to &lt;-1.0, 1.0&gt; to rotate texture coordinates around their center. </div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    * Otherwise, the rotation would take place around the XYZ axes which would spoil the effect.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    * The translated coordinates should be translated back to &lt;0.0, 1.0&gt; after all rotations are done.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    */</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    translatedUVWCoordinates = translatedUVWCoordinates * 2.0 - vec3(1.0);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    /* Rotate texture coordinates. */</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    translatedUVWCoordinates = xRotationMatrix * translatedUVWCoordinates;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    translatedUVWCoordinates = yRotationMatrix * translatedUVWCoordinates;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    translatedUVWCoordinates = zRotationMatrix * translatedUVWCoordinates;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    /* Translate back to &lt;0.0, 1.0&gt; interval. */</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    uvwCoordinates = (translatedUVWCoordinates + vec3(1.0)) / 2.0;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    /* Calculate Model-View-Projection matrix. */</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    modelViewProjectionMatrix = projectionMatrix * cameraMatrix;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    /* Calculate position of vertex. With each instance squares are drawn closer to the viewer. */</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    gl_Position = modelViewProjectionMatrix * (inputPosition + vec4(0.0, 0.0, float(gl_InstanceID) / float(instancesCount - 1), 0.0));</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div></div><!-- fragment --><p> The vertex shader is responsible for rotating the texture, which in our case means, updating the UVW coordinates for a specific layer of a 3D texture based on the rotation vector value.</p>
<p>Fragment <a class="el" href="class_shader.html">Shader</a> Code</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision mediump float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;precision mediump int;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;precision mediump isampler3D;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/* Value used to normalize colour values. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;const highp int maxShort = 32768;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* Value used to brighten output colour. */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;const float contrastModifier = 3.0;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;/* Input taken from vertex shader. */ </div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;in vec3 uvwCoordinates;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;/* 3D integer texture sampler. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;uniform isampler3D textureSampler;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;/* Boolean value indicating current blending equation. */</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;uniform bool isMinBlending;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;/* Threshold used for min blending. */</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;uniform float minBlendingThreshold;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;/* Output variable. */</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;out vec4 fragColor;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;void main()</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;{</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    /* Loaded texture short integer data are in big endian order. Swap the bytes. */</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    ivec4 initialTexture          = ivec4(texture(textureSampler, uvwCoordinates).rrr, 1.0);</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    ivec4 swappedBytesTextureTemp =  (initialTexture &lt;&lt; 8) &amp; ivec4(0xFF00);</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    ivec4 swappedBytesTexture     = ((initialTexture &gt;&gt; 8) &amp; ivec4(0x00FF)) | swappedBytesTextureTemp;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    /* Determine output fragment colour. */</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    fragColor = vec4(swappedBytesTexture) / float(maxShort) * contrastModifier;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    /* If min blending is set, discard fragments that are not bright enough. */</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    if (isMinBlending &amp;&amp; length(fragColor) &lt; minBlendingThreshold)</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    {</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        discard;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    }</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div></div><!-- fragment --><p> The fragment shader is responsible for sampling the 3D texture and when the <em>min</em> blending mode is used, discarding fragments that are not bright enough.</p>
<h1><a class="anchor" id="minMaxBlending3DTexture"></a>
3D Textures</h1>
<p>A 3 dimensional texture is represented by a bunch of 2D textures. To create a 3D texture in OpenGL ES 3.0, you need to:</p>
<ol type="1">
<li>Create a texture object ID; <div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures(1, &amp;<a class="code" href="_e_t_c_atlas_alpha_8cpp.html#a160ac41148eb5e30fbb1494de178a550">textureID</a>));</div></div><!-- fragment --></li>
<li>Bind it to the <em>GL_TEXTURE_3D</em> target; <div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, <a class="code" href="_e_t_c_atlas_alpha_8cpp.html#a160ac41148eb5e30fbb1494de178a550">textureID</a>));</div></div><!-- fragment --></li>
<li>Initialize texture storage; <div class="fragment"><div class="line">    <span class="comment">/* Initialize storage space for texture data. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage3D(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>,</div><div class="line">                            1,</div><div class="line">                            GL_R16I,</div><div class="line">                            <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#abacb48a3088126a6daa66c58464c2eab">textureWidth</a>,</div><div class="line">                            <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#acea0133aedacf0a2777e1c3ad6dd6001">textureHeight</a>,</div><div class="line">                            <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#a7e5902589d8e71efd1cf4217eaa4683c">textureDepth</a>));</div></div><!-- fragment --></li>
<li>Set the texture object parameters; <div class="fragment"><div class="line">    <span class="comment">/* Set texture parameters. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, GL_TEXTURE_WRAP_S,     GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, GL_TEXTURE_WRAP_T,     GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, GL_TEXTURE_WRAP_R,     GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, GL_TEXTURE_MAG_FILTER, GL_NEAREST));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, GL_TEXTURE_MIN_FILTER, GL_NEAREST));</div></div><!-- fragment --></li>
<li>Fill each of the texture levels with data (the above function should be called for each texture layer). <div class="fragment"><div class="line">    <span class="comment">/* Set 2D image at the current textureZOffset. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexSubImage3D(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>,</div><div class="line">                             0,</div><div class="line">                             0,</div><div class="line">                             0,</div><div class="line">                             <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#a0de8534709b35f3581fb38bbc3933e0d">textureZOffset</a>,</div><div class="line">                             <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#abacb48a3088126a6daa66c58464c2eab">textureWidth</a>,</div><div class="line">                             <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#acea0133aedacf0a2777e1c3ad6dd6001">textureHeight</a>,</div><div class="line">                             1,</div><div class="line">                             GL_RED_INTEGER,</div><div class="line">                             GL_SHORT,</div><div class="line">                             textureData));</div></div><!-- fragment --></li>
</ol>
<p>Once all of the steps described above are completed, we can use the texture object as an input for the program object 3D uniform sampler. We are using only one sampler object and a default texture unit, so the steps described below are not necessary, but we will issue them anyway, just to show you the mechanism.</p>
<p>First of all, we are querying for locations of a 3D sampler.</p>
<div class="fragment"><div class="line">    GLint textureSamplerLocation       = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="_anti_alias_8cpp.html#a391fd187e1c163e1bc7dc26a34c402f2">programID</a>, <span class="stringliteral">&quot;textureSampler&quot;</span>));</div></div><!-- fragment --><p> Please note that the second argument should correspond to the uniform name that is used in the shader.</p>
<p>The next step is to check whether the retrieved location is valid. If the returned value is -1, the uniform is considered inactive and any attempt to set the uniform value will be ignored.</p>
<div class="fragment"><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(textureSamplerLocation       != -1, <span class="stringliteral">&quot;Could not find location for uniform: textureSampler&quot;</span>);</div></div><!-- fragment --><p> Once we are sure, the uniform has been found, we can set its value. It's achieved by some basic steps.</p>
<p>Set active texture unit (<em>GL_TEXTURE0</em> is active by default, but we want to call it anyway to show you the mechanism).</p>
<div class="fragment"><div class="line"><a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0));</div></div><!-- fragment --><p>Then, we need to bind a texture object to <em>GL_TEXTURE_3D</em> target.</p>
<div class="fragment"><div class="line"><a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture(<a class="code" href="gl2ext_8h.html#a6c865f303c89ec764158e0016e50d4a8">GL_TEXTURE_3D</a>, <a class="code" href="_e_t_c_atlas_alpha_8cpp.html#a160ac41148eb5e30fbb1494de178a550">textureID</a>));</div></div><!-- fragment --><p>And now, by calling the function shown below, the texture object named with <em>textureID</em> will be used as an input for the program object. </p><div class="fragment"><div class="line"><a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i(textureSamplerLocation, 0));</div></div><!-- fragment --><p>In the <em>glUniform1i()</em> call the second argument corresponds to the 0 in the <em>GL_TEXTURE0</em> texture unit. If we would like to use 3D texture object which is bound to <em>GL_TEXTURE_3D</em> target at <em>GL_TEXTURE1</em> texture unit, then the second argument in the <em>glUniform1i()</em> call should be equal to 1.</p>
<p>To draw a 3D texture on screen, we use <em>instanced drawing</em> technique to render each texture layer separately.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Draw a single square layer consisting of 6 vertices for textureDepth times. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES, 0, 6, <a class="code" href="tutorials_2_min_max_blending_2jni_2_native_8cpp.html#a7e5902589d8e71efd1cf4217eaa4683c">textureDepth</a>));</div></div><!-- fragment --> <h1><a class="anchor" id="minMaxBlendingBlending"></a>
Blending</h1>
<p>The main idea of the application is to show the difference between <em>GL_MIN</em> and <em>GL_MAX</em> blend equations. Just to clarify: the specific blend equation specifies how a pixel color is determined. To be more precise: if a pixel does already have a color determined (it always has) and we want to apply a new color to it, then we can specify how the two colors will be blend: we can simply add the two colors, subtract them or we can use minimum or maximum values of the two (which is our case).</p>
<p>First of all, we need to enable blending. Without that, the new color will replace the old one and no blending will be issued.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Enable blending. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_BLEND));</div></div><!-- fragment --><p> Then, we can change the blend equation by calling</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set new blend equation. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBlendEquation(<a class="code" href="gl2ext_8h.html#a9aa39c311e7b5958879e80579cc129aa">GL_MIN</a>));</div></div><!-- fragment --><p> or</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set new blend equation. */</span></div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBlendEquation(<a class="code" href="gl2ext_8h.html#ad615339259858b91f67bf893e2a0b1b7">GL_MAX</a>));</div></div><!-- fragment --><p> The result of the specific blend equations are shown below.</p>
<div class="image">
<img src="MinMaxBlending_result.png" alt="MinMaxBlending_result.png"/>
<div class="caption">
The result of different blend equations: GL_MAX (on the left) and GL_MIN (on the right).</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
