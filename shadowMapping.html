<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Shadow Mapping</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('shadowMapping.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Demonstration of shadow mapping functionality using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="shadowMappingIntroduction"></a>
Introduction</h1>
<p>This tutorial assumes that you already have basic OpenGL ES knowledge, and have read and understood the <a class="el" href="normalMapping.html">Normal Mapping</a>, <a class="el" href="lighting.html">Lighting</a> and <a class="el" href="textureCube.html">Texture Cube</a> tutorials.</p>
<h1><a class="anchor" id="shadowMappingOverview"></a>
Overview</h1>
<div class="image">
<img src="ShadowMapping_android.png" alt="ShadowMapping_android.png"/>
<div class="caption">
Shadow Mapping. Yellow cube represents the spot light source.</div></div>
<p> The application displays two cubes on a plane which are lit by directional and spot lights. The location and direction of the spot light source (represented by a small yellow cube flying above the scene) in 3D space are regularly updated. The cube and plane models are shadow receivers, but only the cubes are shadow casters. The application uses shadow mapping for rendering and displaying shadows.</p>
<h1><a class="anchor" id="shadowMappingRenderGeometry"></a>
Render geometry</h1>
<p>In the application we are rendering a horizontally located plane, on top of which we lay two cubes. There is also a single cube flying above the scene which represents the spot light source. Let us now focus on generating the geometry that will be rendered.</p>
<p>In the application we are using two program objects: one responsible for rendering the scene, which consists of a plane and two cubes with all the lighting and shadows applied, and a second one, used for rendering a single cube (the yellow one flying above the scene) that represents the spot light source. We will now focus on the first program object, as rendering the single cube on a screen should be already a well-know technique for the reader (or will be after reading this tutorial).</p>
<div class="image">
<img src="ShadowMappingGeometry.png" alt="ShadowMappingGeometry.png"/>
<div class="caption">
Vertex coordinates of the geometry that will be rendered.</div></div>
<p> First of all, we need to have the coordinates of vertices that make up a cubic or plane shape. Please note that there will also be lighting applied, which means that we will need normals as well.</p>
<p>Geometry data will be stored and then used by objects that are generated with the following commands:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffer objects. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenBuffers(6, <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Store buffer object names in global variables.</span></div><div class="line"><span class="comment">     * The variables have more friendly names, so that using them is easier. */</span></div><div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>                = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[0];</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ac367d305ef64179e9da816bebcb7b67d">lightRepresentationCoordinatesBufferObjectId</a> = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[1];</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ab863ba12d9b7b07bf7e77f1f9283b302">cubeNormalsBufferObjectId</a>                    = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[2];</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad9bb98cfbb223135ec6ab2a59b39b01b">planeCoordinatesBufferObjectId</a>               = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[3];</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad480c145c1cf755a12fc6e2b9c2db105">planeNormalsBufferObjectId</a>                   = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[4];</div><div class="line">    <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#acb39074641015729e6515aca3ef191e6">uniformBlockDataBufferObjectId</a>               = <a class="code" href="tutorials_2_boids_2jni_2_native_8cpp.html#abb9dc572e495e1309511e01b7821b58d">bufferObjectIds</a>[5];</div><div class="line"></div><div class="line">    <span class="comment">/* Generate vertex array objects. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenVertexArrays(3, vertexArrayObjectsNames));</div><div class="line"></div><div class="line">    <span class="comment">/* Store vertex array object names in global variables.</span></div><div class="line"><span class="comment">     * The variables have more friendly names, so that using them is easier. */</span></div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#aa5f25125f799044ab352657fd6ac2e1d">cubesVertexArrayObjectId</a>                          = vertexArrayObjectsNames[0];</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a50cfdf0f2b703712a2607602e6553c11">lightRepresentationCoordinatesVertexArrayObjectId</a> = vertexArrayObjectsNames[1];</div><div class="line">    <a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>                          = vertexArrayObjectsNames[2];</div></div><!-- fragment --><p> There is one extra buffer object generated, which ID is stored in the <em>uniformBlockDataBufferObjectId</em> variable. This one is not needed at this step, so you can ignore it.</p>
<p>Geometry data is then generated and copied to specific buffer objects. For more details on how the coordinates of vertices are calculated, please refer to the implementation of those functions.</p>
<p>Generate geometry data.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a0f6f6a96b5bbf5d16be91bd1e5816293">createDataForObjectsToBeDrawn</a>()</div><div class="line">{</div><div class="line">    <span class="comment">/* Get triangular representation of the scene cube. Store the data in the cubeCoordinates array. */</span></div><div class="line">    CubeModel::getTriangleRepresentation(&amp;<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.coordinates,</div><div class="line">                                         &amp;<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfElementsInCoordinatesArray,</div><div class="line">                                         &amp;<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfPoints,</div><div class="line">                                          <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.scalingFactor);</div><div class="line">    <span class="comment">/* Calculate normal vectors for the scene cube created above. */</span></div><div class="line">    CubeModel::getNormals(&amp;<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.normals,</div><div class="line">                          &amp;<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfElementsInNormalsArray);</div><div class="line">    <span class="comment">/* Get triangular representation of a square to draw plane in XZ space. Store the data in the planeCoordinates array. */</span></div><div class="line">    PlaneModel::getTriangleRepresentation(&amp;<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.coordinates,</div><div class="line">                                          &amp;<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfElementsInCoordinatesArray,</div><div class="line">                                          &amp;<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfPoints,</div><div class="line">                                           <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.scalingFactor);</div><div class="line">    <span class="comment">/* Calculate normal vectors for the plane. Store the data in the planeNormals array. */</span></div><div class="line">    PlaneModel::getNormals(&amp;<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.normals,</div><div class="line">                           &amp;<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfElementsInNormalsArray);</div><div class="line">    <span class="comment">/* Get triangular representation of the light cube. Store the data in the lightRepresentationCoordinates array. */</span></div><div class="line">    CubeModel::getTriangleRepresentation(&amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                                         &amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a>,</div><div class="line">                                         &amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a6df2640a5ea7a6c3fa25ab492b76ca64">numberOfPoints</a>,</div><div class="line">                                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a6875156a58d167b1f306147232b7ffe8">scalingFactor</a>);</div><div class="line"></div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.coordinates                != NULL, <span class="stringliteral">&quot;Could not retrieve cube coordinates.&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.normals                    != NULL, <span class="stringliteral">&quot;Could not retrieve cube normals.&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a> != NULL, <span class="stringliteral">&quot;Could not retrieve cube coordinates.&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.coordinates               != NULL, <span class="stringliteral">&quot;Could not retrieve plane coordinates.&quot;</span>);</div><div class="line">    <a class="code" href="_compute_particles_2jni_2common_2common_8h.html#a9a90e23f0f81ce2fdf8c10979e6917fb">ASSERT</a>(<a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.normals                   != NULL, <span class="stringliteral">&quot;Could not retrieve plane normals.&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> Fill buffer objects with data.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the scene cubes. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfElementsInCoordinatesArray * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.coordinates,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of normal vectors for each vertex of the scene cubes. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ab863ba12d9b7b07bf7e77f1f9283b302">cubeNormalsBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfElementsInNormalsArray * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.normals,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the plane. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad9bb98cfbb223135ec6ab2a59b39b01b">planeCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfElementsInCoordinatesArray * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.coordinates,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of the plane&#39;s normal vectors. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad480c145c1cf755a12fc6e2b9c2db105">planeNormalsBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfElementsInNormalsArray * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.normals,</div><div class="line">                          GL_STATIC_DRAW));</div><div class="line"></div><div class="line">    <span class="comment">/* Buffer holding coordinates of the light cube. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ac367d305ef64179e9da816bebcb7b67d">lightRepresentationCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),</div><div class="line">                          <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a1f963c1740592964e3a0437ccbe98b86">lightRepresentation</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div><div class="line">                          GL_STATIC_DRAW));</div></div><!-- fragment --><p> In the program object, geometry vertices are referred to via the attributes, which is rather obvious.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;in vec4 attributePosition; /* Attribute: holding coordinates of triangles that make up a geometry. */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;in vec3 attributeNormals;  /* Attribute: holding normals. */</div></div><!-- fragment --><p> This is why we need to query for the attribute location within the program object responsible for scene rendering (note that all of the following functions need to be called for the active program object).</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aaf38dea9e07e63b67513882117085945">positionAttributeLocation</a>   = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation  (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a23c751719b1521521f5472a204f6cbf3">programId</a>, <span class="stringliteral">&quot;attributePosition&quot;</span>));   <span class="comment">/* Attribute that is fed with the vertices of triangles that make up geometry (cube or plane). */</span></div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a27e37a396d367ba8dfe9adaff7c50118">normalsAttributeLocation</a>    = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetAttribLocation  (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a23c751719b1521521f5472a204f6cbf3">programId</a>, <span class="stringliteral">&quot;attributeNormals&quot;</span>));    <span class="comment">/* Attribute that is fed with the normal vectors for geometry (cube or plane). */</span></div></div><!-- fragment --><p> As you can see above, we are querying for the locations of coordinates only, without specifying the cube or plane ones. This is because we are using only one program object to render both the plane and the cubes. Rendering specific geometry is achieved by using proper <em><a class="el" href="struct_vertex.html">Vertex</a> Attrib Arrays</em>. Let's look at how it is implemented.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#aa5f25125f799044ab352657fd6ac2e1d">cubesVertexArrayObjectId</a>));</div><div class="line">    <span class="comment">/* Set values for cubes&#39; normal vectors. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ab863ba12d9b7b07bf7e77f1f9283b302">cubeNormalsBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a27e37a396d367ba8dfe9adaff7c50118">normalsAttributeLocation</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a27e37a396d367ba8dfe9adaff7c50118">normalsAttributeLocation</a>, 3, GL_FLOAT, GL_FALSE, 0, 0));</div><div class="line">    <span class="comment">/* Set values for the cubes&#39; coordinates. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER, <a class="code" href="tutorials_2_instancing_2jni_2_native_8cpp.html#ae4b69516d749766469d22c10e56d1ab9">cubeCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aaf38dea9e07e63b67513882117085945">positionAttributeLocation</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aaf38dea9e07e63b67513882117085945">positionAttributeLocation</a>, 3, GL_FLOAT, GL_FALSE, 0, 0));</div><div class="line"></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>));</div><div class="line">    <span class="comment">/* Set values for plane&#39;s normal vectors. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad480c145c1cf755a12fc6e2b9c2db105">planeNormalsBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a27e37a396d367ba8dfe9adaff7c50118">normalsAttributeLocation</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a27e37a396d367ba8dfe9adaff7c50118">normalsAttributeLocation</a>, 3, GL_FLOAT, GL_FALSE, 0, 0));</div><div class="line">    <span class="comment">/* Set values for plane&#39;s coordinates. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ad9bb98cfbb223135ec6ab2a59b39b01b">planeCoordinatesBufferObjectId</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aaf38dea9e07e63b67513882117085945">positionAttributeLocation</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aaf38dea9e07e63b67513882117085945">positionAttributeLocation</a>, 3, GL_FLOAT, GL_FALSE, 0, 0));</div></div><!-- fragment --><p> Now, by calling <em>glBindVertexArray()</em> with the proper parameter, we can control which object (cubes or plane) is going to be rendered. Please refer to:</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#aa5f25125f799044ab352657fd6ac2e1d">cubesVertexArrayObjectId</a>));</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindVertexArray(<a class="code" href="tutorials_2_occlusion_queries_2jni_2_native_8cpp.html#a247dd95a0a87ef7e43a724b77791e416">planeVertexArrayObjectId</a>));</div></div><!-- fragment --><p> The final thing is to make the actual draw call, which can be achieved by:</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, <a class="code" href="_compute_particles_2jni_2app_8cpp.html#aee7f639247161e2069ff35d57f7735af">plane</a>.numberOfPoints));</div></div><!-- fragment --><p> We wanted to draw two cubes that are laid on a plane. This is why we use the <em>glDrawArraysInstanced()</em> call rather than <em>glDrawArrays()</em>. Thanks to that there will be exactly 2 instances of the same object drawn on a screen.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glDrawArraysInstanced(GL_TRIANGLES, 0, <a class="code" href="_translucency_2jni_2app_8cpp.html#a404abf6278027b87d264ad06033973b3">cube</a>.numberOfPoints, 2));</div></div><!-- fragment --> <h1><a class="anchor" id="shadowMappingCalculateAShadowMap"></a>
Calculate a shadow map</h1>
<p>To calculate the shadow map we need to create a depth texture, which will be used to store the results. It is achieved in some basic steps, which you should already know, but let us describe this one more time.</p>
<p>Generate texture object and bind it to the <em>GL_TEXTURE_2D</em> target.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenTextures  (1,</div><div class="line">                            &amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#ae5e7d69532bac7c0b1f7b419f0f64c4d">textureName</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div><div class="line">                             <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#ae5e7d69532bac7c0b1f7b419f0f64c4d">textureName</a>));</div></div><!-- fragment --><p> Specify the texture storage data type.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexStorage2D(GL_TEXTURE_2D,</div><div class="line">                            1,</div><div class="line">                            GL_DEPTH_COMPONENT24,</div><div class="line">                            <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a82c85b49db606240a492e41c4f2c805a">width</a>,</div><div class="line">                            <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a9c83cfd161f45a62dec8f7d9bd2c891e">height</a>));</div></div><!-- fragment --><p> We wanted our shadow to be more precise, this is why the depth texture resolution is bigger than normal scene size. Please refer to:</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af485b7638f8bce742ca111004c8a485c">window</a>.<a class="code" href="struct_window_properties.html#addd9ab3167f8e5ab30af34cbb74b8792">height</a> = <a class="code" href="gl2ext_8h.html#aa352f2804b9902ac30769c00dde75d5f">height</a>;</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af485b7638f8bce742ca111004c8a485c">window</a>.<a class="code" href="struct_window_properties.html#a326cb28b16fd4e03435131e5c04cc2d7">width</a>  = <a class="code" href="gl2ext_8h.html#a9a82cf3caff84cabc4598e2619faac17">width</a>;</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a9c83cfd161f45a62dec8f7d9bd2c891e">height</a>                = <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af485b7638f8bce742ca111004c8a485c">window</a>.<a class="code" href="struct_window_properties.html#addd9ab3167f8e5ab30af34cbb74b8792">height</a> * 2;</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a82c85b49db606240a492e41c4f2c805a">width</a>                 = <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af485b7638f8bce742ca111004c8a485c">window</a>.<a class="code" href="struct_window_properties.html#a326cb28b16fd4e03435131e5c04cc2d7">width</a>  * 2;</div></div><!-- fragment --><p> Set texture object parameters. The new thing here is to set <em>GL_TEXTURE_COMPARE_MODE</em> to the value of <em>GL_COMPARE_REF_TO_TEXTURE</em> which leads to r texture coordinate to be compared to the value in the currently bound depth texture.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MIN_FILTER,</div><div class="line">                             GL_NEAREST));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_MAG_FILTER,</div><div class="line">                             GL_NEAREST));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_S,</div><div class="line">                             GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_WRAP_T,</div><div class="line">                             GL_CLAMP_TO_EDGE));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_COMPARE_FUNC,</div><div class="line">                             GL_LEQUAL));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div><div class="line">                             GL_TEXTURE_COMPARE_MODE,</div><div class="line">                             GL_COMPARE_REF_TO_TEXTURE));</div></div><!-- fragment --><p> The next thing we have to do to implement the <em>render to texture</em> mechanism is to:</p>
<ul>
<li>Generate framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGenFramebuffers     (1,</div><div class="line">                                   &amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a20a6c3e67e4479e7f65a3442d38c6968">framebufferObjectName</a>));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindFramebuffer     (GL_FRAMEBUFFER,</div><div class="line">                                    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a20a6c3e67e4479e7f65a3442d38c6968">framebufferObjectName</a>));</div></div><!-- fragment --><ul>
<li>Bind the depth texture object to the depth attachment of the framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glFramebufferTexture2D(GL_FRAMEBUFFER,</div><div class="line">                                    GL_DEPTH_ATTACHMENT,</div><div class="line">                                    GL_TEXTURE_2D,</div><div class="line">                                    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#ae5e7d69532bac7c0b1f7b419f0f64c4d">textureName</a>,</div><div class="line">                                    0));</div></div><!-- fragment --><p> We wanted the spot light source position to be updated per each frame. This is why the shadow map will need to be updated as well, as the perspective from which a spot light is "looking into" the scene is different for each frame.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#ae560f1cdfb628ccb59726b00b483e632">lightProjectionMatrix</a>  = <a class="code" href="tutorials_2_asset_loading_2jni_2_matrix_8cpp.html#a918119096240af89f225bc5b7669d991">Matrix::matrixPerspective</a>(<a class="code" href="namespace_mali_s_d_k.html#a683f8db3cdf4522a549aa6b237661df4">degreesToRadians</a>(90.0f),</div><div class="line">                                                       1.0f,</div><div class="line">                                                       1.0f,</div><div class="line">                                                       50.0f);</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.x = radius * sinf(<a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a> / 2.0f);</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.y = 2.0f;</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.z = radius * cosf(<a class="code" href="spawn_8cs.html#a251125d5d29683e1458005f28de9845f">time</a> / 2.0f);</div><div class="line"></div><div class="line">    <span class="comment">/* Direction of light. */</span></div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a9fe277cff09bccad351007a0c81d5c71">direction</a>.x = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a5e48ac4fbc968f9840b74f973dc9fb8b">lookAtPoint</a>.x - <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.x;</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a9fe277cff09bccad351007a0c81d5c71">direction</a>.y = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a5e48ac4fbc968f9840b74f973dc9fb8b">lookAtPoint</a>.y - <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.y;</div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a9fe277cff09bccad351007a0c81d5c71">direction</a>.z = <a class="code" href="tutorials_2_bloom_2jni_2_native_8cpp.html#a5e48ac4fbc968f9840b74f973dc9fb8b">lookAtPoint</a>.z - <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>.z;</div><div class="line"></div><div class="line">    <span class="comment">/* Normalize the light direction vector. */</span></div><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a9fe277cff09bccad351007a0c81d5c71">direction</a>.normalize();</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#aab5cad73ee7df30441e02fc6850c9802">lightDirectionLocation</a>, 1, (<span class="keywordtype">float</span>*)&amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a9fe277cff09bccad351007a0c81d5c71">direction</a>));</div><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform3fv(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a5e61902f1d78d15ec09ffe9aedf7a036">lightPositionLocation</a>,  1, (<span class="keywordtype">float</span>*)&amp;<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a94371b2818dddf147711a04281e85b05">light</a>.<a class="code" href="struct_light_properties.html#a244d4e24345df514bf5fa813bbbb2868">position</a>));</div></div><!-- fragment --><p> In the shader, we are using a uniform: a boolean flag indicating, whether the plane or cubes are being rendered. Thanks to that, there will be a different position used, which are specific for each geometry.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    if (shouldRenderPlane)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    {</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        modelPosition = planePosition;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    }</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    else</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        modelPosition = vec3(cubesPosition[gl_InstanceID].x, cubesPosition[gl_InstanceID].y, cubesPosition[gl_InstanceID].z);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    }</div></div><!-- fragment --><p> Get uniform location</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a0a7a3011c3e9627a94a2e9667d6d42c2">shouldRenderPlaneLocation</a>   = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a23c751719b1521521f5472a204f6cbf3">programId</a>, <span class="stringliteral">&quot;shouldRenderPlane&quot;</span>));   <span class="comment">/* Uniform holding a boolean value indicating which geometry is being drawn: cube or plane. */</span></div></div><!-- fragment --><p> Set uniform value. False, if cubes are rendered.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a0a7a3011c3e9627a94a2e9667d6d42c2">shouldRenderPlaneLocation</a>,</div><div class="line">                         <span class="keyword">false</span>));</div></div><!-- fragment --><p> True, if a plane is rendered.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a0a7a3011c3e9627a94a2e9667d6d42c2">shouldRenderPlaneLocation</a>,</div><div class="line">                         <span class="keyword">true</span>));</div></div><!-- fragment --><p> Owing to the fact that the shadow map texture is bigger than the normal scene (as already mentioned above), we have to remember to adjust the viewport.</p>
<div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glViewport(0, 0, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a82c85b49db606240a492e41c4f2c805a">width</a>, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#a9c83cfd161f45a62dec8f7d9bd2c891e">height</a>));</div></div><!-- fragment --><p> Our scene is rather simple: there are two cubes placed on the top of a plane. We can introduce some optimisation here, which means the back faces will be culled. We are also setting the polygon offset to eliminate z-fighting in the shadows. Those settings are used only if enabled.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Set the Polygon offset, used when rendering the into the shadow map to eliminate z-fighting in the shadows. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glPolygonOffset(1.0, 0.0));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glCullFace(GL_BACK));</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_POLYGON_OFFSET_FILL));</div></div><!-- fragment --><p> What we need to do is to enable depth testing. When this is enabled, the depth values will be compared and the result will be stored in the depth buffer. </p><div class="fragment"><div class="line">    <span class="comment">/* Enable depth test to do comparison of depth values. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glEnable(GL_DEPTH_TEST));</div></div><!-- fragment --><p> In this step, we want to generate the depth values only, which means we are allowed to disable writing to each framebuffer colour component.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Disable writing of each frame buffer color component. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE));</div></div><!-- fragment --><p> Finally we are ready for the actual rendering.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_etc_texture_2jni_2_native_8cpp.html#a56c5cf8a568cff737ff95520cbe6b405">draw</a>(<span class="keyword">false</span>);</div></div><!-- fragment --><p> If we would like to use the generated depth texture data in a program object, it is enough to query for a shadow sampler uniform location and set the depth texture object as input value for this uniform.</p>
<div class="fragment"><div class="line">    <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a7a9cc0d5b999a202ee132095ab9c8d2c">shadowMapLocation</a>           = <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glGetUniformLocation(<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a23c751719b1521521f5472a204f6cbf3">programId</a>, <span class="stringliteral">&quot;shadowMap&quot;</span>));</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Set active texture. Shadow map texture will be passed to shader. */</span></div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0));</div><div class="line">    <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D, <a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#af2767ed7ab531763fd474a3416feeb5f">shadowMap</a>.<a class="code" href="struct_shadow_map_texture_properties.html#ae5e7d69532bac7c0b1f7b419f0f64c4d">textureName</a>));</div></div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="_astc_textures_8h.html#a410114caf210cb21e6c1701f04eb102d">GL_CHECK</a>(glUniform1i (<a class="code" href="tutorials_2_shadow_mapping_2jni_2_native_8cpp.html#a2b03ad08d97c99eaa3737f07f7ee37cf">cubesAndPlaneProgram</a>.<a class="code" href="struct_cubes_and_plane_program_properties.html#a7a9cc0d5b999a202ee132095ab9c8d2c">shadowMapLocation</a>,      0));</div></div><!-- fragment --><p> Those are basically all the steps we need to proceed in the API. The main mechanism of the shadow mapping technique is handled by the program object. Please look at the shaders shown below.</p>
<p><a class="el" href="struct_vertex.html">Vertex</a> shader code </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/* Number of cubes to be drawn. */ </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define numberOfCubes 2</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;/* [Define attributes] */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;in vec4 attributePosition; /* Attribute: holding coordinates of triangles that make up a geometry. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;in vec3 attributeNormals;  /* Attribute: holding normals. */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;/* [Define attributes] */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform mat4 cameraProjectionMatrix; /* Projection matrix from camera point of view. */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform mat4 lightProjectionMatrix;  /* Projection matrix from light  point of view. */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;uniform mat4 lightViewMatrix; /* View matrix from light point of view. */</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;uniform vec3 cameraPosition;  /* Camera position which we use to calculate view matrix for final pass. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;uniform vec3 lightPosition; /* Vector of position of spot light source. */</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;uniform bool isCameraPointOfView; /* If true: perform calculations from camera point of view, else: from light point of view. */</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;uniform bool shouldRenderPlane;   /* If true: draw plane, else: draw cubes. */</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;uniform vec3 planePosition; /* Position of plane used to calculate translation matrix for a plane. */</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;/* Uniform block holding data used for rendering cubes (position of cubes) - used to calculate translation matrix for each cube in world space. */</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;uniform cubesDataUniformBlock</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;{</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    vec4 cubesPosition[numberOfCubes];</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;};</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;out vec4 outputLightPosition;       /* Output variable: vector of position of spot light source translated into eye-space. */</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;out vec3 outputNormal;              /* Output variable: normal vector for the coordinates. */</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;out vec4 outputPosition;            /* Output variable: vertex coordinates expressed in eye space. */</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;out mat4 outputViewToTextureMatrix; /* Output variable: matrix we will use in the fragment shader to sample the shadow map for given fragment. */</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;void main()</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    /* View matrix calculated from camera point of view. */</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    mat4 cameraViewMatrix;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    /* Matrices and vectors used for calculating output variables. */</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    vec3 modelPosition;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    mat4 modelViewMatrix;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    mat4 modelViewProjectionMatrix;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    /* Model consists of plane and cubes (each of them has different colour and position). */</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    /* [Use different position for a specific geometry] */</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    if (shouldRenderPlane)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        modelPosition = planePosition;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    else</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        modelPosition = vec3(cubesPosition[gl_InstanceID].x, cubesPosition[gl_InstanceID].y, cubesPosition[gl_InstanceID].z);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    /* [Use different position for a specific geometry] */</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    /* Create transformation matrix (translation of a model). */</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    mat4 translationMatrix = mat4 (1.0,             0.0,             0.0,             0.0, </div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                                   0.0,             1.0,             0.0,             0.0, </div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                   0.0,             0.0,             1.0,             0.0, </div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                   modelPosition.x, modelPosition.y, modelPosition.z, 1.0);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    /* Compute matrices for camera point of view. */</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    if (isCameraPointOfView == true)</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        cameraViewMatrix = mat4 ( 1.0,                 0.0,               0.0,              0.0, </div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                  0.0,                 1.0,               0.0,              0.0, </div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                                  0.0,                 0.0,               1.0,              0.0, </div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                  -cameraPosition.x,  -cameraPosition.y, -cameraPosition.z, 1.0);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                                            </div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        /* Compute model-view matrix. */</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        modelViewMatrix = cameraViewMatrix * translationMatrix;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        /* Compute  model-view-perspective matrix. */</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        modelViewProjectionMatrix = cameraProjectionMatrix * modelViewMatrix;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    </div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    }</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    /* Compute matrices for light point of view. */</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    else</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        /* Compute model-view matrix. */</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        modelViewMatrix = lightViewMatrix * translationMatrix;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        /* Compute model-view-perspective matrix. */</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        modelViewProjectionMatrix = lightProjectionMatrix * modelViewMatrix;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    /* [Define bias matrix] */</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    /* Bias matrix used to map values from a range &lt;-1, 1&gt; (eye space coordinates) to &lt;0, 1&gt; (texture coordinates). */</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    const mat4 biasMatrix = mat4(0.5, 0.0, 0.0, 0.0,</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                 0.0, 0.5, 0.0, 0.0,</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                                 0.0, 0.0, 0.5, 0.0,</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                                 0.5, 0.5, 0.5, 1.0);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    /* [Define bias matrix] */</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    </div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    /* Calculate normal matrix. */</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    mat3 normalMatrix = transpose(inverse(mat3x3(modelViewMatrix)));</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    /* Calculate and set output vectors. */</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    outputLightPosition = modelViewMatrix * vec4(lightPosition, 1.0);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    outputNormal        = normalMatrix    * attributeNormals;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    outputPosition      = modelViewMatrix * attributePosition;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    if (isCameraPointOfView)</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        /* [Calculate matrix that will be used to convert camera to eye space] */</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        outputViewToTextureMatrix = biasMatrix * lightProjectionMatrix * lightViewMatrix * inverse(cameraViewMatrix);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        /* [Calculate matrix that will be used to convert camera to eye space] */</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    /* Multiply model-space coordinates by model-view-projection matrix to bring them into eye-space. */</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    gl_Position = modelViewProjectionMatrix * attributePosition;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;}</div></div><!-- fragment --><p> We use one program object to render the cubes and plane from the camera and light point of view. The vertex shader just uses different input data to render the specific geometry and different matrices are used for translating the vertices into a specific space. There is however one important step which has not been mentioned before.</p>
<p>If we are rendering a geometry from the spot lights point of view (to get depth values which are then stored in the shadowMap texture), then we need to sample the texture to get the depth value of a specific fragment, but this time the cameras point of view is taken into account. We have to somehow convert one space into another. And this is why we are calculating the <em>outputViewToTextureMatrix</em> matrix.</p>
<p>A bias matrix helps us with converting coordinates from eye space (from a range &lt;-1, 1&gt;) to values from texture coordinates range: &lt;0, 1&gt;.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;    /* Bias matrix used to map values from a range &lt;-1, 1&gt; (eye space coordinates) to &lt;0, 1&gt; (texture coordinates). */</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    const mat4 biasMatrix = mat4(0.5, 0.0, 0.0, 0.0,</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;                                 0.0, 0.5, 0.0, 0.0,</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                                 0.0, 0.0, 0.5, 0.0,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                                 0.5, 0.5, 0.5, 1.0);</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;        outputViewToTextureMatrix = biasMatrix * lightProjectionMatrix * lightViewMatrix * inverse(cameraViewMatrix);</div></div><!-- fragment --><p> The whole idea is represented with the schema shown below.</p>
<div class="image">
<img src="ShadowMappingMatrixSchema.png" alt="ShadowMappingMatrixSchema.png"/>
<div class="caption">
Converting camera eye space to spot light NDC space schema.</div></div>
<p> When we get this value, we are ready to issue the fragment shader operations. There is directional lighting implemented, which should be clear for a reader. There are also spot light calculations issued.</p>
<p>Fragment shader code</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;precision highp float;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;precision highp sampler2DShadow;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;in vec4 outputLightPosition;       /* Vector of the spot light position translated into eye-space. */</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;in vec3 outputNormal;              /* Normal vector for the coordinates. */</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;in vec4 outputPosition;            /* Vertex coordinates expressed in eye space. */</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;in mat4 outputViewToTextureMatrix; /* Matrix we will use in the fragment shader to sample the shadow map for given fragment. */</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;uniform vec4            colorOfGeometry; /* Colour of the geometry. */</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;uniform vec3            lightDirection;  /* Normalized direction vector for the spot light. */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;uniform sampler2DShadow shadowMap;       /* Sampler of the depth texture used for shadow-mapping. */</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;out vec4 color; /* Output colour variable. */</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;#define PI 3.14159265358979323846</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;/* Structure holding properties of the directional light. */</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;struct DirectionalLight</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;{</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    float ambient;   /* Value of ambient intensity for directional lighting of a scene. */</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    vec3  color;     /* Colour of the directional light. */</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    vec3  direction; /* Direction for the directional light. */</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;};</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;/* Structure holding properties of spot light. */</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;struct SpotLight</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    float ambient;              /* Value of ambient intensity for spot lighting. */</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    float angle;                /* Angle between spot light direction and cone face. */</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    float spotExponent;         /* Value indicating intensity distribution of light. */</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    float constantAttenuation;  /* Value of light&#39;s attenuation. */</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    float linearAttenuation;    /* Value of linear light&#39;s attenuation. */</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    float quadraticAttenuation; /* Value of quadratic light&#39;s attenuation. */</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    vec3  direction;            /* Vector of direction of spot light. */</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    vec4  position;             /* Coordinates of position of spot light source. */</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;};</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;void main()</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    DirectionalLight directionalLight;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    directionalLight.ambient   = 0.01;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    directionalLight.color     = vec3(1.0,  1.0,  1.0);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    directionalLight.direction = vec3(0.2, -1.0, -0.2);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    SpotLight spotLight;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    spotLight.ambient              = 0.1;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    spotLight.angle                = 30.0;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    spotLight.spotExponent         = 2.0;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    spotLight.constantAttenuation  = 1.0;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    spotLight.linearAttenuation    = 0.1;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    spotLight.quadraticAttenuation = 0.9;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    spotLight.direction            = lightDirection;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    spotLight.position             = outputLightPosition;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    /* Compute distance between the light position and the fragment position. */</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    float xDistanceFromLightToVertex = (spotLight.position.x - outputPosition.x);</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    float yDistanceFromLightToVertex = (spotLight.position.y - outputPosition.y);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    float zDistanceFromLightToVertex = (spotLight.position.z - outputPosition.z);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    float distanceFromLightToVertex  = sqrt((xDistanceFromLightToVertex * xDistanceFromLightToVertex) +</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;                                            (yDistanceFromLightToVertex * yDistanceFromLightToVertex) +</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                                            (zDistanceFromLightToVertex * zDistanceFromLightToVertex));</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    /* Directional light. */</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    /* Calculate the value of diffuse intensity. */</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    float diffuseIntensity = max(0.0, -dot(outputNormal, normalize(directionalLight.direction)));</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    /* Calculate colour for directional lighting. */</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    color = colorOfGeometry * vec4(directionalLight.color * (directionalLight.ambient + diffuseIntensity), 1.0);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    /* Spot light. */</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    /* Compute the dot product between normal and light direction. */</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    float normalDotLight = max(dot(normalize(outputNormal), normalize(-spotLight.direction)), 0.0);</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    /* Shadow. */</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    /* Position of the vertex translated to texture space. */</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    vec4 vertexPositionInTexture = outputViewToTextureMatrix * outputPosition;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    /* Normalized position of the vertex translated to texture space. */</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    vec4 normalizedVertexPositionInTexture = vec4(vertexPositionInTexture.x / vertexPositionInTexture.w,</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                                  vertexPositionInTexture.y / vertexPositionInTexture.w,</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                                                  vertexPositionInTexture.z / vertexPositionInTexture.w,</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                                                  1.0);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    /* Depth value retrieved from the shadow map. */</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    float shadowMapDepth = textureProj(shadowMap, normalizedVertexPositionInTexture);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    /* Depth value retrieved from drawn model. */</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    float modelDepth = normalizedVertexPositionInTexture.z;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    /* Calculate vector from position of light to position of fragment. */</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    vec3 vectorFromLightToFragment = vec3(outputPosition.x - spotLight.position.x,</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                                        outputPosition.y - spotLight.position.y,</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                                        outputPosition.z - spotLight.position.z);</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    /* Calculate cosine value of angle between vectorFromLightToFragment and vector of spot light direction. */</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    float cosinusAlpha = dot(spotLight.direction, vectorFromLightToFragment) /</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                                (sqrt(dot(spotLight.direction, spotLight.direction)) *</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                            sqrt(dot(vectorFromLightToFragment, vectorFromLightToFragment)));</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    /* Calculate angle for cosine value. */</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    float alpha = acos(cosinusAlpha);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    /*</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;     * Check angles. If alpha is less than spotLight.angle then the fragment is inside light cone.</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;     * Otherwise the fragment is outside the cone - it is not lit by spot light.</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;     */</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    const float shadowMapBias = 0.00001;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    if (alpha &lt; spotLight.angle)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        if (modelDepth &lt; shadowMapDepth + shadowMapBias)</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            float spotEffect = dot(normalize(spotLight.direction), normalize(vectorFromLightToFragment));</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            spotEffect = pow(spotEffect, spotLight.spotExponent);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            /* Calculate total value of light&#39;s attenuation. */</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;            float attenuation = spotEffect /</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                                (spotLight.constantAttenuation  +</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                spotLight.linearAttenuation    * distanceFromLightToVertex +</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                                spotLight.quadraticAttenuation * distanceFromLightToVertex * distanceFromLightToVertex);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            /* Calculate colour for spot lighting.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;             * Scale the colour by 0.5 to make the shadows more obvious. */</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            color = color / 0.5 + (attenuation * (normalDotLight + spotLight.ambient));</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    }</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    /* Angle (in radians) between the surfaces normal and the light direction. */</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    float angle = acos(dot(normalize(outputNormal), normalize(spotLight.direction)));</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    /*</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;     * Reduce the intensity of the colour if the object is facing away from the light.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;     * scaleIntensity is 1 when the light is facing the surface, 0 when its facing the opposite direction.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;     */</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    float scaleIntensity = smoothstep(0.0, PI, angle);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    vec4 scaleVector = vec4(scaleIntensity, scaleIntensity, scaleIntensity, 1.0);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    color *= scaleVector;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div></div><!-- fragment --><p> The main idea behind this is simple: we take a fragment, check, whether it is placed inside the spot light cone (with checking the angle between the fragment and the spot light direction). Then the fragment is considered as lit by a spot light, or outside: in this case no spot light is added to a fragment. In the situation when a fragment is lit by the spot light, we need to check whether it should be obscured by a shadow.</p>
<p>This is where the previously calculated <em>outputViewToTextureMatrix</em> matrix will be used. We need to sample the depth texture with properly calculated coordinates for a given fragment and compare the retrieved value with the model depth. In the comparison there is also a <em>shadowMapBias</em> added to avoid artefacts. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
