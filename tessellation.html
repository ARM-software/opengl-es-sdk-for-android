<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenGL ES SDK for Android: Displacement mapping with tessellation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenGL ES SDK for Android
<span id="armdevcenter"><a href="https://developer.arm.com/">ARM Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tessellation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Displacement mapping with tessellation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This sample uses OpenGL ES 3.1 and the Android extension pack to perform displacement mapping with tessellation. The sample investigates common techniques used to improve performance and visuals.</p>
<div class="image">
<img src="tessellation-title.png" alt="tessellation-title.png"/>
</div>
<h1><a class="anchor" id="tessellationIntroduction"></a>
Introduction</h1>
<p>The Android extension pack adds many new features to mobile, that have until now been exclusive to desktop OpenGL. New pipeline stages, such as geometry and tessellation shaders, are now available to the programmer. This sample showcases the use of tessellation on a Mali GPU.</p>
<p>In the sample we apply a displacement map to a coarse mesh, to generate detailed geometry on the fly. We combine this with a screen-space based LOD computation to progressively vary the level of detail, depending on how much screen area the geometry covers.</p>
<h2><a class="anchor" id="tessellationAboutTessellation"></a>
About tessellation</h2>
<p>Tessellation introduces three optional pipeline stages - two of them programmable - located conveniently after the vertex shader and before the fragment shader. These stages are capable of generating additional geometry. How many triangles, or where the generated geometry should be placed, is programmable in the <em>Tessellation Control</em> and <em>Tessellation Evaluation</em> shaders. These both operate on a per-vertex basis, and can see all the vertices of a single primitive.</p>
<p>The ability to generate additional geometry gives increased expressive power to the programmer. However, the ease of use is debatable. Realtime tessellation is notorious for requiring great care to avoid performance issues, patch gaps, mesh swimming or other visual artifacts. In this sample we will take a look at one particular usage of tessellation, as well as some tricks that can be applied to improve performance and hide artifacts. Before moving on, we briefly mention some common use cases, some of which we leave to the reader for further investigation:</p>
<ul>
<li><b>Continuous level-of-detail (LOD)</b>: Geometry that covers only a handful of pixels clearly has lower requirements for detail than geometry that meets the viewer face-on. Traditionally this has been handled by dividing a mesh into several distinct meshes, each with a different level of detail. While this does the job, it is often difficult to hide the <em>popping</em> that occurs, when switching between discrete levels. Tessellation can be used to provide a seemingly continuous transition between detail levels.</li>
<li><b>Displacement mapping</b>: Models that are handcrafted by artists tend to have much higher triangle counts before they are placed into a game, where they must be downgraded to meet the polygon budget. Displacement mapping stores details of the high quality mesh as a texture, that can be applied at run time to restore the fine details, using some LOD scheme as mentioned above.</li>
<li><b>Subdivision surfaces</b>: Each polygonal mesh has a well-defined smooth surface associated with it. A refinement algorithm computes the smooth surface as the limit of a recursive process (the exact surface depends on the method used). One such method is Catmull-Clark subdivision. A popular approach by Loop and Schaefer [2] is suited for the GPU, and approximates the surface with bicubic patches.</li>
<li><b>Displaced subdivision surfaces</b>: Lee et al. had the splendid idea of combining subdivision surfaces with displacement mapping [3]. The result is compact storage of fine-detail models, well suited for animation or rendering.</li>
<li><b>Smoothing 2D surfaces</b>: GUI elements or text can be described by higher order geometry, such as bezier curves, to provide potentially infinite smoothness. Tessellation could be used to generate the geometry to render smooth 2D graphics.</li>
</ul>
<p>For further reading, we refer to <em>10 fun things to do with tessellation</em> [4], describing more uses such as terrain or hair rendering. For more information about the basics of tessellation, these articles ([5], [6]) provide a concise introduction.</p>
<h2><a class="anchor" id="tessellationDisplacementMapping"></a>
Displacement mapping</h2>
<p>In this sample we apply a displacement map to a spherical mesh, producing cool planetoidal-esque shapes. We begin by procedurally generating a cube mesh, where each face is predivided into a number of quadrilateral <em>patches</em>. A patch is a new primitive type, and defines the points that can be operated on in the tessellation shaders. These patches are further subdivided - into proper triangles - with a level of detail dictated by the control shader. As shown in the figure, we can produce a sphere from the tessellated mesh by normalizing each vertex to unit length.</p>
<div class="image">
<img src="tessellation-cube-to-sphere-2.png" alt="tessellation-cube-to-sphere-2.png"/>
<div class="caption">
Figure 2: Each patch of the initial cube is further subdivided into triangles. Each point in the triangle is then normalized to unit length to produce a smooth sphere. Note that a uniform tessellation on the </div></div>
<p> cube will be denser near the seams of the faces on the sphere."</p>
<p>The displacement map is generated using the popular 3D modelling package Blender, by the use of combining procedural textures of different types. To apply the map to the sphere, we need a mapping between vertex coordinates on the sphere and texel coordinates in the texture. Several methods for mapping a sphere exist, each with their own advantages and drawbacks. We chose a <em>cubemap</em>, where each side of the initial cube is mapped to one square in a texture of six.</p>
<div class="image">
<img src="tessellation-map.png" alt="tessellation-map.png"/>
<div class="caption">
Figure 3: The displacement map consists of 6 squares, corresponding to each face of the cube. Note that there are no visible seams between the faces in this figure.</div></div>
<p> Sampling the cubemap is done by intersecting the sphere normal with the associated cube face. The mathematics for this turn out to be very simple, making cubemaps one of the more efficient mappings. Cubemap texture sampling is available as a hardware-level operation in the shaders.</p>
<p>Care should be taken to avoid visible seams between cubemap faces. Seamless filtering is available as a texture parameter hint in OpenGL, and may avoid issues. Further improvements can be made by averaging edges in the texture beforehand.</p>
<div class="image">
<img src="tessellation-sphere-displaced.png" alt="tessellation-sphere-displaced.png"/>
<div class="caption">
Figure 4: The above cubemap applied to the tessellated sphere.</div></div>
<p> In the evaluation shader, we renormalize the generated vertices and sample the texture using the sphere normal (parallel to the vertex position in our case!). The vertex is finally displaced by an amount proportional to the color of the texel.</p>
<h1><a class="anchor" id="tessellationOptimizations"></a>
Optimizations</h1>
<p>While the basics of the displacement mapping technique are apparently simple, a good result does not come along by itself. In the next sections we describe some pitfalls associated with tessellation, as well as some optimizations that can be made to improve performance and visuals.</p>
<h2><a class="anchor" id="tessellationBackfaceCulling"></a>
Backface culling</h2>
<p>The tessellation evaluation shader will be run for each vertex generated by the tessellator. However, many of these vertices might end up being invisible when finally rendered to the screen. It is therefore beneficial to determine whether or not we can <em>cull</em> a patch, before submitting it to the tessellator, where further work would be wasted.</p>
<p>We can cull a patch by setting its tessellation factors to zero, effectively generating no additional geometry. This is done in the control shader, by checking whether all the vertices of a patch are either offscreen or are hidden by front geometry. In the case of a perfect sphere, a patch is hidden if all of its normals are facing away from the camera in view-space. That is, the z-component of each normal is negative. However, when the sphere is morphed we may have geometry that is displaced far enough to be visible from behind the sphere. A straightforward fix is to require that the z-component is less than some handpicked bias.</p>
<p>Finally, we project the patch vertices to normalized device coordinates, and compare the vertices with the frustum bounds to determine if the patch is fully offscreen.</p>
<h2><a class="anchor" id="tessellationProgressiveLevelOfDetail"></a>
Progressive level of detail</h2>
<p>Patches that do not cover a large screen area need not be tessellated too much. We take advantage of this to increase performance. The method used in the sample is a naive implementation of screen-space coverage adaptive tessellation, and works as follows:</p>
<ol type="1">
<li>Project the patch vertices to screen space</li>
<li>Compute the lengths of each projected edge (the unit will be in pixels)</li>
<li>The tessellation level of each edge is computed as a linear function of its screen space length. An edge is maximally tessellated when its length is equal to a handpicked threshold.</li>
<li>The inner tessellation levels are computed as the average of the associated outer levels.</li>
</ol>
<p>Care must be taken to ensure that the edge levels are computed consistently across all patches. If two neighbouring edges do not have the same tessellation level, horrible gaps or flickering may occur.</p>
<h2><a class="anchor" id="tessellationMipmapSelection"></a>
Mipmap selection</h2>
<p>Tessellation of meshes has close ties with sampling theory. I.e. the generated geometry must have a high enough sampling rate, in order to reconstruct the geometry described by the displacement map. If the sampling rate is too low, we could attempt to reduce the frequency of the displacement map to compensate.</p>
<p>In the sample code, we attempt to do this by selecting a lower quality <em>mipmap</em> of the texture, depending on the tessellation. Mipmaps are pre-calculated, optimized versions of the original texture, each of which downscaled by a factor of two from the previous level. You can think of this as reducing the frequency of the displacement geometry by a half, for each mipmap level.</p>
<p>A clever strategy could be to actually analyze the frequency components of the map, and select an appropriate mipmap level based on the tessellation level. In the sample we simply linearly select between some lower-bounded mipmap and the best mipmap based on camera distance.</p>
<h2><a class="anchor" id="tessellationAliasing"></a>
Aliasing</h2>
<p>It is possible that the displacement map simply has too much detail, than can be represented by the tessellated mesh. The result of this is <em>aliasing</em>, and can be painfully visible.</p>
<p>The following figures demonstrate the phenomenom. In both cases, the displacement map consisted of a single sharp line, dividing the map into a black and white section. In the first figure, the line was aligned with the grid, but slightly offset from the sampling center. In the second figure, the line was not aligned with the grid.</p>
<div class="image">
<img src="tessellation-aliasing-1.png" alt="tessellation-aliasing-1.png"/>
<div class="caption">
Figure 5: The mesh suffers aliasing in one dimension due to high-frequency components in the displacement map that are insufficiently sampled by the tessellation.</div></div>
 <div class="image">
<img src="tessellation-aliasing-2.png" alt="tessellation-aliasing-2.png"/>
<div class="caption">
Figure 6: The mesh suffers aliasing in two dimensions due to low sampling rate, and misalignment between the underlying sampling points and the displacement map.</div></div>
<p> This jarring effect can be somewhat reduced by simply increasing the global tessellation factor, but that approach is not scaleable. Several techniques have been developed for preventing aliasing in tessellation. Such a technique must prevent gaps between patches and mesh swimming (vertices that squirm around when the level of detail is varied by the camera distance). We mention some ideas:</p>
<ul>
<li>Importance sampling: The generated tessellation points are shifted such that they align better with contours in the displacement map.</li>
<li>Noise and dithering: Hide the effect by adding noise to the displacement map. We employ this strategy in one of our displacement maps that initially had visible artifacts from steep hills.</li>
</ul>
<div class="image">
<img src="tessellation-aliasing-noise.png" alt="tessellation-aliasing-noise.png"/>
<div class="caption">
Figure 7: The effects of aliasing can be somewhat hidden by adding noise to the displacement map.</div></div>
 <h2><a class="anchor" id="tessellationGeometryAdaptive"></a>
Geometry adaptive tessellation</h2>
<p>If your mesh consists of large flat areas - such as <em>the world's greatest virtual concrete slab</em> [1] - we can reduce the triangle count with no apparent loss of fidelity. Geometry adaptive tessellation does this by examining the curvature or the underlying surface, and varies the level of tessellation accordingly. A possible approach applied to subdivision surfaces is described in [8].</p>
<h1><a class="anchor" id="tessellationFinalRemarks"></a>
Final remarks</h1>
<p>Hopefully, this sample has demonstrated the potential use cases of GPU accelerated tessellation, as well as what pitfalls that lay before the eager programmer. If the reader decides to go further with tessellation, it is important to consider that the Mali GPU - in its own peculiarity - does not have a dedicated tessellation unit. The performance of tessellation can be highly dependent on the underlying hardware, and should be used with care.</p>
<h1><a class="anchor" id="tessellationReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] The Tech Report. "The world's greatest virtual concrete slab", <a href="http://techreport.com/review/21404/crysis-2-tessellation-too-much-of-a-good-thing/2">available online.</a></p>
<p><a class="anchor" id="ref2"></a>[2] Loop, Schaefer. "Approximating Catmull-Clark Subdivision Surfaces with Bicubic Patches", <a href="http://research.microsoft.com/en-us/um/people/cloop/acctog.pdf">available online.</a></p>
<p><a class="anchor" id="ref3"></a>[3] Lee, et al.. "Displaced Subdivision Surfaces", <a href="http://graphics.stanford.edu/courses/cs468-01-winter/papers/lmh-dss-00.pdf">available online.</a></p>
<p><a class="anchor" id="ref4"></a>[4] Castaño, Ignacio. "10 Fun Things to do with Tessellation", <a href="http://www.ludicon.com/castano/blog/2009/01/10-fun-things-to-do-with-tessellation/">available online.</a></p>
<p><a class="anchor" id="ref5"></a>[5] The Little Grasshopper. "Triangle Tessellation with OpenGL 4.0", <a href="http://prideout.net/blog/?p=48">available online.</a></p>
<p><a class="anchor" id="ref6"></a>[6] OpenGL SuperBible. "Primitive Processing in OpenGL", <a href="http://www.informit.com/articles/article.aspx?p=2120983">available online.</a></p>
<p><a class="anchor" id="ref7"></a>[7] Rákos, Daniel. "History of hardware tessellation", <a href="http://rastergrid.com/blog/2010/09/history-of-hardware-tessellation/">available online.</a></p>
<p><a class="anchor" id="ref8"></a>[8] GPU Gems 2. "Adaptive Tessellation of Subdivision Surfaces with Displacement Mapping", <a href="http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter07.html">available online.</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2017</a>
    </li>
  </ul>
</div>
</body>
</html>
